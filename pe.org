:org_mode_options:
#+TODO: ACTIVE | DISABLED
#+STARTUP: indent
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+STARTUP: overview
#+OPTIONS: ^:nil
:END:

* Explanation
The site: https://projecteuler.net/  has some great math programming problems on
it. They are fun to solve and more fun when done in Odin Lang https://odin-lang.org/

If any of these below problems are solved in the most optimal way, that is
purely by accident =)

Also, some might not work, but they did at one point
Also also, *most* are super mathy, just fyi

$LaTex$

#+begin_src emacs-lisp :tangle no
;; adjust default "look" of latex
;; this is in my config.org, but just in case you want bigger :scale 1.5 or something
(setq org-format-latex-options '(:foreground default :background default :scale 1.5 :html-foreground "Black" :html-background "Transparent" :html-scale 1.0 :matchers ("begin" "$1" "$" "$$" "\\(" "\\[")))
#+end_src

* ob-odin.el and gdb testing area
Last one here is intended to be buggy to show how to use gdb and ob-odin.el
...
C-c C-c in code blocks to build and run
outputs to #+results
...
M-x gdb file[.exe]
or M-x my/gdb to start debugging
...
if you are using windows, it's best to debug with visual studio =(
BUT gdb-msvc might be an option
#+begin_src odin
  fmt.println("derp")
#+end_src

#+begin_src odin :cmpflag -debug
  if ODIN_DEBUG {
    fmt.println("debug") // just to show that debugging works
  }
  return
#+end_src

#+begin_src odin :norun t :cmpflag -debug :includes core:math core:fmt
  // compute first n prime numbers.. 3 inf loops and an addition error (can you find them all?)
  sum :: proc(arr : []int, n : int) -> int
  {
    i : int
    total : int
    for i=0; i<n; i+=1 {
      total =+ arr[i]
    }
    return total
  }

  get_primes :: proc(n : int) -> []int
  {
    result : []int = make([]int, n)
    i := 0
    x := 2
    for ; i<n; {
      if is_prime(x) {
        result[i] = x
        i+=1 // note: inf loop here
        x+=2
      }
    }
    return result
  }

  is_prime :: proc(x : int) -> bool
  {
    if x % 2 == 0 {
      return false
    }
    for i:=3; i <= cast(int)math.sqrt_f32(cast(f32)x); i+=2 {
      if x % i == 0 {
        return false
      }
    }
    return true
  }

  main :: proc() {
    if ODIN_DEBUG {
      fmt.println("debug build")
    }

    n := 10
    primes := get_primes(n)

    s := sum(primes, n)
    fmt.printf("The sum of the first %d primes is %s\n", n, s)
  }
#+end_src

* util - random stuff that might be helpful
#+begin_src odin :main no :comments link :tangle util/util.odin
package util

import "core:fmt"
import "core:math"
import "core:strings"

is_prime :: proc(x : int) -> bool {
  if x == 1 do return false
  if x == 2 do return true
  if x % 2 == 0 {
    return false;
  }
  for i:=3; i <= cast(int)math.sqrt_f32(cast(f32)x); i+=2 {
    if x % i == 0 {
      return false;
    }
  }
  return true;
}

is_palindrome :: proc(n : int) -> bool {
	res : bool = true

	tmp := n
	len_of_number_n := 1
	for i:=0; tmp >= 10; i+=1 {
		tmp = tmp/10
		len_of_number_n += 1
	}

	str := fmt.tprintf("%d", n)
	for j:=0; j < len_of_number_n / 2; j+=1 {
		if (str[j:j+1] != str[len_of_number_n-(j+1):len_of_number_n-j]) {
			res = false
		}
	}
	return res
}

get_combination_util :: proc(arr: []int, data: []int, start,end,idx,r: int, ret: ^[dynamic][]int) {
  if idx == r {
	  data_cpy := make([]int, r)
    for i,di in data {
	    data_cpy[di] = i
    }
    append(ret, data_cpy)
    return
  }
  for i:=start; i<=end && end-i+1 >= r-idx; i+=1 {
    data[idx] = arr[i]
    get_combination_util(arr, data, i+1, end, idx+1, r, ret)
  }
}
get_combinations :: proc(arr: []int, r: int, ret: ^[dynamic][]int) {
  data := make([]int, r)
  get_combination_util(arr, data, 0, len(arr)-1, 0, r, ret)
}

print_combination_util :: proc(arr: []int, data: []int, start,end,idx,r: int) {
  if idx == r {
    for j in 0..<r {
      fmt.printf("%d ", data[j])
    }
    fmt.println()
    return
  }
  for i:=start; i<=end && end-i+1 >= r-idx; i+=1 {
    data[idx] = arr[i]
    print_combination_util(arr, data, i+1, end, idx+1, r)
  }
}
print_combinations :: proc(arr: []int, r: int) {
  data : []int = make([]int, r)
  print_combination_util(arr, data, 0, len(arr)-1, 0, r)
}

permute :: proc(str : string, l,r : int, ret : ^[dynamic]string) {
  if l == r {
    append(ret, strings.clone(str))
  } else {
    for i in l..=r {
      swap(str, l, i)
      permute(str, l+1, r, ret)
      swap(str, l, i)
    }
  }
}

swap :: proc(s : string, i,j : int) {
  p1 := raw_data(s[i:])
  p2 := raw_data(s[j:])
  p1[0], p2[0] = s[j], s[i]
}

// n Choose r ... combinatorics
nCr :: proc(n, r: int) -> int {
  r := r
	ret : int
	if n-r < r {
		r = n-r
	}
	ret = 1
	for i:=1; i<=r; i+=1 {
		ret = (ret * (n-i+1))/i
    if ret < 0 do return -1 // return -1 if overflow
	}
	return ret;
}

/*
fmt.println("combination")
arr : []int = []int{1,2,3,4}
print_combinations(arr, 3)

fmt.println("premutation") 
ret : [dynamic]string
permute("hello", 1,2, &ret)
fmt.println(ret)
,*/
#+end_src

* Prob 001 - Multiples of 3 and 5
#+begin_src odin
limit := 1000
sum := 0
for i:=1; i < limit; i+=1 {
  if (i % 3 == 0) || (i % 5 == 0) {
    sum += i
  }
}
fmt.println("sum:", sum)
#+end_src

#+RESULTS:
: sum: 233168

* Prob 002 - Even Fibonacci Number
#+begin_src odin
  sum_even_fibs :: proc(n : i64) -> f64 {
    sum : f64 = 0
    prev1 : i64 = 0
    prev2 : i64 = 1
    for i:i64=0; i<n; i+=1 {
      tmp := prev2
      prev2 = prev1 + prev2
      if (prev2 > n) do break // don't cnt
      prev1 = tmp
      if (prev2 % 2) == 0 {
        sum += cast(f64)prev2
      }
    }
    return sum
  }

  result : f64 = sum_even_fibs(4_000_000)
  fmt.printf("result: %f\n", result)
#+end_src

#+RESULTS:
: result: 4613732.000

* Prob 003 - Largest Prime Factor
#+begin_src odin :var n=1000 :post asValue(name="primes",val=*this*) :results drawer file :file primes.csv
  make_primes :: proc (n : int) {
    p := 5
    for prime_idx:=3; prime_idx<=n; {
      // prime check
      is_prime := true
      if (p % 2 == 0) || (p % 3 == 0) {
        is_prime = false
      } else {
        for i:=5; i * i <= p; {
          if (p % i == 0) || (p % (i+2) == 0) {
            is_prime = false
          }
          i += 6
        }
      }

      // now is_prime tells if p is prime
      if is_prime {
        prime_idx += 1
        fmt.printf(", %d", p)
        p += 2 // check next possible prime
      } else {
        p += 2
      }
    }
    fmt.printf("")
  }

  fmt.printf("%d, %d", 2, 3)

  // output n more primes
  make_primes(n)
#+end_src

#+RESULTS:
:results:
#+NAME: primes
[[file:primes.csv]]
:end:

#+begin_src odin :var primes=primes :includes core:os core:io core:encoding/csv core:strconv core:strings
  file,ferr := os.open(primes)
  if ferr != 0 {
    fmt.println("error")
    return
  }
  defer os.close(file)

  readr,_ := io.to_reader(os.stream_from_handle(file))
  csvreadr : csv.Reader
  csv.reader_init(&csvreadr, readr)
  strs, err := csv.read(&csvreadr)

  primelist := make(map[int]int)
  defer delete(primelist)

  for i:=0; i<len(strs); i+=1 {
    ok : bool
    primelist[i],ok = strconv.parse_int(strings.trim(strs[i], " "))
    if !ok {
      fmt.printf("error")
    }
  }

  largest_prime_factor :: proc(n : int, primelist : map[int]int) -> int {
    // start div by 2, then 3... until you are left with one last "largest" prime then return that
    mn := n
    pidx := 0
    last_p := 0
    for pidx=0; pidx < len(primelist); {
      if mn % primelist[pidx] == 0 {
        mn = mn / primelist[pidx]
        last_p = pidx
      } else {
        pidx += 1
      }
    }
    return cast(int)primelist[last_p]
  }

  result : int = largest_prime_factor(600851475143, primelist)
  fmt.printf("result: %d\n", result)
#+end_src

#+RESULTS:
: result: 6857

* Prob 004 - Largest Palindrome Product
#+begin_src odin :main no :comments link :tangle src/largest_palindrome_product.odin
package largest_palindrome_product

import "core:fmt"
import "../util"

largest_three_digit_prod_palindrome :: proc() -> int {
	n1 := 0
	n2 := 0
	max := 0
	for ; n1 < 999; n1+=1 {
		n2 = 0
		for ; n2 < 999; n2+=1 {
			if util.is_palindrome(n1 * n2) {
				if n1 * n2 > max do	max = n1*n2
			}
		}
	}
	return max
}

main :: proc() {
  n1 := largest_three_digit_prod_palindrome()
  fmt.printf("result: %d\n", n1)
}
#+end_src

#+RESULTS:
: result: 906609

* Prob 005 - Smallest Multiple
#+begin_src odin
  smallest_number_div_by_1_to_20 :: proc () -> int {
    tmp := 1
    for ;; {
      all_div := true
      for i:=2; i<=20; i+=1 {
        if tmp % i != 0 {
          all_div = false
          break
        }
      }
      if all_div do break
      tmp += 1
    }
    return tmp
  }
  n1 := smallest_number_div_by_1_to_20()
  fmt.printf("result: %d\n", n1)
#+end_src

#+RESULTS:
: result: 232792560

* Prob 006 - Sum Square Difference
#+begin_src odin
  diff_sum_of_sqr_and_sqr_of_sum :: proc (n : int) -> int {
    first_sums_of_sqrs := 0
    first_sqrs_of_sums := 0
    for i:=1; i<=n; i+=1 {
      first_sums_of_sqrs += i*i
      first_sqrs_of_sums += i
    }
    first_sqrs_of_sums *= first_sqrs_of_sums

    return abs(first_sqrs_of_sums - first_sums_of_sqrs)
  }

  n1 := diff_sum_of_sqr_and_sqr_of_sum(100)
  fmt.printf("result: %d\n", n1)
#+end_src

#+RESULTS:
: result: 25164150

* Prob 007 - 10001st prime
#+begin_src odin
  big_prime :: proc (n : int) -> int {
    p := 5
    for prime_idx:=3; prime_idx<=n; {
      // prime check
      is_prime := true
      if (p % 2 == 0) || (p % 3 == 0) {
        is_prime = false
      } else {
        for i:=5; i * i <= p; {
          if (p % i == 0) || (p % (i+2) == 0) {
            is_prime = false
          }
          i += 6
        }
      }

      // now is_prime tells if p is prime
      if is_prime {
        prime_idx += 1
        p += 2; // check next possible prime
      } else {
        p += 2
      }
    }

    p -= 2
    return p
  }

  n1 := big_prime(10_001); // note: doesn't work for 3rd prime or less
  fmt.printf("result: %d\n", n1)
#+end_src

#+RESULTS:
: result: 104743

* Prob 008 - Largest Product in a Series
#+begin_src odin :includes core:strings core:strconv
  bignumstr : string = `
  73167176531330624919225119674426574742355349194934
  96983520312774506326239578318016984801869478851843
  85861560789112949495459501737958331952853208805511
  12540698747158523863050715693290963295227443043557
  66896648950445244523161731856403098711121722383113
  62229893423380308135336276614282806444486645238749
  30358907296290491560440772390713810515859307960866
  70172427121883998797908792274921901699720888093776
  65727333001053367881220235421809751254540594752243
  52584907711670556013604839586446706324415722155397
  53697817977846174064955149290862569321978468622482
  83972241375657056057490261407972968652414535100474
  82166370484403199890008895243450658541227588666881
  16427171479924442928230863465674813919123162824586
  17866458359124566529476545682848912883142607690042
  24219022671055626321111109370544217506941658960408
  07198403850962455444362981230987879927244284909188
  84580156166097919133875499200524063689912560717606
  05886116467109405077541002256983155200055935729725
  71636269561882670428252483600823257530420752963450`

  four_product_at :: proc (at : int, n : int, bignumstr : string) -> (prod : int) {
    str, was := strings.replace(bignumstr, "\n", "", -1)
    lat := at

    prod = 1
    for i:=0; i<n; i+=1 {
      n1, _ := strconv.parse_int(str[lat:lat+1])
      lat += 1
      prod *= n1
    }
    if was do delete(str)
    return
  }

  lmax := 0
  tmp := 0

  for i:=1; i<=1000-13; i+=1 {
    tmp = four_product_at(i, 13, bignumstr)
    if tmp > lmax do lmax = tmp
  }

  fmt.printf("result: %d\n", lmax)
#+end_src

#+RESULTS:
: result: 5377010688

* Prob 009 - Special Pythagorean Triplet
#+begin_src odin
  is_pythagorean_triplet :: proc(a,b,c : int) -> bool {
    if a*a + b*b == c*c do return true
    return false
  }

  a,b,c : int
  for a=0; a<1000; a+=1 {
    for b=0; b<1000; b+=1 {
      c = 1000 - a - b

      if c > 0 {
        if is_pythagorean_triplet(a,b,c) {
          //fmt.printf("a: %d b: %d c: %d\n", a, b, c)
          if a!=0 && b!=0 && c!=0 && a<b {
            fmt.println(a*b*c)
            break
          }
        }
      }
    }
  }
#+end_src

#+RESULTS:
: 31875000

* Prob 010 - Summation of Primes
#+begin_src odin
  is_prime :: proc (p : int) -> (is_prime : bool) {
    // prime check
    is_prime = true
    if (p % 2 == 0) || (p % 3 == 0) { // start higher than 5!!
      is_prime = false
    } else {
      for i:=5; i * i <= p; {
        if (p % i == 0) || (p % (i+2) == 0) {
          is_prime = false
        }
        i += 6
      }
    }
    return
  }

  sum := 17
  for p:=10; p < 2_000_000; p+=1 {
    if is_prime(p) do sum += p
  }

  fmt.printf("sum: %d\n", sum)
#+end_src

#+RESULTS:
: sum: 142913828922

* Prob 011 - Largest Product in a Grid
#+begin_src odin
  grid : [][]int = {
    { 08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08 },
    { 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00 },
    { 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65 },
    { 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91 },
    { 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80 },
    { 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50 },
    { 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70 },
    { 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21 },
    { 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72 },
    { 21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95 },
    { 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92 },
    { 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57 },
    { 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58 },
    { 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40 },
    { 04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66 },
    { 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69 },
    { 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36 },
    { 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16 },
    { 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54 },
    { 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48 },
  }

  largest_product_in_grid :: proc(n : int, m : int, num_of_nums : int, grid : [][]int) -> int {
    prod := 0
    num := 0
    for i:=0; i<n; i+=1 {
      for j:=0; j<m; j+=1 {
        // for every cell, check all directions
        num = 1
        if (j+num_of_nums-1) < m {			    // right
          for k:=0; k<num_of_nums; k+=1 {
            num *= grid[i][j+k]
          }
        }
        if num > prod do prod = num

        num = 1
        if (j+num_of_nums-1) < m && (i+num_of_nums-1) < n { // right and down
          for k:=0; k<num_of_nums; k+=1 {
            num *= grid[i+k][j+k]
          }
        }
        if num > prod do prod = num

        num = 1
        if (i+num_of_nums-1) < n {			    // down
          for k:=0; k<num_of_nums; k+=1 {
            num *= grid[i+k][j]
          }
        }
        if num > prod do prod = num

        num = 1
        if (j+num_of_nums-1) < m && (i-num_of_nums) >= -1 { // right and up
          for k:=0; k<num_of_nums; k+=1 {
            num *= grid[i-k][j+k]
          }
        }
        if num > prod do prod = num

      }
    }

    return prod
  }

  tmp := largest_product_in_grid(20, 20, 4, grid)
  fmt.printf("sum: %d\n", tmp)
#+end_src

#+RESULTS:
: sum: 70600674

* Prob 012 - Highly Divisible Triangular Number
#+begin_src odin :var primes=primes :includes core:os core:io core:encoding/csv core:strconv core:strings
  file,ferr := os.open(primes)
  if ferr != 0 {
    fmt.println("error")
    return
  }
  defer os.close(file)

  readr,_ := io.to_reader(os.stream_from_handle(file))
  csvreadr : csv.Reader
  csv.reader_init(&csvreadr, readr)
  strs, err := csv.read(&csvreadr)

  primelist := make(map[int]int)
  defer delete(primelist)

  for i:=0; i<len(strs); i+=1 {
    ok : bool
    primelist[i],ok = strconv.parse_int(strings.trim(strs[i], " "))
    if !ok {
      fmt.printf("error")
    }
  }

  triangle_number :: proc(n : int) -> (res : int) {
    // n plus all natural numbers less than n
    res = 0
    for i:=n; i>0; i-=1 {
      res += i
    }
    return
  }

  amount_of_prime_factors :: proc(n : int, primelist : map[int]int) -> map[int]int {
    // finds the amount of each prime factor (see above), puts into a map (prime_number_index->amount)
    // start div by 2, then 3...
    list := make(map[int]int)
    mn := n
    pidx := 0
    for pidx=0; pidx < len(primelist); {
      for ; mn % primelist[pidx] == 0; {
        mn = mn / primelist[pidx]
        if _,ok := list[pidx]; ok {
          list[pidx] += 1
        } else {
          list[pidx] = 1
        }
      }
      pidx += 1
    }
    return list
  }

  num_of_divisors :: proc(n : int, primelist : map[int]int) -> int {
    // find prime factors
    // then number of times each prime factor is used, add 1 to each and call it a_subx
    // then multiply all a_subx together to get the # of divisors
    list := amount_of_prime_factors(n, primelist)
    prod := 1
    for k,v in list {
      prod *= (v+1)
    }
    return prod
  }

  for i:=1; i < 1<<32; i+=1 {
    tmp := triangle_number(i)
    tmp2 := num_of_divisors(tmp, primelist)
    if tmp2 > 500 {
      fmt.printf("tri: %d\n", tmp)
      break
    }
  }
#+end_src

#+RESULTS:
: tri: 76576500

* Prob 013 - Large Sum
#+begin_src odin :includes core:strings core:strconv
  numbers :: `37107287533902102798797998220837590246510135740250
  46376937677490009712648124896970078050417018260538
  74324986199524741059474233309513058123726617309629
  91942213363574161572522430563301811072406154908250
  23067588207539346171171980310421047513778063246676
  89261670696623633820136378418383684178734361726757
  28112879812849979408065481931592621691275889832738
  44274228917432520321923589422876796487670272189318
  47451445736001306439091167216856844588711603153276
  70386486105843025439939619828917593665686757934951
  62176457141856560629502157223196586755079324193331
  64906352462741904929101432445813822663347944758178
  92575867718337217661963751590579239728245598838407
  58203565325359399008402633568948830189458628227828
  80181199384826282014278194139940567587151170094390
  35398664372827112653829987240784473053190104293586
  86515506006295864861532075273371959191420517255829
  71693888707715466499115593487603532921714970056938
  54370070576826684624621495650076471787294438377604
  53282654108756828443191190634694037855217779295145
  36123272525000296071075082563815656710885258350721
  45876576172410976447339110607218265236877223636045
  17423706905851860660448207621209813287860733969412
  81142660418086830619328460811191061556940512689692
  51934325451728388641918047049293215058642563049483
  62467221648435076201727918039944693004732956340691
  15732444386908125794514089057706229429197107928209
  55037687525678773091862540744969844508330393682126
  18336384825330154686196124348767681297534375946515
  80386287592878490201521685554828717201219257766954
  78182833757993103614740356856449095527097864797581
  16726320100436897842553539920931837441497806860984
  48403098129077791799088218795327364475675590848030
  87086987551392711854517078544161852424320693150332
  59959406895756536782107074926966537676326235447210
  69793950679652694742597709739166693763042633987085
  41052684708299085211399427365734116182760315001271
  65378607361501080857009149939512557028198746004375
  35829035317434717326932123578154982629742552737307
  94953759765105305946966067683156574377167401875275
  88902802571733229619176668713819931811048770190271
  25267680276078003013678680992525463401061632866526
  36270218540497705585629946580636237993140746255962
  24074486908231174977792365466257246923322810917141
  91430288197103288597806669760892938638285025333403
  34413065578016127815921815005561868836468420090470
  23053081172816430487623791969842487255036638784583
  11487696932154902810424020138335124462181441773470
  63783299490636259666498587618221225225512486764533
  67720186971698544312419572409913959008952310058822
  95548255300263520781532296796249481641953868218774
  76085327132285723110424803456124867697064507995236
  37774242535411291684276865538926205024910326572967
  23701913275725675285653248258265463092207058596522
  29798860272258331913126375147341994889534765745501
  18495701454879288984856827726077713721403798879715
  38298203783031473527721580348144513491373226651381
  34829543829199918180278916522431027392251122869539
  40957953066405232632538044100059654939159879593635
  29746152185502371307642255121183693803580388584903
  41698116222072977186158236678424689157993532961922
  62467957194401269043877107275048102390895523597457
  23189706772547915061505504953922979530901129967519
  86188088225875314529584099251203829009407770775672
  11306739708304724483816533873502340845647058077308
  82959174767140363198008187129011875491310547126581
  97623331044818386269515456334926366572897563400500
  42846280183517070527831839425882145521227251250327
  55121603546981200581762165212827652751691296897789
  32238195734329339946437501907836945765883352399886
  75506164965184775180738168837861091527357929701337
  62177842752192623401942399639168044983993173312731
  32924185707147349566916674687634660915035914677504
  99518671430235219628894890102423325116913619626622
  73267460800591547471830798392868535206946944540724
  76841822524674417161514036427982273348055556214818
  97142617910342598647204516893989422179826088076852
  87783646182799346313767754307809363333018982642090
  10848802521674670883215120185883543223812876952786
  71329612474782464538636993009049310363619763878039
  62184073572399794223406235393808339651327408011116
  66627891981488087797941876876144230030984490851411
  60661826293682836764744779239180335110989069790714
  85786944089552990653640447425576083659976645795096
  66024396409905389607120198219976047599490197230297
  64913982680032973156037120041377903785566085089252
  16730939319872750275468906903707539413042652315011
  94809377245048795150954100921645863754710598436791
  78639167021187492431995700641917969777599028300699
  15368713711936614952811305876380278410754449733078
  40789923115535562561142322423255033685442488917353
  44889911501440648020369068063960672322193204149535
  41503128880339536053299340368006977710650566631954
  81234880673210146739058568557934581403627822703280
  82616570773948327592232845941706525094512325230608
  22918802058777319719839450180888072429661980811197
  77158542502016545090413245809786882778948721859617
  72107838435069186155435662884062257473692284509516
  20849603980134001723930671666823555245252804609722
  53503534226472524250874054075591789781264330331690`

  strs := strings.split(numbers, "\n")
  sum : f64 = 0
  for i:=0; i<len(strs); i+=1 {
    tmp, ok := strconv.parse_f64(fmt.tprintf("%s.%s", strs[i][0:10], strs[i][10:]))
    if ok {
      sum += tmp
    }
  }
  fmt.printf("sum %f\n", sum)
#+end_src

#+RESULTS:
: sum 553737623039.088

* Prob 014 - Longest Collatz Sequence
note: this one takes awhile... TODO speed it up?
#+begin_src odin
  one_step :: proc (n : i64) -> i64 {
    if n % 2 == 0 {
      return n / 2
    } else {
      return 3*n + 1
    }
  }

  tmp : i64 =  0
  cnt :=  0
  max_chain_cnt :=  0
  kk : i64 = 0
  for k: i64 =1_000_000; k >= 2; k-=1 {
    tmp = k
    cnt = 0
    for ; tmp >= 1;  {
      tmp = one_step(tmp); // one link in the chain
      cnt += 1
      if tmp == 1 do break
    }
    if cnt > max_chain_cnt  {
      max_chain_cnt = cnt
      kk = k
    }
  }
  fmt.printf("k: %d\n", kk)
#+end_src

#+RESULTS:
: k: 837799

* Prob 015 - Lattice Paths
Starting in the top left corner of a 2x2 grid, and only being able to move to
the right and down, there are exactly 6 routes to the bottom right corner.
What about a grid 20x20?
#+begin_src odin
  //      1
  //     1 1
  //    1 2 1
  //   1 3 3 1
  //  1 4 6 4 1
  // 1 5 a a 5 1
  //1 6 f . f 6 1
  make_pascals :: proc(pasc : [dynamic]int) -> (ret : [dynamic]int) {
    // given a line of pascals triangle calc the next line down
    ret = {1}
    for i:=0; i<len(pasc); i+=1 {
      if i==len(pasc)-1 {
        append(&ret, 1)
      } else {
        append(&ret, pasc[i]+pasc[i+1])
      }
    }
    return ret
  }

  calc_pascal :: proc(n : int) -> int {
    // return number of paths possible, with only going right or down
    // along a grid edge of N x N cells
    tmp : [dynamic]int = {}
    for i:=0; i<2*n+1; i+=1 {
      tmp = make_pascals(tmp)
      for i:=0; i<len(tmp); i+=1 {
        //fmt.printf("%d ", tmp[i])
      }
      //fmt.println()
    }
    // now get center number (only every other row of pascal have a "center" number)
    l := len(tmp)
    if l%2 == 1 {
      return tmp[l/2]
    }
    return -1
  }

  // NOTES - examples
  // going only right or down

  // 2x2: 00  , 01  , 01  , 11  , 11  , 11
  //      00    00    01    00    01    11

  // 3x3: 000   001   001   001   011   011   011   011   011   011   111   111   111   111   111   111   111   111   111   111
  //      000   000   001   001   000   001   001   011   011   011   000   001   001   011   011   011   111   111   111   111
  //      000   000   000   001   000   000   001   000   001   011   000   000   001   000   001   011   000   001   011   111

  // 2, 6, 20

  fmt.println(calc_pascal(20))
  // this was super fun!
#+end_src

#+RESULTS:
: 137846528820

* Prob 016 - Power Digit Sum
#+begin_src odin :includes core:strconv
  // basic idea is:
  // 		// x div by 10 is?  x * 0.1... OR (x * 0.8) / 8
  divu10 :: proc(n : u64) -> (q : u64, r : u64) {
    q = (n >> 1) + (n >> 2);  // q=n/2+n/4 = 3n/4
    q = q + (q >> 4);         // q=3n/4+(3n/4)/16 = 3n/4+3n/64 = 51n/64
    q = q + (q >> 8);         // q=51n/64+(51n/64)/256 = 51n/64 + 51n/16384 = 13107n/16384 q = q + (q >> 16); // q= 13107n/16384+(13107n/16384)/65536=13107n/16348+13107n/1073741824=858993458n/1073741824
    // note: q is now roughly 0.8n
    q = q >> 3;               // q=n/8 = (about 0.1n or n/10)
    r = n - (((q << 2) + q) << 1); // rounding: r= n-2*(n/10*4+n/10)=n-2*5n/10=n-10n/10

    return
  } // above is fast, but not accurate

  add_big_ten :: proc(a : ^[$N]u8, b : ^[$M]u8) {
    carry			: u8 = 0
    carry_tmp : u8 = 0

    for i:=N-1; i>=0; i-=1 {
      if (a[i] >= 10 - b[i] - carry) { // `a + b` overflows
        carry_tmp = 1
        a[i] += b[i] + carry - 10
      } else {
        carry_tmp = 0
        a[i] += b[i] + carry
      }
      carry = carry_tmp
    }
  }

  tmp : u64 = 1<<63; // start with a big number
  sum := 0
  str := fmt.tprintf("%d", tmp)
  numa : [400]u8 = {}; // 400 should be enough digits
  numb : [400]u8 = {}
  for i:=0; i<400; i+=1 {
    numa[i] = 0
    numb[i] = 0
  }
  for j:=0; j<len(str); j+=1 {
    numa[400-len(str) + j] = cast(u8)strconv._digit_value(cast(rune)str[j])
    numb[400-len(str) + j] = numa[400-len(str) + j]
  }

  for x in 64..1000 {
    add_big_ten(&numa, &numb); // double the number this many times
    for k:=0; k<400; k+=1 {
      numb[k] = numa[k]
    }
  }
  //fmt.println(numa)
  for l:=0; l<400; l+=1 {
    sum += cast(int)numa[l]; // sum the digits
  }
  fmt.println(sum)
#+end_src

#+RESULTS:
: 1366

* Prob 017 - Number Letter Count
#+begin_src odin
  _num_as_w1 :: proc(n : int) -> (str : string) {
    switch n {
    case 1:
      str = "one"
    case 2:
      str = "two"
    case 3:
      str = "three"
    case 4:
      str = "four"
    case 5:
      str = "five"
    case 6:
      str = "six"
    case 7:
      str = "seven"
    case 8:
      str = "eight"
    case 9:
      str = "nine"
    }
    return
  }
  _num_as_w :: proc(n : int) -> (str : string) {
    switch n {
    case 1:
      str = "one"
    case 2:
      str = "two"
    case 3:
      str = "three"
    case 4:
      str = "four"
    case 5:
      str = "five"
    case 6:
      str = "six"
    case 7:
      str = "seven"
    case 8:
      str = "eight"
    case 9:
      str = "nine"
    case 10:
      str = "ten"
    case 11:
      str = "eleven"
    case 12:
      str = "twelve"
    case 13:
      str = "thirteen"
    case 14:
      str = "fourteen"
    case 15:
      str = "fifteen"
    case 16:
      str = "sixteen"
    case 17:
      str = "seventeen"
    case 18:
      str = "eighteen"
    case 19:
      str = "nineteen"
    case 20..29:
      str = "twenty"
    case 30..39:
      str = "thirty"
    case 40..49:
      str = "forty"
    case 50..59:
      str = "fifty"
    case 60..69:
      str = "sixty"
    case 70..79:
      str = "seventy"
    case 80..89:
      str = "eighty"
    case 90..99:
      str = "ninety"
    }
    if n > 20 {
      if (n % 10 != 0) {
        str = fmt.tprintf("%s%s", str, _num_as_w1(n%10))
      }
    }
    return
  }

  number_as_words :: proc(n : int, str : ^string) -> int {
    m : int = n
    if m == 1000 {
      str^ = "onethousand"
    } else {
      if m >= 100 {
        str^ = fmt.tprintf("%shundred", _num_as_w(m/100))
        m = m - (m/100 * 100)
        if m > 0 {
          str^ = fmt.tprintf("%sand", str^)
        }
        str^ = fmt.tprintf("%s%s", str^, _num_as_w(m))
      } else {
        str^ = fmt.tprintf("%s", _num_as_w(m))
      }
    }
    return len(str^)
  }

  i := 1
  s := ""
  tmp := 0

  for ; i<=1000; i+=1 {
    tmp += number_as_words(i, &s)
  }
  fmt.println(tmp)
#+end_src

#+RESULTS:
: 21124

* Prob 018 - Maximum Path Sum I
#+begin_src odin

  triangle : []int = {
    75,
    95, 64,
    17, 47, 82,
    18, 35, 87, 10,
    20, 04, 82, 47, 65,
    19, 01, 23, 75, 03, 34,
    88, 02, 77, 73, 07, 63, 67,
    99, 65, 04, 28, 06, 16, 70, 92,
    41, 41, 26, 56, 83, 40, 80, 70, 33,
    41, 48, 72, 33, 47, 32, 37, 16, 94, 29,
    53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14,
    70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57,
    91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48,
    63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31,
    04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23, }

  connects_to :: proc(idx : int, triangle : []int) -> [2]int {
    // every triangle node connects to the two below, find longest path down
    ridx := 0
    prev_ridx := 0
    to_n1 := 0
    to_n2 := 1
    line := 1
    for ; ridx <= idx; ridx+=1 {
      if (ridx == prev_ridx+line) {
        line += 1
        prev_ridx = ridx
      }

      if ridx == idx {
        to_n1 += line
        to_n2 += line
      } else {
        to_n1 += 1
        to_n2 += 1
      }
    }
    if (to_n1 > len(triangle)-1 || to_n2 > len(triangle)-1) {
      to_n1 = -1
      to_n2 = -1
    }

    return {to_n1, to_n2}
  }

  Nodes :: struct {
    n : int,
    largest_sum  : int,
    connect_prev : int,
  }

  tree := make([]Nodes, len(triangle))

  for i:=0; i<len(triangle)-1; i+=1 {
    tree[i] = ({ triangle[i], triangle[i], -1 })
  }
  for i:=0; i<len(triangle)-1; i+=1 {
    tmp := connects_to(i, triangle)
    if tmp[0] > 0 && tmp[1] > 0 {
      if tree[tmp[0]].n + tree[i].largest_sum > tree[tmp[0]].largest_sum {
        tree[tmp[0]].largest_sum = tree[tmp[0]].n + tree[i].largest_sum
        tree[tmp[0]].connect_prev = i
      }
      if tree[tmp[1]].n + tree[i].largest_sum > tree[tmp[1]].largest_sum {
        tree[tmp[1]].largest_sum = tree[tmp[1]].n + tree[i].largest_sum
        tree[tmp[1]].connect_prev = i
      }
    }
  }

  // for all bottom nodes at the end -- note: 15 is height/width of triangle
  largest := 0
  for i:=0; i<15; i+=1 {
    if tree[119-i].largest_sum > largest {
      largest = tree[119-i].largest_sum
    }
  }
  fmt.println(largest)
#+end_src

#+RESULTS:
: 1074

* Prob 019 - Counting Sundays
#+begin_src odin
  /*
  1 Jan 1900 was a Monday.
  Thirty days has September,
  April, June and November.
  All the rest have thirty-one,
  Saving February alone,
  Which has twenty-eight, rain or shine.
  And on leap years, twenty-nine.
  A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.

  How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
  ,*/

  is_leap_year :: proc(y : int) -> bool {
    if y % 400 == 0 {
      return true
    } else if y % 100 == 0 {
      return false
    } else if y % 4 == 0 {
      return true
    }
    return false
  }

  num_of_days :: proc() -> int {
    cnt := 0
    tmp := 0
    // # of days from Mon 1 Jan 1900 to 31 Dec 2000
    day  := 1
    mon  := 0
    year := 1901

    for ; true ; {
      days_in_month := 31
      if mon == 1 { // feb
        days_in_month = 28
        if is_leap_year(year) {
          days_in_month = 29
        }
      } else if mon == 3 || mon == 5 || mon == 8 || mon == 10 {
        days_in_month = 30
      }

      cnt += 1
      day += 1

      if cnt == 7 {
        cnt = 0
      }

      if day > days_in_month {
        day = 1
        mon += 1
      }
      if mon >= 12 {
        mon = 0
        year += 1
      }
      if cnt == 6 && day == 1 {
        //fmt.printf("day %d, mon %d, year %d\n", day, mon, year)
        tmp += 1
      }

      if year == 2000 && mon == 11 && day == 31 {
        return tmp
      }
    }
    return 0
  }

  // for some STRANGE reason the last Sunday is not included? so subtract 1
  fmt.printf("days: %d\n", num_of_days() - 1)

#+end_src

#+RESULTS:
: days: 171

* Prob 020 - Factorial Digit Sum
sum all the digits in a string
#+name: sum_string
#+begin_src odin :var data="" :includes core:strconv
sum := 0;
for d in data {
  sum += strconv._digit_value(d);
}
fmt.println(sum);
#+end_src

'calc' package in emacs has support for big integers with 'gmp', so use that
to make string for 100 factorial
#+begin_src emacs-lisp :post sum_string(data=*this*) :cache yes
(calc-eval "100!")
#+end_src

#+RESULTS[1554e3690e5d36455c0a23e2eb6b63c1a76dc90f]:
: 648

* Prob 021 - Amicable Numbers

Let d(n) be defined as the sum of proper divisors of n (numbers less than n
which divide evenly into n).
If d(a) = b and d(b) = a, where a ? b, then a and b are an amicable pair and
each of a and b are called amicable numbers.

For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55
and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71
and 142; so d(284) = 220.

Evaluate the sum of all the amicable numbers under 10000.

#+begin_src odin
sum := 0
sum_of_proper_divisors :: proc(n : int) -> (sum : int) {
  sum = 1
  last_ni := 0
  for i:=2; i<(n/2); i+=1 {
    if n % i == 0 {
      if last_ni == i {
	break
      }
      last_ni = (n/i)
      sum += i + last_ni
    }
  }
  return
}

for i:=6; i<10_000; i+=1 {
  a := sum_of_proper_divisors(i)
  b := sum_of_proper_divisors(a)
  if b == i && a != b{
    fmt.println(i, a, b)
    sum += i
  }
}
fmt.println(sum)
#+end_src

#+RESULTS:
|   220 |  284 |  220 |
|   284 |  220 |  284 |
|  1184 | 1210 | 1184 |
|  1210 | 1184 | 1210 |
|  2620 | 2924 | 2620 |
|  2924 | 2620 | 2924 |
|  5020 | 5564 | 5020 |
|  5564 | 5020 | 5564 |
|  6232 | 6368 | 6232 |
|  6368 | 6232 | 6368 |
| 31626 |      |      |

* Prob 022 - Names Scores
#+begin_src odin :var data=names.org:names-data-sorted
idx := 1
sum := 0

name_worth :: proc(s : string) -> int {
  worth := 0
  for i in s {
    worth += cast(int)i - cast(int)'A' + 1
  }
  return worth
}

//fmt.println(name_worth("COLIN"))
for i in data {
  sum += name_worth(i[0]) * idx
  idx += 1
}
fmt.println(sum)
#+end_src

* Prob 023 - Non-abundant Sums
A perfect number is a number for which the sum of its proper divisors is
exactly equal to the number. For example, the sum of the proper divisors of 28
would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.

A number n is called deficient if the sum of its proper divisors is less than
n and it is called abundant if this sum exceeds n.

As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest
number that can be written as the sum of two abundant numbers is 24. By
mathematical analysis, it can be shown that all integers greater than 28123 can
be written as the sum of two abundant numbers. However, this upper limit cannot
be reduced any further by analysis even though it is known that the greatest
number that cannot be expressed as the sum of two abundant numbers is less than
this limit.

Find the sum of all the positive integers which cannot be written as the sum of
two abundant numbers.

#+name: asValue
#+begin_src emacs-lisp :var name="last" :var val=0 :results value
  (concat (format "#+NAME: %s\n" name) val)
#+end_src

#+begin_src odin :var primes=primes :includes core:encoding/csv core:os core:io core:strconv core:strings core:math
file,ferr := os.open(primes)
if ferr != 0 {
  fmt.println("error")
  return
}
defer os.close(file)

readr,_ := io.to_reader(os.stream_from_handle(file))
csvreadr : csv.Reader
csv.reader_init(&csvreadr, readr)
strs, err := csv.read(&csvreadr)

primelist := make(map[int]int)
defer delete(primelist)

for i:=0; i<len(strs); i+=1 {
  ok : bool
  primelist[i],ok = strconv.parse_int(strings.trim(strs[i], " "))
  if !ok {
    fmt.printf("error")
  }
}

sum_of_factors_prime :: proc(n : int, primelist : map[int]int) -> int {
  nn := n
  sum := 1
  p := primelist[0]
  j, i : int = 0, 0

  for ; p*p <= nn && nn > 1 && i < len(primelist); {
    p = primelist[i]
    i+=1
    if (nn % p == 0) {
      j = p * p
      nn = nn / p
      for ; nn % p == 0; {
        j = j * p
        nn = nn / p
      }
      sum = sum * (j-1) / (p-1)
    }
  }
  if (nn > 1) {
    sum = sum * (nn + 1)
  }

  return sum - n
}

sum_of_factors :: proc(n : int) -> int {
  sqrt_of_number := cast(int)math.sqrt(cast(f32)n)
  sum := 1

  // If the number is a perfect square
  // Count the squareroot once in the sum of factors
  if (n == sqrt_of_number * sqrt_of_number) {
    sum += sqrt_of_number
    sqrt_of_number-=1
  }

  for i := 2; i <= sqrt_of_number; i+=1 {
    if (n % i == 0) {
      sum = sum + i + (n / i)
    }
  }
  return sum
}

// now file all abundant numbers
limit := 28123
abundant := make(map[int]int)
defer delete(abundant)

j:=0
for i in 12..<limit {
  if sum_of_factors_prime(i, primelist) > i {
    //if sum_of_factors(i) > i {
    abundant[j] = i
    j+=1
  }
}

can_be_written_as_abundant : [28124]bool
for i in 0..<j {
  for k in i..<j {
    tmp := abundant[i] + abundant[k]
    if (tmp <= limit) {
      can_be_written_as_abundant[tmp] = true
    } else {
      break
    }
  }
}
sum := 0
for i in 1..limit {
  if can_be_written_as_abundant[i] == false {
    sum+=i
  }
}

fmt.println(sum)
#+end_src

#+RESULTS:
: 4179871

* Prob 024 - Lexicographic Permutations
#+begin_src odin
// 9! is the number of combinations that 9 digits can be arranged
// 8! is the number of combinations that 8 digits can be arranged

factorial :: proc(n : int) -> int {
  if n < 0 {
    return 0
  }
  p : int = 1
  for i:=1; i < n; i+=1 {
    p *= i
  }
  return p
}

perm  : []int = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
n := len(perm)+1
pn := len(perm)
perm_num := ""
remain := 1_000_000 - 1

for i:=1; i < n; i+=1 {
  fac := factorial(n-i)
  j := remain / fac
  remain = remain % fac

  perm_num = fmt.tprintf("%s%d", perm_num, perm[j])
  copy(perm[j:], perm[(j+1):])
  pn -= 1

  if (remain == 0) {
    break
  }
}

for i:=0; i < pn; i+=1 {
  perm_num = fmt.tprintf("%s%d", perm_num, perm[i])
}
fmt.println(perm_num)
#+end_src

#+RESULTS:
: 2783915460

* Prob 025 - 1000-digit Fibonacci Number
#+begin_src odin

// add two big (base 10) numbers, put result in a
add_big_ten :: proc(a : ^[$N]u8, b : ^[$M]u8) {
  carry			: u8 = 0
  carry_tmp : u8 = 0

  for i:=N-1; i>=0; i-=1 {
    if (a[i] >= 10 - b[i] - carry) { // `a + b` overflows
      carry_tmp = 1
      a[i] += b[i] + carry - 10
    } else {
      carry_tmp = 0
      a[i] += b[i] + carry
    }
    carry = carry_tmp
  }
}
numa : [1000]u8 = {}
numb : [1000]u8 = {}
for i:=0; i<1000; i+=1 {
  numa[i] = 0
  numb[i] = 0
}
numa[1000-1] = 1
numb[1000-1] = 1
n := 2

for ; numa[0] == 0 && numb[0] == 0; {
  add_big_ten(&numa, &numb)
  n+=1
  if !(numa[0] > 0) {
    add_big_ten(&numb, &numa)
    n+=1
  }
}

first_none_zero := false
for l:=0; l<1000; l+=1 {
  if numa[l] != 0 {
    first_none_zero = true
  }
  if first_none_zero {
    //fmt.printf("%d", numa[l]); // if you want to print the number
  }
}
fmt.printf("%d", n)
#+end_src

#+RESULTS:
: 4782

* Prob 026 - Reciprocal Cycles
#+begin_src odin :var primes=primes :includes core:os core:io core:encoding/csv core:strconv core:strings
file,ferr := os.open(primes)
if ferr != 0 {
  fmt.println("error")
  return
}
defer os.close(file)

readr,_ := io.to_reader(os.stream_from_handle(file))
csvreadr : csv.Reader
csv.reader_init(&csvreadr, readr)
strs, err := csv.read(&csvreadr)

primelist := make(map[int]int)
defer delete(primelist)

d: f32 =0
i:=0
for ; i<len(strs); i+=1 {
  ok : bool
  primelist[i],ok = strconv.parse_int(strings.trim(strs[i], " "))
  if !ok {
    fmt.printf("error")
  }
  if primelist[i] > 1000 {
    d = cast(f32)primelist[i-3]
    break
  }
}
// now we are looking for "full period primes"(they have period/length of p-1) starting at i-1

// note: 31 is prime, but has period/order of 15   (since 1000000000000000 % 31 == 1)
// below is an example showing this
find_period :: proc(p : int) -> int {
  order:=0
  mod:=0
  num:=10

  for ; mod != 1; {
    mod = num % p
    num = mod * 10
    order+=1
  }
  return order
}
//fmt.println(find_period(31))

// for a list see...
//(PARI) a(n)=if(n<4, n==2, znorder(Mod(10, prime(n))))           a(n) is decimal expansion length
// https://oeis.org/A002371/b002371.txt  <-- contains a list of primes and their decimal expansion length

j:=1
how_far_back := 20; // not sure how far back you might have to go, but this seems like enough
for ; j<how_far_back; j+=1 {
  if find_period(primelist[i-j]) == (primelist[i-j]-1) {
    break
  }
}
fmt.println(primelist[i-j])
#+end_src

#+RESULTS:
: 983

* Prob 027 - Quadratic Primes
#+begin_src odin
// a and b go from -1000 to 1000... what quadratic n^2 + an + b produces the most primes for n=0..X (maximize X)
is_prime :: proc (n : int) -> bool {
  if n <= 5 {
    return n==2 || n==3 || n==5
  }
  p := 5
  for prime_idx:=3; p<=n; {
    // prime check
    is_prime := true
    if (p % 2 == 0) || (p % 3 == 0) {
      is_prime = false
    } else {
      for i:=5; i * i <= p; {
        if (p % i == 0) || (p % (i+2) == 0) {
          is_prime = false
        }
        i += 6
      }
    }

    // now is_prime tells if p is prime
    if is_prime {
      if p==n {
        return true
      }
      prime_idx += 1
      p += 2; // check next possible prime
    } else {
      p += 2
    }
  }
  return false
}

primes_produced :: proc(a : int, b : int) -> int {
  n:=0
  p := b
  for ; is_prime(p); {
    n+=1
    p = (n*n) + a*n + b
  }
  return n
}

a := -1000
b := -1000
max_primes := 0
num := 0
for ; a <= 1000; a+=1 {
  for b=-1000; b <= 1000; b+=1 {
    tmp := primes_produced(a, b)
    if tmp > max_primes {
      max_primes = tmp
      num = a * b
      fmt.println(max_primes, a, b)
    }
  }
}
fmt.println(max_primes, num)
#+end_src

#+RESULTS:
|  1 |  -1000 |   2 |
|  2 |   -996 | 997 |
|  3 |   -499 | 997 |
|  4 |   -325 | 977 |
|  5 |   -245 | 977 |
|  6 |   -197 | 983 |
|  7 |   -163 | 983 |
|  8 |   -131 | 941 |
|  9 |   -121 | 947 |
| 11 |   -105 | 967 |
| 71 |    -61 | 971 |
| 71 | -59231 |     |

* Prob 028 - Number Spiral Diagonals
#+begin_src odin
M :: 1001
x := M/2
y := M/2
n := 1
going_dir := 0
spiral_cnt := 0
sum := 0

// sum up corners or fill spiral box
for ; going_dir < 4; {
  //box[x][y] = n
  if x == y || (M-1-x) == y {
    sum += n
  }
  n+=1

  if going_dir == 0 { // right
    x+=1
    if x > M-1 {
      going_dir = 4; // end
    }
  } else if going_dir == 1 { // down
    y+=1
  } else if going_dir == 2 { // left
    x-=1
  } else if going_dir == 3 { // up
    y-=1
  }

  if going_dir == 0 && x>M/2+spiral_cnt {
    going_dir = 1
    spiral_cnt+=1
  }
  else if going_dir == 1 && y==M/2+spiral_cnt {
    going_dir = 2
  }
  else if going_dir == 2 && x==M/2-spiral_cnt {
    going_dir = 3
  }
  else if going_dir == 3 && y==M/2-spiral_cnt {
    going_dir = 0
  }
}
fmt.println(sum)
#+end_src

#+RESULTS:
: 669171001

* Prob 029 - Distinct Powers
#+begin_src odin :includes core:math
set : map[f64]bool
for a:=2; a <= 100; a+=1 {
  for b:=2; b <= 100; b+=1 {
    set[math.pow_f64(cast(f64)a, cast(f64)b)] = true
  }
}
fmt.println("set size:", len(set))
#+end_src

#+RESULTS:
: set size: 9183

* Prob 030 - Digit Fifth Powers
Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:

1634 = 14 + 64 + 34 + 44
8208 = 84 + 24 + 04 + 84
9474 = 94 + 44 + 74 + 44
As 1 = 14 is not a sum it is not included.

The sum of these numbers is 1634 + 8208 + 9474 = 19316.

Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.

#+begin_src odin :includes core:math core:strconv
total_sum := 0
digits_cnt := 6
power : f64 = 5
for i in 2..<1000000 {
  frmt := fmt.tprintf("%%0%dd", digits_cnt)
  str := fmt.tprintf(frmt, i)

  sum := 0
  for j in 0..<digits_cnt {
    d := strconv._digit_value(cast(rune)str[j])
    pow := math.pow_f64(cast(f64)d, power)
    sum += cast(int)pow
  }
  if sum == i {
    fmt.println(str, sum)
    total_sum += sum
  }
}
fmt.println(total_sum)
#+end_src

#+RESULTS:
| 004150 |   4150 |
| 004151 |   4151 |
| 054748 |  54748 |
| 092727 |  92727 |
| 093084 |  93084 |
| 194979 | 194979 |
| 443839 |        |
* Prob 031 - Coin Sum
In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:

1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).
It is possible to make £2 in the following way:

1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
How many different ways can £2 be made using any number of coins?

#+begin_src odin :includes core:strings core:strconv
coins : []int = { 1, 2, 5, 10, 20, 50, 100, 200 }
goal := 200
ways : []int = make([]int, goal+1)
ways[0] = 1

for i in 0..<len(coins) {
  for j in coins[i]..<goal+1 {
    ways[j] += ways[j - coins[i]]
  }
}

fmt.println(ways[goal])
#+end_src

#+RESULTS:
: 73682
* Prob 032 - Pandigital
We shall say that an n-digit number is pandigital if it makes use of all the
digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through
5 pandigital.
The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing
multiplicand, multiplier, and product is 1 through 9 pandigital.

Find the sum of all products whose multiplicand/multiplier/product identity can
be written as a 1 through 9 pandigital.

HINT: Some products can be obtained in more than one way so be sure to only
include it once in your sum.
#+begin_src odin :includes core:strings
// uses bit shifting
is_pandigital :: proc(n: u64) -> bool {
  digits, cnt, tmp : i32 = 0, 0, 0
  nn := n
  for ; nn > 0; {
    tmp = digits
    digits = digits | 1 << cast(u32)((nn % 10) -1)
    if tmp == digits do return false
    cnt += 1
    nn /= 10
  }
  return digits == (1 << cast(u32)cnt) -1
}
concat :: proc(a, b: u64) -> u64 {
  cc : u64 = b
  aa := a
  for ; cc > 0; {
    aa *= 10
    cc /= 10
  }
  return aa + b
}

//fmt.println(is_pandigital(987654321))

products : map[u64]bool
sum : u64 = 0
prod, compiled : u64

for m: u64 =2; m < 100; m+=1 {
  nbeg : u64 = (m > 9) ? 123 : 1234
  nend : u64 = 10_000 / m + 1

  for n: u64 =nbeg; n < nend; n+=1 {
    prod = m * n
    compiled = concat( concat( prod, n ), m )
    if compiled >= 1e8 && compiled < 1e9 && is_pandigital(compiled) {
      products[prod] = true
    }
  }
}
for pk, pv in products {
  sum += pk
}
fmt.println(sum)
#+end_src

#+RESULTS:
: 45228
* Prob 033 - Digit cancelling fractions
The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.
We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.
If the product of these four fractions is given in its lowest common terms, find
the value of the denominator.

#+begin_src odin :includes core:strconv core:math
fraction :: struct {
  n : f64,
  d : f64,
}
the_four := make([]fraction, 4)
defer delete(the_four)

idx := 0
for numer in 1..99 {
  for denom in numer..99 {
    goal : f64 = cast(f64)numer / cast(f64)denom
    s_num := fmt.tprintf("%02d", numer)
    s_den := fmt.tprintf("%02d", denom)
    a, b, c, d := s_num[0], s_num[1], s_den[0], s_den[1]
    A : f64 = cast(f64)strconv._digit_value(cast(rune)a)
    B : f64 = cast(f64)strconv._digit_value(cast(rune)b)
    C : f64 = cast(f64)strconv._digit_value(cast(rune)c)
    D : f64 = cast(f64)strconv._digit_value(cast(rune)d)
    cnt := 0

    if A == 0 || B == 0 do cnt += 1
    if C == 0 || D == 0 do cnt += 1

    found := false
    if cnt < 2 && numer != denom {
      if C != 0 {
        if B==D && A / C == goal do found = true
        if A==D && B / C == goal do found = true
      }
      if D != 0 {
        if B==C && A / D == goal do found = true
        if A==C && B / D == goal do found = true
      }
    }
    if found {
      //fmt.printf("%c%c %c%c\n", a, b, c, d)
      the_four[idx] = fraction{ cast(f64)numer, cast(f64)denom }
      idx += 1
    }
  }
}
n := 1
d := 1
for f in the_four {
  //fmt.println(f.n, f.d)
  n *= cast(int)f.n
  d *= cast(int)f.d
}
// denom in its lowest common term
fmt.println( d / math.gcd(n, d) )

#+end_src

#+RESULTS:
: 100
* Prob 034 - Digit factorials
145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
Find the sum of all numbers which are equal to the sum of the factorial of their digits.
Note: As 1! = 1 and 2! = 2 are not sums they are not included.

#+begin_src odin :includes core:strconv core:math/bits core:math
cnt := bits.U16_MAX
acc := 0
for n in 10..cnt {
  // get all digits
  // get factorials of those digits
  // add them together
  nn := n
  accum := 0
  for nn > 0 {
    num := fmt.tprintf("%d", nn)
    a := num[len(num)-1]
    A := strconv._digit_value(cast(rune)a)
    accum += math.factorial(A)
    nn = nn / 10
  }
  if accum == n {
    fmt.println(n)
    acc += n
  }
}
fmt.println(acc)
#+end_src

#+RESULTS:
|   145 |
| 40585 |
| 40730 |
* Prob 035 - Circular primes
The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.
There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
How many circular primes are there below one million?

#+begin_src odin :includes core:math core:strconv
is_prime :: proc(x : int) -> bool
{
  if x % 2 == 0 {
    return false
  }
  for i:=3; i <= cast(int)math.sqrt_f32(cast(f32)x); i+=2 {
    if x % i == 0 {
      return false
    }
  }
  return true
}
rotate :: proc(x : int) -> int
{
  nn := x
  num := fmt.tprintf("%d", nn)
  n := fmt.tprintf("%s%c", num[1:], num[0])
  ret, ok := strconv.parse_int(n)
  return ret
}

cprimes : [dynamic]int
append(&cprimes, 2)
for i in 3..<1_000_000 {
  found := true
  n := i
  sn := fmt.tprintf("%d", n)
  for i in 0..<len(sn) {
    if sn[i] == '0' {
      found = false
      break
    }
  }
  if found {
    for i in 0..<len(sn) {
      if !is_prime(n) {
        found = false
        break
      }
      n = rotate(n)
    }
  }
  if found {
    append(&cprimes, i)
  }
}
//for i in cprimes {
//  fmt.println(i)
//}
fmt.println(len(cprimes))
#+end_src

#+RESULTS:
: 55
* Prob 036 - Double-base palindromes
The decimal number, 585 = 1001001001_2 (binary), is palindromic in both bases.
Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.
(Please note that the palindromic number, in either base, may not include
leading zeros.)

#+begin_src odin :includes core:strconv core:strings
hex_to_binary : map[rune]string
hex_to_binary['0'] = "0000"
hex_to_binary['1'] = "0001"
hex_to_binary['2'] = "0010"
hex_to_binary['3'] = "0011"
hex_to_binary['4'] = "0100"
hex_to_binary['5'] = "0101"
hex_to_binary['6'] = "0110"
hex_to_binary['7'] = "0111"
hex_to_binary['8'] = "1000"
hex_to_binary['9'] = "1001"
hex_to_binary['a'] = "1010"
hex_to_binary['b'] = "1011"
hex_to_binary['c'] = "1100"
hex_to_binary['d'] = "1101"
hex_to_binary['e'] = "1110"
hex_to_binary['f'] = "1111"

num := 0

for i in 1..<1_000_000 {
  si := fmt.tprintf("%d", i)
  si_hex := fmt.tprintf("%x", i)
  si_binary := ""
  start := 0
  end := len(si) - 1
  good := true
  for ;  start< len(si)/2 && start != end; {
    if si[start] != si[end] do good = false
    start += 1
    end -= 1
  }
  if good {
    for s in si_hex {
      si_binary = strings.concatenate({si_binary, hex_to_binary[s]})
    }
    si_binary = strings.trim_left(si_binary, "0")

    start = 0
    end = len(si_binary) - 1
    for ; start < len(si_binary)/2 && start != end; {
      if si_binary[start] != si_binary[end] do good = false
      start += 1
      end -= 1
    }
  }

  if good {
    num += i
    //fmt.println(i, si_binary)
  }
}
fmt.println(num)
#+end_src

#+RESULTS:
: 872187

* Prob 037 - Truncatable primes
The number 3797 has an interesting property. Being prime itself, it is possible
to continuously remove digits from left to right, and remain prime at each
stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797,
379, 37, and 3. Find the sum of the only eleven primes that are both truncatable
from left to right and right to left. NOTE: 2, 3, 5, and 7 are not considered to
be truncatable primes.

#+begin_src odin :includes core:strconv core:math
is_prime :: proc(x : int) -> bool {
  if x == 1 do return false
  if x == 2 do return true
  if x % 2 == 0 {
    return false
  }
  for i:=3; i <= cast(int)math.sqrt_f32(cast(f32)x); i+=2 {
    if x % i == 0 {
      return false
    }
  }
  return true
}
is_lr_prime :: proc(num : int) -> bool {
  // 3797... 379(7)... 37(9)... 3(7)
  str := fmt.tprintf("%d", num)
  new_num, ok := strconv.parse_int(str[0:len(str)-1])
  if ok {
    if len(str)==2 do return is_prime(new_num)
    if is_prime(new_num) && is_lr_prime(new_num) do return true
  }
  return false
}
is_rl_prime :: proc(num : int) -> bool {
  // 3797... (3)797... (7)97... (9)7
  str := fmt.tprintf("%d", num)
  new_num, ok := strconv.parse_int(str[1:len(str)])
  if ok {
    if len(str)==2 do return is_prime(new_num)
    if is_prime(new_num) && is_rl_prime(new_num) do return true
  }
  return false
}

num := 11
acc := 0
for i:=0; i<11; { // only 11 =)
  if is_prime(num) && is_lr_prime(num) && is_rl_prime(num) {
    i += 1 // both L->R prime and R->L prime
    fmt.println("adding", num)
    acc += num
  }
  num += 2 // no need for even numbers
}
fmt.println(acc)
#+end_src

#+RESULTS:
| adding |     23 |
| adding |     37 |
| adding |     53 |
| adding |     73 |
| adding |    313 |
| adding |    317 |
| adding |    373 |
| adding |    797 |
| adding |   3137 |
| adding |   3797 |
| adding | 739397 |
| 748317 |        |

* Prob 038 - Pandigital multiples
Take the number 192 and multiply it by each of 1, 2, and 3:

192 × 1 = 192 192 × 2 = 384 192 × 3 = 576 By concatenating each product we get
the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated
product of 192 and (1,2,3)

The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and
5, giving the pandigital, 918273645, which is the concatenated product of 9 and
(1,2,3,4,5).

What is the largest 1 to 9 pandigital 9-digit number that can be formed as the
concatenated product of an integer with (1,2, ... , n) where n > 1?
#+begin_src odin :includes core:strconv core:fmt core:strings

AllNine :: distinct bit_set[1..9]

is_pandigital :: proc(num: int) -> bool {
  nine : AllNine
  nine += { 1, 2, 3, 4, 5, 6, 7, 8, 9 }

  str := fmt.tprintf("%d", num)
  if len(str) != 9 do return false // limit to 9 digit numbers

  for c in str {
    nine -= { strconv._digit_value(c) }
  }
  if nine == {} do return true // if empty
  return false
}

concat_prod :: proc(num: int, s: [dynamic]int) -> (int, bool) {
  str := string("")
  for i in s {
    tmp := fmt.tprintf("%d", (num * i))
    str = strings.concatenate( []string{str, tmp} )
  }
  return strconv.parse_int(str, 10)
}

main :: proc() {
  largest := 0
  pan_set : [dynamic]int
  append(&pan_set, 1)
  to_add := []int{2, 3,4,5,6,7,8,9}

  for j in to_add {
    //fmt.println(j)
    append(&pan_set, j)

    for i in 1..<500_000 {
      num, ok := concat_prod(i, pan_set)
      if ok && is_pandigital(num) && num > largest {
        largest = num
      }
    }
  }
  fmt.println(largest) // must be slowest way possible... hehe
}
#+end_src

#+RESULTS:
: 932718654

* Prob 039 - Integer Right Triangles
If p is the perimeter of a right angle triangle with integral length sides,
{a,b,c}, there are exactly three solutions for p = 120.
{20,48,52}, {24,45,51}, {30,40,50}
For which value of p ≤ 1000, is the number of solutions maximised?
#+begin_src odin :includes core:strconv core:math
is_right_tri :: proc(a, b, c: int) -> bool {
  A := math.pow_f32(f32(a), 2)
  B := math.pow_f32(f32(b), 2)
  C := math.pow_f32(f32(c), 2)
  if A + B == C do return true
  return false
}

num_solutions :: proc(p: int) -> int {
  num := 0
  for a in 0..<(p/2) {
    for b in 0..<a {
      c := p - a - b
      if c > 1 {
        if is_right_tri(a, b, c) do num += 1
      }
    }
  }
  return num
}

max := 0
ans := 0
for p in 1..<1000 {
  tmp := num_solutions(p)
  if tmp > max {
    max = tmp
    ans = p
  }
}
fmt.println(ans)
#+end_src

#+RESULTS:
: 840

* Prob 040 - Champernowne's constant
An irrational decimal fraction is created by concatenating the positive integers:
0.123456789101112131415161718192021...

It can be seen that the 12th digit of the fractional part is 1.
If dn represents the nth digit of the fractional part, find the value of the following expression.

d1 × d10 × d100 × d1000 × d10000 × d100000 × d1000000
#+begin_src odin :includes core:strconv core:strings
d :: proc(n : int) -> int {
  WITH_STR :: false
  str := ""
  digits_cnt := 0
  for i:=0; i<n; i+=1 {
    tmp := fmt.tprintf("%d", i+1)
    if WITH_STR {
      str = strings.concatenate([]string{str, tmp})
    }
    digits_cnt += len(tmp)
    if digits_cnt >= n {
      return strconv._digit_value(rune(tmp[len(tmp)-(digits_cnt-n)-1]))
    }
  }
  return -1
}

fmt.println(d(1) * d(10) * d(100) * d(1_000) * d(10_000) * d(100_000) * d(1_000_000))
#+end_src

#+RESULTS:
: 210

* Prob 041 - Pandigital prime
We shall say that an n-digit number is pandigital if it makes use of all the
digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is
also prime.

What is the largest n-digit pandigital prime that exists?
#+begin_src odin :includes core:strconv ../util :tangle src/pandigital.odin
ret : [dynamic]string; defer delete(ret)
N :: 7
str := ""
for i in 1..=N {
  str = fmt.tprintf("%s%d", str, i)
}

largest := 0
util.permute(str, 0, N-1, &ret)
for i in ret {
  num,_ := strconv.parse_int(i)
  if num > largest && util.is_prime(num) do largest = num
}
fmt.println(largest)
#+end_src

#+RESULTS:
: 7652413

* Prob 042 - Coded triangle numbers
The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so
the first ten triangle numbers are:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

By converting each letter in a word to a number corresponding to its
alphabetical position and adding these values we form a word value. For example,
the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a
triangle number then we shall call the word a triangle word.

ABCDEFGHIJ KL
1234567890 12

Using words.txt (right click and 'Save Link/Target As...'), a 16K text file
containing nearly two-thousand common English words, how many are triangle
words?

** words.txt
tangle this file first so src program has something to read
#+begin_src text :tangle words.txt
"A","ABILITY","ABLE","ABOUT","ABOVE","ABSENCE","ABSOLUTELY","ACADEMIC","ACCEPT","ACCESS","ACCIDENT","ACCOMPANY","ACCORDING","ACCOUNT","ACHIEVE","ACHIEVEMENT","ACID","ACQUIRE","ACROSS","ACT","ACTION","ACTIVE","ACTIVITY","ACTUAL","ACTUALLY","ADD","ADDITION","ADDITIONAL","ADDRESS","ADMINISTRATION","ADMIT","ADOPT","ADULT","ADVANCE","ADVANTAGE","ADVICE","ADVISE","AFFAIR","AFFECT","AFFORD","AFRAID","AFTER","AFTERNOON","AFTERWARDS","AGAIN","AGAINST","AGE","AGENCY","AGENT","AGO","AGREE","AGREEMENT","AHEAD","AID","AIM","AIR","AIRCRAFT","ALL","ALLOW","ALMOST","ALONE","ALONG","ALREADY","ALRIGHT","ALSO","ALTERNATIVE","ALTHOUGH","ALWAYS","AMONG","AMONGST","AMOUNT","AN","ANALYSIS","ANCIENT","AND","ANIMAL","ANNOUNCE","ANNUAL","ANOTHER","ANSWER","ANY","ANYBODY","ANYONE","ANYTHING","ANYWAY","APART","APPARENT","APPARENTLY","APPEAL","APPEAR","APPEARANCE","APPLICATION","APPLY","APPOINT","APPOINTMENT","APPROACH","APPROPRIATE","APPROVE","AREA","ARGUE","ARGUMENT","ARISE","ARM","ARMY","AROUND","ARRANGE","ARRANGEMENT","ARRIVE","ART","ARTICLE","ARTIST","AS","ASK","ASPECT","ASSEMBLY","ASSESS","ASSESSMENT","ASSET","ASSOCIATE","ASSOCIATION","ASSUME","ASSUMPTION","AT","ATMOSPHERE","ATTACH","ATTACK","ATTEMPT","ATTEND","ATTENTION","ATTITUDE","ATTRACT","ATTRACTIVE","AUDIENCE","AUTHOR","AUTHORITY","AVAILABLE","AVERAGE","AVOID","AWARD","AWARE","AWAY","AYE","BABY","BACK","BACKGROUND","BAD","BAG","BALANCE","BALL","BAND","BANK","BAR","BASE","BASIC","BASIS","BATTLE","BE","BEAR","BEAT","BEAUTIFUL","BECAUSE","BECOME","BED","BEDROOM","BEFORE","BEGIN","BEGINNING","BEHAVIOUR","BEHIND","BELIEF","BELIEVE","BELONG","BELOW","BENEATH","BENEFIT","BESIDE","BEST","BETTER","BETWEEN","BEYOND","BIG","BILL","BIND","BIRD","BIRTH","BIT","BLACK","BLOCK","BLOOD","BLOODY","BLOW","BLUE","BOARD","BOAT","BODY","BONE","BOOK","BORDER","BOTH","BOTTLE","BOTTOM","BOX","BOY","BRAIN","BRANCH","BREAK","BREATH","BRIDGE","BRIEF","BRIGHT","BRING","BROAD","BROTHER","BUDGET","BUILD","BUILDING","BURN","BUS","BUSINESS","BUSY","BUT","BUY","BY","CABINET","CALL","CAMPAIGN","CAN","CANDIDATE","CAPABLE","CAPACITY","CAPITAL","CAR","CARD","CARE","CAREER","CAREFUL","CAREFULLY","CARRY","CASE","CASH","CAT","CATCH","CATEGORY","CAUSE","CELL","CENTRAL","CENTRE","CENTURY","CERTAIN","CERTAINLY","CHAIN","CHAIR","CHAIRMAN","CHALLENGE","CHANCE","CHANGE","CHANNEL","CHAPTER","CHARACTER","CHARACTERISTIC","CHARGE","CHEAP","CHECK","CHEMICAL","CHIEF","CHILD","CHOICE","CHOOSE","CHURCH","CIRCLE","CIRCUMSTANCE","CITIZEN","CITY","CIVIL","CLAIM","CLASS","CLEAN","CLEAR","CLEARLY","CLIENT","CLIMB","CLOSE","CLOSELY","CLOTHES","CLUB","COAL","CODE","COFFEE","COLD","COLLEAGUE","COLLECT","COLLECTION","COLLEGE","COLOUR","COMBINATION","COMBINE","COME","COMMENT","COMMERCIAL","COMMISSION","COMMIT","COMMITMENT","COMMITTEE","COMMON","COMMUNICATION","COMMUNITY","COMPANY","COMPARE","COMPARISON","COMPETITION","COMPLETE","COMPLETELY","COMPLEX","COMPONENT","COMPUTER","CONCENTRATE","CONCENTRATION","CONCEPT","CONCERN","CONCERNED","CONCLUDE","CONCLUSION","CONDITION","CONDUCT","CONFERENCE","CONFIDENCE","CONFIRM","CONFLICT","CONGRESS","CONNECT","CONNECTION","CONSEQUENCE","CONSERVATIVE","CONSIDER","CONSIDERABLE","CONSIDERATION","CONSIST","CONSTANT","CONSTRUCTION","CONSUMER","CONTACT","CONTAIN","CONTENT","CONTEXT","CONTINUE","CONTRACT","CONTRAST","CONTRIBUTE","CONTRIBUTION","CONTROL","CONVENTION","CONVERSATION","COPY","CORNER","CORPORATE","CORRECT","COS","COST","COULD","COUNCIL","COUNT","COUNTRY","COUNTY","COUPLE","COURSE","COURT","COVER","CREATE","CREATION","CREDIT","CRIME","CRIMINAL","CRISIS","CRITERION","CRITICAL","CRITICISM","CROSS","CROWD","CRY","CULTURAL","CULTURE","CUP","CURRENT","CURRENTLY","CURRICULUM","CUSTOMER","CUT","DAMAGE","DANGER","DANGEROUS","DARK","DATA","DATE","DAUGHTER","DAY","DEAD","DEAL","DEATH","DEBATE","DEBT","DECADE","DECIDE","DECISION","DECLARE","DEEP","DEFENCE","DEFENDANT","DEFINE","DEFINITION","DEGREE","DELIVER","DEMAND","DEMOCRATIC","DEMONSTRATE","DENY","DEPARTMENT","DEPEND","DEPUTY","DERIVE","DESCRIBE","DESCRIPTION","DESIGN","DESIRE","DESK","DESPITE","DESTROY","DETAIL","DETAILED","DETERMINE","DEVELOP","DEVELOPMENT","DEVICE","DIE","DIFFERENCE","DIFFERENT","DIFFICULT","DIFFICULTY","DINNER","DIRECT","DIRECTION","DIRECTLY","DIRECTOR","DISAPPEAR","DISCIPLINE","DISCOVER","DISCUSS","DISCUSSION","DISEASE","DISPLAY","DISTANCE","DISTINCTION","DISTRIBUTION","DISTRICT","DIVIDE","DIVISION","DO","DOCTOR","DOCUMENT","DOG","DOMESTIC","DOOR","DOUBLE","DOUBT","DOWN","DRAW","DRAWING","DREAM","DRESS","DRINK","DRIVE","DRIVER","DROP","DRUG","DRY","DUE","DURING","DUTY","EACH","EAR","EARLY","EARN","EARTH","EASILY","EAST","EASY","EAT","ECONOMIC","ECONOMY","EDGE","EDITOR","EDUCATION","EDUCATIONAL","EFFECT","EFFECTIVE","EFFECTIVELY","EFFORT","EGG","EITHER","ELDERLY","ELECTION","ELEMENT","ELSE","ELSEWHERE","EMERGE","EMPHASIS","EMPLOY","EMPLOYEE","EMPLOYER","EMPLOYMENT","EMPTY","ENABLE","ENCOURAGE","END","ENEMY","ENERGY","ENGINE","ENGINEERING","ENJOY","ENOUGH","ENSURE","ENTER","ENTERPRISE","ENTIRE","ENTIRELY","ENTITLE","ENTRY","ENVIRONMENT","ENVIRONMENTAL","EQUAL","EQUALLY","EQUIPMENT","ERROR","ESCAPE","ESPECIALLY","ESSENTIAL","ESTABLISH","ESTABLISHMENT","ESTATE","ESTIMATE","EVEN","EVENING","EVENT","EVENTUALLY","EVER","EVERY","EVERYBODY","EVERYONE","EVERYTHING","EVIDENCE","EXACTLY","EXAMINATION","EXAMINE","EXAMPLE","EXCELLENT","EXCEPT","EXCHANGE","EXECUTIVE","EXERCISE","EXHIBITION","EXIST","EXISTENCE","EXISTING","EXPECT","EXPECTATION","EXPENDITURE","EXPENSE","EXPENSIVE","EXPERIENCE","EXPERIMENT","EXPERT","EXPLAIN","EXPLANATION","EXPLORE","EXPRESS","EXPRESSION","EXTEND","EXTENT","EXTERNAL","EXTRA","EXTREMELY","EYE","FACE","FACILITY","FACT","FACTOR","FACTORY","FAIL","FAILURE","FAIR","FAIRLY","FAITH","FALL","FAMILIAR","FAMILY","FAMOUS","FAR","FARM","FARMER","FASHION","FAST","FATHER","FAVOUR","FEAR","FEATURE","FEE","FEEL","FEELING","FEMALE","FEW","FIELD","FIGHT","FIGURE","FILE","FILL","FILM","FINAL","FINALLY","FINANCE","FINANCIAL","FIND","FINDING","FINE","FINGER","FINISH","FIRE","FIRM","FIRST","FISH","FIT","FIX","FLAT","FLIGHT","FLOOR","FLOW","FLOWER","FLY","FOCUS","FOLLOW","FOLLOWING","FOOD","FOOT","FOOTBALL","FOR","FORCE","FOREIGN","FOREST","FORGET","FORM","FORMAL","FORMER","FORWARD","FOUNDATION","FREE","FREEDOM","FREQUENTLY","FRESH","FRIEND","FROM","FRONT","FRUIT","FUEL","FULL","FULLY","FUNCTION","FUND","FUNNY","FURTHER","FUTURE","GAIN","GAME","GARDEN","GAS","GATE","GATHER","GENERAL","GENERALLY","GENERATE","GENERATION","GENTLEMAN","GET","GIRL","GIVE","GLASS","GO","GOAL","GOD","GOLD","GOOD","GOVERNMENT","GRANT","GREAT","GREEN","GREY","GROUND","GROUP","GROW","GROWING","GROWTH","GUEST","GUIDE","GUN","HAIR","HALF","HALL","HAND","HANDLE","HANG","HAPPEN","HAPPY","HARD","HARDLY","HATE","HAVE","HE","HEAD","HEALTH","HEAR","HEART","HEAT","HEAVY","HELL","HELP","HENCE","HER","HERE","HERSELF","HIDE","HIGH","HIGHLY","HILL","HIM","HIMSELF","HIS","HISTORICAL","HISTORY","HIT","HOLD","HOLE","HOLIDAY","HOME","HOPE","HORSE","HOSPITAL","HOT","HOTEL","HOUR","HOUSE","HOUSEHOLD","HOUSING","HOW","HOWEVER","HUGE","HUMAN","HURT","HUSBAND","I","IDEA","IDENTIFY","IF","IGNORE","ILLUSTRATE","IMAGE","IMAGINE","IMMEDIATE","IMMEDIATELY","IMPACT","IMPLICATION","IMPLY","IMPORTANCE","IMPORTANT","IMPOSE","IMPOSSIBLE","IMPRESSION","IMPROVE","IMPROVEMENT","IN","INCIDENT","INCLUDE","INCLUDING","INCOME","INCREASE","INCREASED","INCREASINGLY","INDEED","INDEPENDENT","INDEX","INDICATE","INDIVIDUAL","INDUSTRIAL","INDUSTRY","INFLUENCE","INFORM","INFORMATION","INITIAL","INITIATIVE","INJURY","INSIDE","INSIST","INSTANCE","INSTEAD","INSTITUTE","INSTITUTION","INSTRUCTION","INSTRUMENT","INSURANCE","INTEND","INTENTION","INTEREST","INTERESTED","INTERESTING","INTERNAL","INTERNATIONAL","INTERPRETATION","INTERVIEW","INTO","INTRODUCE","INTRODUCTION","INVESTIGATE","INVESTIGATION","INVESTMENT","INVITE","INVOLVE","IRON","IS","ISLAND","ISSUE","IT","ITEM","ITS","ITSELF","JOB","JOIN","JOINT","JOURNEY","JUDGE","JUMP","JUST","JUSTICE","KEEP","KEY","KID","KILL","KIND","KING","KITCHEN","KNEE","KNOW","KNOWLEDGE","LABOUR","LACK","LADY","LAND","LANGUAGE","LARGE","LARGELY","LAST","LATE","LATER","LATTER","LAUGH","LAUNCH","LAW","LAWYER","LAY","LEAD","LEADER","LEADERSHIP","LEADING","LEAF","LEAGUE","LEAN","LEARN","LEAST","LEAVE","LEFT","LEG","LEGAL","LEGISLATION","LENGTH","LESS","LET","LETTER","LEVEL","LIABILITY","LIBERAL","LIBRARY","LIE","LIFE","LIFT","LIGHT","LIKE","LIKELY","LIMIT","LIMITED","LINE","LINK","LIP","LIST","LISTEN","LITERATURE","LITTLE","LIVE","LIVING","LOAN","LOCAL","LOCATION","LONG","LOOK","LORD","LOSE","LOSS","LOT","LOVE","LOVELY","LOW","LUNCH","MACHINE","MAGAZINE","MAIN","MAINLY","MAINTAIN","MAJOR","MAJORITY","MAKE","MALE","MAN","MANAGE","MANAGEMENT","MANAGER","MANNER","MANY","MAP","MARK","MARKET","MARRIAGE","MARRIED","MARRY","MASS","MASTER","MATCH","MATERIAL","MATTER","MAY","MAYBE","ME","MEAL","MEAN","MEANING","MEANS","MEANWHILE","MEASURE","MECHANISM","MEDIA","MEDICAL","MEET","MEETING","MEMBER","MEMBERSHIP","MEMORY","MENTAL","MENTION","MERELY","MESSAGE","METAL","METHOD","MIDDLE","MIGHT","MILE","MILITARY","MILK","MIND","MINE","MINISTER","MINISTRY","MINUTE","MISS","MISTAKE","MODEL","MODERN","MODULE","MOMENT","MONEY","MONTH","MORE","MORNING","MOST","MOTHER","MOTION","MOTOR","MOUNTAIN","MOUTH","MOVE","MOVEMENT","MUCH","MURDER","MUSEUM","MUSIC","MUST","MY","MYSELF","NAME","NARROW","NATION","NATIONAL","NATURAL","NATURE","NEAR","NEARLY","NECESSARILY","NECESSARY","NECK","NEED","NEGOTIATION","NEIGHBOUR","NEITHER","NETWORK","NEVER","NEVERTHELESS","NEW","NEWS","NEWSPAPER","NEXT","NICE","NIGHT","NO","NOBODY","NOD","NOISE","NONE","NOR","NORMAL","NORMALLY","NORTH","NORTHERN","NOSE","NOT","NOTE","NOTHING","NOTICE","NOTION","NOW","NUCLEAR","NUMBER","NURSE","OBJECT","OBJECTIVE","OBSERVATION","OBSERVE","OBTAIN","OBVIOUS","OBVIOUSLY","OCCASION","OCCUR","ODD","OF","OFF","OFFENCE","OFFER","OFFICE","OFFICER","OFFICIAL","OFTEN","OIL","OKAY","OLD","ON","ONCE","ONE","ONLY","ONTO","OPEN","OPERATE","OPERATION","OPINION","OPPORTUNITY","OPPOSITION","OPTION","OR","ORDER","ORDINARY","ORGANISATION","ORGANISE","ORGANIZATION","ORIGIN","ORIGINAL","OTHER","OTHERWISE","OUGHT","OUR","OURSELVES","OUT","OUTCOME","OUTPUT","OUTSIDE","OVER","OVERALL","OWN","OWNER","PACKAGE","PAGE","PAIN","PAINT","PAINTING","PAIR","PANEL","PAPER","PARENT","PARK","PARLIAMENT","PART","PARTICULAR","PARTICULARLY","PARTLY","PARTNER","PARTY","PASS","PASSAGE","PAST","PATH","PATIENT","PATTERN","PAY","PAYMENT","PEACE","PENSION","PEOPLE","PER","PERCENT","PERFECT","PERFORM","PERFORMANCE","PERHAPS","PERIOD","PERMANENT","PERSON","PERSONAL","PERSUADE","PHASE","PHONE","PHOTOGRAPH","PHYSICAL","PICK","PICTURE","PIECE","PLACE","PLAN","PLANNING","PLANT","PLASTIC","PLATE","PLAY","PLAYER","PLEASE","PLEASURE","PLENTY","PLUS","POCKET","POINT","POLICE","POLICY","POLITICAL","POLITICS","POOL","POOR","POPULAR","POPULATION","POSITION","POSITIVE","POSSIBILITY","POSSIBLE","POSSIBLY","POST","POTENTIAL","POUND","POWER","POWERFUL","PRACTICAL","PRACTICE","PREFER","PREPARE","PRESENCE","PRESENT","PRESIDENT","PRESS","PRESSURE","PRETTY","PREVENT","PREVIOUS","PREVIOUSLY","PRICE","PRIMARY","PRIME","PRINCIPLE","PRIORITY","PRISON","PRISONER","PRIVATE","PROBABLY","PROBLEM","PROCEDURE","PROCESS","PRODUCE","PRODUCT","PRODUCTION","PROFESSIONAL","PROFIT","PROGRAM","PROGRAMME","PROGRESS","PROJECT","PROMISE","PROMOTE","PROPER","PROPERLY","PROPERTY","PROPORTION","PROPOSE","PROPOSAL","PROSPECT","PROTECT","PROTECTION","PROVE","PROVIDE","PROVIDED","PROVISION","PUB","PUBLIC","PUBLICATION","PUBLISH","PULL","PUPIL","PURPOSE","PUSH","PUT","QUALITY","QUARTER","QUESTION","QUICK","QUICKLY","QUIET","QUITE","RACE","RADIO","RAILWAY","RAIN","RAISE","RANGE","RAPIDLY","RARE","RATE","RATHER","REACH","REACTION","READ","READER","READING","READY","REAL","REALISE","REALITY","REALIZE","REALLY","REASON","REASONABLE","RECALL","RECEIVE","RECENT","RECENTLY","RECOGNISE","RECOGNITION","RECOGNIZE","RECOMMEND","RECORD","RECOVER","RED","REDUCE","REDUCTION","REFER","REFERENCE","REFLECT","REFORM","REFUSE","REGARD","REGION","REGIONAL","REGULAR","REGULATION","REJECT","RELATE","RELATION","RELATIONSHIP","RELATIVE","RELATIVELY","RELEASE","RELEVANT","RELIEF","RELIGION","RELIGIOUS","RELY","REMAIN","REMEMBER","REMIND","REMOVE","REPEAT","REPLACE","REPLY","REPORT","REPRESENT","REPRESENTATION","REPRESENTATIVE","REQUEST","REQUIRE","REQUIREMENT","RESEARCH","RESOURCE","RESPECT","RESPOND","RESPONSE","RESPONSIBILITY","RESPONSIBLE","REST","RESTAURANT","RESULT","RETAIN","RETURN","REVEAL","REVENUE","REVIEW","REVOLUTION","RICH","RIDE","RIGHT","RING","RISE","RISK","RIVER","ROAD","ROCK","ROLE","ROLL","ROOF","ROOM","ROUND","ROUTE","ROW","ROYAL","RULE","RUN","RURAL","SAFE","SAFETY","SALE","SAME","SAMPLE","SATISFY","SAVE","SAY","SCALE","SCENE","SCHEME","SCHOOL","SCIENCE","SCIENTIFIC","SCIENTIST","SCORE","SCREEN","SEA","SEARCH","SEASON","SEAT","SECOND","SECONDARY","SECRETARY","SECTION","SECTOR","SECURE","SECURITY","SEE","SEEK","SEEM","SELECT","SELECTION","SELL","SEND","SENIOR","SENSE","SENTENCE","SEPARATE","SEQUENCE","SERIES","SERIOUS","SERIOUSLY","SERVANT","SERVE","SERVICE","SESSION","SET","SETTLE","SETTLEMENT","SEVERAL","SEVERE","SEX","SEXUAL","SHAKE","SHALL","SHAPE","SHARE","SHE","SHEET","SHIP","SHOE","SHOOT","SHOP","SHORT","SHOT","SHOULD","SHOULDER","SHOUT","SHOW","SHUT","SIDE","SIGHT","SIGN","SIGNAL","SIGNIFICANCE","SIGNIFICANT","SILENCE","SIMILAR","SIMPLE","SIMPLY","SINCE","SING","SINGLE","SIR","SISTER","SIT","SITE","SITUATION","SIZE","SKILL","SKIN","SKY","SLEEP","SLIGHTLY","SLIP","SLOW","SLOWLY","SMALL","SMILE","SO","SOCIAL","SOCIETY","SOFT","SOFTWARE","SOIL","SOLDIER","SOLICITOR","SOLUTION","SOME","SOMEBODY","SOMEONE","SOMETHING","SOMETIMES","SOMEWHAT","SOMEWHERE","SON","SONG","SOON","SORRY","SORT","SOUND","SOURCE","SOUTH","SOUTHERN","SPACE","SPEAK","SPEAKER","SPECIAL","SPECIES","SPECIFIC","SPEECH","SPEED","SPEND","SPIRIT","SPORT","SPOT","SPREAD","SPRING","STAFF","STAGE","STAND","STANDARD","STAR","START","STATE","STATEMENT","STATION","STATUS","STAY","STEAL","STEP","STICK","STILL","STOCK","STONE","STOP","STORE","STORY","STRAIGHT","STRANGE","STRATEGY","STREET","STRENGTH","STRIKE","STRONG","STRONGLY","STRUCTURE","STUDENT","STUDIO","STUDY","STUFF","STYLE","SUBJECT","SUBSTANTIAL","SUCCEED","SUCCESS","SUCCESSFUL","SUCH","SUDDENLY","SUFFER","SUFFICIENT","SUGGEST","SUGGESTION","SUITABLE","SUM","SUMMER","SUN","SUPPLY","SUPPORT","SUPPOSE","SURE","SURELY","SURFACE","SURPRISE","SURROUND","SURVEY","SURVIVE","SWITCH","SYSTEM","TABLE","TAKE","TALK","TALL","TAPE","TARGET","TASK","TAX","TEA","TEACH","TEACHER","TEACHING","TEAM","TEAR","TECHNICAL","TECHNIQUE","TECHNOLOGY","TELEPHONE","TELEVISION","TELL","TEMPERATURE","TEND","TERM","TERMS","TERRIBLE","TEST","TEXT","THAN","THANK","THANKS","THAT","THE","THEATRE","THEIR","THEM","THEME","THEMSELVES","THEN","THEORY","THERE","THEREFORE","THESE","THEY","THIN","THING","THINK","THIS","THOSE","THOUGH","THOUGHT","THREAT","THREATEN","THROUGH","THROUGHOUT","THROW","THUS","TICKET","TIME","TINY","TITLE","TO","TODAY","TOGETHER","TOMORROW","TONE","TONIGHT","TOO","TOOL","TOOTH","TOP","TOTAL","TOTALLY","TOUCH","TOUR","TOWARDS","TOWN","TRACK","TRADE","TRADITION","TRADITIONAL","TRAFFIC","TRAIN","TRAINING","TRANSFER","TRANSPORT","TRAVEL","TREAT","TREATMENT","TREATY","TREE","TREND","TRIAL","TRIP","TROOP","TROUBLE","TRUE","TRUST","TRUTH","TRY","TURN","TWICE","TYPE","TYPICAL","UNABLE","UNDER","UNDERSTAND","UNDERSTANDING","UNDERTAKE","UNEMPLOYMENT","UNFORTUNATELY","UNION","UNIT","UNITED","UNIVERSITY","UNLESS","UNLIKELY","UNTIL","UP","UPON","UPPER","URBAN","US","USE","USED","USEFUL","USER","USUAL","USUALLY","VALUE","VARIATION","VARIETY","VARIOUS","VARY","VAST","VEHICLE","VERSION","VERY","VIA","VICTIM","VICTORY","VIDEO","VIEW","VILLAGE","VIOLENCE","VISION","VISIT","VISITOR","VITAL","VOICE","VOLUME","VOTE","WAGE","WAIT","WALK","WALL","WANT","WAR","WARM","WARN","WASH","WATCH","WATER","WAVE","WAY","WE","WEAK","WEAPON","WEAR","WEATHER","WEEK","WEEKEND","WEIGHT","WELCOME","WELFARE","WELL","WEST","WESTERN","WHAT","WHATEVER","WHEN","WHERE","WHEREAS","WHETHER","WHICH","WHILE","WHILST","WHITE","WHO","WHOLE","WHOM","WHOSE","WHY","WIDE","WIDELY","WIFE","WILD","WILL","WIN","WIND","WINDOW","WINE","WING","WINNER","WINTER","WISH","WITH","WITHDRAW","WITHIN","WITHOUT","WOMAN","WONDER","WONDERFUL","WOOD","WORD","WORK","WORKER","WORKING","WORKS","WORLD","WORRY","WORTH","WOULD","WRITE","WRITER","WRITING","WRONG","YARD","YEAH","YEAR","YES","YESTERDAY","YET","YOU","YOUNG","YOUR","YOURSELF","YOUTH"
#+end_src
** src
#+begin_src odin :main no :tangle src/coded_tri_nums.odin
package pe

import "core:os"
import "core:fmt"
import "core:strings"

tri_num :: proc(num : int) -> bool {
  n := num * 2
  for i in 1..<9000 {
    if n % i == 0 && n / i == i + 1 {
      return true
    }
  }
  return false
}

main :: proc() {
  file, err := os.open("words.txt", ); defer os.close(file)
  data, ok := os.read_entire_file(file)
  data1 := strings.split_lines(string(data))[0]
  words : []string
  cnt := 0
  if ok {
    words = strings.split(data1, ",")
    for w in words {
      //fmt.println(w[1:len(w)-1])
      word := w[1:len(w)-1]
      wcnt := 0
      for i in word {
        wcnt += cast(int)(i-'A')+1
      }
      if tri_num(wcnt) {
        cnt += 1
      }
    }
  }
  fmt.println(cnt)
}
#+end_src

#+RESULTS:
: 162

* Prob 043 - Sub-string divisibility
The number, 1406357289, is a 0 to 9 pandigital number because it is made up of
each of the digits 0 to 9 in some order, but it also has a rather interesting
sub-string divisibility property.

Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note
the following:

d2d3d4=406 is divisible by 2
d3d4d5=063 is divisible by 3
d4d5d6=635 is divisible by 5
d5d6d7=357 is divisible by 7
d6d7d8=572 is divisible by 11
d7d8d9=728 is divisible by 13
d8d9d10=289 is divisible by 17
Find the sum of all 0 to 9 pandigital numbers with this property.

#+begin_src odin :main no :tangle src/sub-string-div.odin
package pe_043

import "core:os"
import "core:fmt"
import "core:strings"
import "core:strconv"
import "../util" 

sub_string_div :: proc(num: string) -> bool {
  d2,_ := strconv.parse_int(num[1:4])
  d3,_ := strconv.parse_int(num[2:5])
  d4,_ := strconv.parse_int(num[3:6])
  d5,_ := strconv.parse_int(num[4:7])
  d6,_ := strconv.parse_int(num[5:8])
  d7,_ := strconv.parse_int(num[6:9])
  d8,_ := strconv.parse_int(num[7:10])
  if d2 % 2 == 0 &&
    d3 % 3 == 0 &&
    d4 % 5 == 0 &&
    d5 % 7 == 0 &&
    d6 % 11 == 0 &&
    d7 % 13 == 0 &&
    d8 % 17 == 0 {
      return true
    }
  return false
}

main :: proc() {
  ret : [dynamic]string; defer delete(ret)
  N :: 9
  str := ""
  for i in 0..=N {
    str = fmt.tprintf("%s%d", str, i)
  }
  util.permute(str, 0, N, &ret)

  total := 0
  for i in ret {
    if sub_string_div(i) {
      //fmt.println(i)
      num,_ := strconv.parse_int(i)
      total += num
    }
  }
  fmt.println(total)
}
#+end_src

#+RESULTS:
: 16695334890

* Prob 044 - Pentagon numbers
Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten
pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 −
22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of
D?

#+begin_src odin :main no
 import "core:fmt"
 import "core:math"

 is_pentagonal :: proc(x: int) -> bool {
   r := math.sqrt_f64(1 + 24 * cast(f64)x)
   n, frac := math.modf(r)
   if frac == 0.0 {
     return cast(u64)n % 6 == 5
   }
   return false
 }

 main :: proc() {
   nums := [dynamic]int{ 1, 5, 12 }; defer delete(nums)

   n := 10
   Pn := 22
   for {
     append(&nums, Pn)

     for i in 0..<len(nums) {
       a := Pn - nums[i]
       b := nums[i]
       if is_pentagonal(a) && is_pentagonal(abs(a - b)) {
         fmt.println(abs(a - b))
         return
       }
     }
     n+=3; Pn+=n
   }
 }
#+end_src

#+RESULTS:
: 5482660

* Prob 045 - Triangular, pentagonal, and hexagonal
Triangle, pentagonal, and hexagonal numbers are generated by the following
formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.

#+begin_src odin :main no
 import "core:fmt"
 import "core:math"

 is_pentagonal :: proc(x: u64) -> bool {
   r := math.sqrt_f64(1 + 24 * cast(f64)x)
   n, frac := math.modf(r)
   if frac == 0.0 {
     return cast(u64)n % 6 == 5
   }
   return false
 }

 main :: proc() {
   for m : u64 = 144; ; m+=1 {
     res : u64 = 2 * m * m - m // hex num is a tri num with n = 2m - 1 (the odd tri num indexes)
     if is_pentagonal(res) {
       fmt.println(res)
       break
     }
   }
 }
#+end_src

#+RESULTS:
: 1533776805

* Prob 046 - Goldbach's other conjecture
It was proposed by Christian Goldbach that every odd composite number can be
written as the sum of a prime and twice a square.

9 = 7 + 2×1^2
15 = 7 + 2×2^2
21 = 3 + 2×3^2
25 = 7 + 2×3^2
27 = 19 + 2×2^2
33 = 31 + 2×1^2

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime
and twice a square?

#+begin_src odin :main no :tangle src/goldbach.odin
 import "core:fmt"
 import "core:math"
 import "../util"

 is_2sq :: proc(x: int) -> bool {
   if x % 2 != 0 do return false
   num := x / 2
   r := math.sqrt_f64(cast(f64)num)
   n, frac := math.modf(r)
   if frac != 0.0 do return false
   return true
 }

 is_sum_of_prime_and_2sq :: proc(x: int) -> bool {
   num := x - 2
   for ; num > 0; num-=2{
     if !util.is_prime(num) do continue
     if is_2sq(x-num) do return true
   }
   return false
 }

 main :: proc() {
   num := 9
   for {
     num += 2
     if util.is_prime(num) do continue
     //fmt.println(num, is_sum_of_prime_and_2sq(num))
     if is_sum_of_prime_and_2sq(num) do continue
     fmt.println(num)
     break
   }
 }
#+end_src

#+RESULTS:
: 5777

* Prob 047 - Distinct primes factors
The first two consecutive numbers to have two distinct prime factors are:
14 = 2 × 7
15 = 3 × 5

The first three consecutive numbers to have three distinct prime factors are:
644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.

Find the first four consecutive integers to have four distinct prime factors
each. What is the first of these numbers?

Here _distinct_ doesn't mean the primes from 14 and 15 have to be different,
just that there is 2 prime factors in each (this did not register with my mind
at first, so yeah! that sucked)

#+begin_src odin :main no :tangle src/distinct_primes.odin
import "core:fmt"
import "../util"

Prime_Factor :: struct {
  prime : int,
  power : int,
}

// either increment (add 1 to power of a prime factor) or add this prime factor to the list
inc_or_add :: proc(x: int, list: ^[dynamic]Prime_Factor) {
  found := false
  for &i in list {
    if i.prime == x {
      i.power += 1 // inc
      found = true
    }
  }
  if !found {
    append(list, Prime_Factor{x, 1})
  }
}

get_prime_factorization :: proc(x: int, list: ^[dynamic]Prime_Factor) {
  n := x
  tmp := x / 2
  clear(list)
  for i in 2..=tmp {     // put all prime factors into list
    if util.is_prime(i) {
      for; n % i == 0; { // this prime divides x
        inc_or_add(i, list)
        n = n / i        // correct here right? can it be: n / i - 1 ? is div slow?
      }
    }
  }
  return
}

main :: proc() {
  C :: 4    // consecutive
  num := 11 // start search from here
  list : [C][dynamic]Prime_Factor
  for i in 0..<C {
    get_prime_factorization(num - i, &list[C-i-1])
  }
  found := false
  for {
    // compare length of pfactors in list
    found = true
    for i in 0..<C {
      if len(list[i]) != C {
        found = false // one of 'em is not length C, boo
        break
      }
    }
    if found do break
    // shift things down, get next numbers prime factors, try again
    for i in 0..<C-1 {
      list[i] = list[i+1]
    }
    num += 1
    get_prime_factorization(num, &list[C-1])
    // fmt.println(num)... this takes SOOOO long to find you might want to include this to see how far you've come
  }
  tmp := ""
  for i in 0..<C {
    tmp = fmt.tprintf("%s %v", tmp, num-i)
  }
  fmt.println(C, tmp)
}
#+end_src

* Prob 048 - Self Powers
The series, 1^{1} + 2^{2} + 3^{3} + ... + 10^{10} = 10405071317.
Find the last ten digits of the series, 1^{1} + 2^{2} + 3^{3} + ... + 1000^{1000}.

#+begin_src odin :main no :tangle src/self_powers.odin
import "core:fmt"
import "core:math"

main :: proc() {
  //fmt.println(math.pow_f64(1000,1000)) // too big! shows +Inf
  // since all we care about is last 10 digits, can we make a special power proc?
  // note: 9^9 is already 9 digits: 387420489
  ten_digit_pow :: proc(base, exp: u128) -> u128 { // needs u128
    val : u128 = 10_000_000_000
    if base % 10 == 0 && exp % 10 == 0 {
      return 0
    } else if base == 16 && exp == 16 {
      return 3709551616 // too big for u64, so pre-calc?... many other derpy combos in u64
    } else if exp == 1 {
      return base
    } else if exp == 0 {
      return 1
    } else if exp < 0 {
      return 0 // should never happen
    } else if (exp % 2) == 0 {
      half_pow := (ten_digit_pow(base, exp >> 1)) % val
      return (half_pow * half_pow) % val
    } else {
      return (base * ten_digit_pow(base, exp - 1)) % val
    }
  }

  acc2 : u128 = 0
  for i in 1..=1000 {
    tmp := ten_digit_pow(u128(i), u128(i))
    acc2 += tmp
    acc2 = acc2 % 10_000_000_000
  }
  fmt.println(acc2) // TODO: make work with u64?
}
#+end_src

* Prob 049 - Prime Permutations
The arithmetic sequence, $1487, 4817, 8147$, in which each of the terms
increases by $3330$, is unusual in two ways:
(i) each of the three terms are prime, and,
(ii) each of the 4-digit numbers are permutations of one another.

There are no arithmetic sequences made up of three 
1-, 2-, or 3-digit primes, exhibiting this property, but there is one other
4-digit increasing sequence.

What 12-digit number do you form by concatenating the three terms in this
sequence?

#+begin_src odin :main no :tangle src/prime_permutations.odin
import "core:fmt"
import "../util"

are_2_premutations_prime :: proc(x: int) -> bool {
  a : [4]u8
  a.x = u8(x / 1000)
  a.y = u8((x-int(a.x)*1000) / 100)
  a.z = u8((x-int(a.x)*1000-int(a.y)*100) / 10)
  a.w = u8(x % 10)

  num : int
  b := [23][4]u8{a.xywz,
                 a.xzyw,
                 a.xzwy,
                 a.xwyz,
                 a.xwzy,
                 a.yxzw,
                 a.yxwz,
                 a.yzxw,
                 a.yzwx,
                 a.ywxz,
                 a.ywzx,
                 a.zxyw,
                 a.zxwy,
                 a.zyxw,
                 a.zywx,
                 a.zwxy,
                 a.zwyx,
                 a.wxyz,
                 a.wxzy,
                 a.wyxz,
                 a.wyzx,
                 a.wzxy,
                 a.wzyx}

  num_in_b :: proc(x: int, b: ^[23][4]u8) -> bool {
    a : [4]u8
    a.x = u8(x / 1000)
    a.y = u8((x-int(a.x)*1000) / 100)
    a.z = u8((x-int(a.x)*1000-int(a.y)*100) / 10)
    a.w = u8(x % 10)
    for bb in b {
      if a == bb do return true
    }
    return false
  }

  for bb in b {
    num = int(bb.x) * 1000 + int(bb.y) * 100 + int(bb.z) * 10 + int(bb.w)
    if num <= x do continue
    if util.is_prime(num) {
      diff := num - x
      num2 := num + diff
      if num2 <= 9999 {
        if util.is_prime(num2) && num_in_b(num2, &b) {
          fmt.println(x, num, num2, diff)
          return true
        }
      }
    }
  }

  return false
}

main :: proc() {
  primes : [dynamic]int; defer delete(primes)
  for x in 1000..=9999 {
    if util.is_prime(x) {
      append(&primes, x)
    }
  }
  for x in primes {
    are_2_premutations_prime(x)
  }
}
#+end_src

* Prob 050 - Consecutive Prime Sum
The prime 41, can be written as the sum of six consecutive primes:
$41 = 2 + 3 + 5 + 7 + 11 + 13$

This is the longest sum of consecutive primes that adds to a prime below
one-hundred.

The longest sum of consecutive primes below one-thousand that adds to a prime,
contains 21 terms, and is equal to 953.

Which prime, below one-million, can be written as the sum of the most
consecutive primes?
#+begin_src odin :main no :tangle src/consec_prime_sum.odin
import "core:fmt"
import "../util"

main :: proc() {
  below := 1_000_000
  primes : [dynamic]int; defer delete(primes)
  pmarks : [dynamic]int; defer delete(pmarks)
  for x in 2..=below {
    if util.is_prime(x) {
      append(&primes, x)
      append(&pmarks, 0) // for marking longest consec prime starting @ this prime
    }
  }

  // try all added together (as a window), then dec last prime from "window"
  // then try move of window "down"
  // so under 10 would look like 2+3+5+7=17 check prime.. would stop here, since this is longest, but 17 isn't below 10
  // then 2+3+5=10 check prime
  // then 3+5+7=15 check
  // then 2+3=5 check
  // then 3+5=8 check
  // then 5+7=12 check
  // then ... nothing length 1 of consec primes is meaningless
  window_size := len(primes)
  found := false
  for ; window_size > 1 && !found; {
    // a big window size checks many primes, if there was a way
    // to go through once marking sequences that do add to prime
    // that would be faster, right?
    // so like 2+3+5=10 which is not prime, but 2+3=5 is
    // mark prime 2 as having length 2 to make a prime
    // ... so after 2+3+5=10 is done, next time we see prime 2 and window_size == pmark[prime_2's_idx].. we are done
    // else skip to next
    // TODO: this still takes like more than 35 seconds =(
    
    for s_idx := 0; s_idx + window_size <= len(primes); s_idx += 1 {
      acc := 0
      plen := 0
      if pmarks[s_idx] == window_size {
        for i in primes[s_idx:s_idx+window_size] {
          acc += i
        }
        fmt.println("found", window_size, acc, primes[s_idx:s_idx+window_size])
        found = true
        break
      } else if pmarks[s_idx] == 0 {
        for i in s_idx..<(s_idx + window_size) {
          acc += primes[i]
          plen += 1
          if plen > 1 && acc < below && util.is_prime(acc) {
            pmarks[s_idx] = plen
          }
        }
        if pmarks[s_idx] == 0 do pmarks[s_idx] = -1 // nothing here makes a prime, ignored in future
      }
    }
    window_size -= 1
  }
}
#+end_src

* Prob 051 - Prime Digit Replacements
By replacing the 1st digit of the 2-digit number *3, it turns out that six of
the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit
number is the first example having seven primes among the ten generated numbers,
yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993.
Consequently 56003, being the first member of this family, is the smallest prime
with this property.

Find the smallest prime which, by replacing part of the number (not necessarily
adjacent digits) with the same digit, is part of an eight prime value family.

#+begin_src odin :main no :comments link :tangle src/prime_digit_replacements.odin
package prime_digit_replacements

import "core:fmt"
import "core:strings"
import "core:strconv"
import "../util"

main :: proc() {
	places : [dynamic]int; defer delete(places) // list of 1st, 2nd, etc places that we test for replacement with a digit 0-9
	
	x := 56_000 // start here
	looking_for_family_size := 8 // ex: 6 out of 9 prime value family
	largest_so_far := 0

	no_more := false
	for ; x < 1_000_000; x += 1 {
		if util.is_prime(x) {

			xstr := fmt.tprintf("%d", x)
			//fmt.printf("%d len: %d\n", x, len(xstr))

			arr := make([]int, len(xstr))           // index into digits of prime
			for i in 0..<len(xstr) {
				arr[i] = i
			}
			num_stars := 1
			for ; num_stars < len(xstr)-1; num_stars += 1 {
				places : [dynamic][]int
				util.get_combinations(arr, num_stars, &places) // all the combinations of where some number of *'s would go ie: 56**3

				// remove from places when *'s don't contain same digit number
				for j, j_idx in places {
					same_num : u8
					remove := false
					for k in 0..<len(j) {
						if k == 0 {
							same_num = xstr[j[k]] // first
						} else if same_num != xstr[j[k]] {
							remove = true
							break
						}
					}
					if remove {
						//fmt.println(x, "gets no", j)
						places[j_idx] = []int{}
					}
				}

				no_test := false
				for j in places {
					family_size := 1
					
					for star_digit in 0..=9 {
						xstr2 := strings.clone(xstr)
						x2_num := 0
						
						for k in j { // all the places where star_digit will replace a prime digit
							// note: zero (0) can't replace first digit
							if k == 0 && star_digit == 0 {
								no_test = true
								break
							}
							str_tmp := fmt.tprintf("%d", star_digit)
							raw_data(xstr2)[k] = str_tmp[0]
						}
						x2_num, _ = strconv.parse_int(xstr2)
						if x2_num != x { // don't test original prime
							//fmt.println("test", xstr2, util.is_prime(x2_num))
							if util.is_prime(x2_num) {
								family_size += 1
							}
						}
					}
					if family_size >= looking_for_family_size {
						fmt.println("YAY", x, "with", family_size, "primes and", num_stars, "star replacement", j)
						no_more = true
						break
					}
					if family_size > largest_so_far {
						largest_so_far = family_size
						fmt.println("so far", x, "with", family_size, "primes and", num_stars, "star replacement", j)
					}
				} // end for j in places
				if no_more do break
			}
			if no_more do break
		}
	}
}
#+end_src

#+RESULTS:
| so far 56003 with 3 primes and 1 star replacement [0] |    |    |
| so far 56003 with 7 primes and 2 star replacement [2  | 3] |    |
| YAY 121313 with 8 primes and 3 star replacement [0    |  2 | 4] |
* Prob 052 - Permuted Multiples
It can be seen that the number, 125874, and its double, 251748, contain exactly
the same digits, but in a different order.

Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain
the same digits.

#+begin_src odin :main no :comments link :tangle src/permuted_multiples.odin
package permuted_multiples

import "core:c"
import "core:fmt"
import "core:strconv"

get_digit_cnts :: proc(#any_int num: int) -> (ret: [10]int) {
	// returns int array 0-9 with count of those digits in the num(ber)
	//                            0 1 2 3 4 5 6 7 8 9
	// ex: 1258744 would be []int{0,1,1,0,2,1,0,1,1,0}... or two 4's etc..
	str := fmt.tprintf("%d", num)
	for _,i in str {
		val := strconv._digit_value(rune(str[i]))
		if val <= 9 && val >= 0 {
			ret[val] += 1
		}
	}
	return
}

main :: proc() {
	//fmt.println(get_digit_cnts(1258744))
	num : i32 = 1
	for ; num < c.INT32_MAX; num += 1 {
		x1 := get_digit_cnts(num)
		x2 := get_digit_cnts(2*num)
		x3 := get_digit_cnts(3*num)
		x4 := get_digit_cnts(4*num)
		x5 := get_digit_cnts(5*num)
		x6 := get_digit_cnts(6*num)
		if x1 == x2 &&
			x2 == x3 &&
			x3 == x4 &&
			x4 == x5 &&
			x5 == x6
		{
			fmt.println(num)
			break
		}
	}
}
#+end_src

#+RESULTS:
: 142857
* Prob 053 - Combinatoric Selections
There are exactly ten ways of selecting three from five, 12345:
123, 124, 125, 134, 135, 145, 234, 235, 245, and 345

In combinatorics, we use the notation, $\displaystyle \binom 5 3 = 10$.
In general, $\displaystyle \binom n r = \dfrac{n!}{r!(n-r)!}$, where r \le n, n! = n \times (n-1) \times ... \times 3 \times 2 \times 1, and 0! = 1.

It is not until n = 23, that a value exceeds one-million: $\displaystyle \binom {23} {10} = 1144066$.

How many, not necessarily distinct, values of $\displaystyle \binom n r$ for
1 \le n \le 100, are greater than one-million?

#+begin_src odin :main no :comments link :tangle src/combinatoric_selections.odin
package combinatoric_selections

import "core:fmt"
import "../util"

main :: proc() {
	//fmt.println(util.nCr(5, 3))
	//fmt.println(util.nCr(23,10))

	cnt := 0
	for n in 1..=100 {
		for r in 0..=n {
			tmp := util.nCr(n, r)
			if tmp > 1_000_000 || tmp == -1 {
				cnt += 1
			}
		}
	}
	fmt.println(cnt)
}
#+end_src

#+RESULTS:
: 4075

* Prob 054 - Poker Hands
Problem 54
In the card game poker, a hand consists of five cards and are ranked, from
lowest to highest, in the following way:

1. High Card: Highest value card.
2. One Pair: Two cards of the same value.
3. Two Pairs: Two different pairs.
4. Three of a Kind: Three cards of the same value.
5. Straight: All cards are consecutive values.
6. Flush: All cards of the same suit.
7. Full House: Three of a kind and a pair.
8. Four of a Kind: Four cards of the same value.
9. Straight Flush: All cards are consecutive values of same suit.
10. Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.

The cards are valued in the order:
2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.

If two players have the same ranked hands then the rank made up of the highest
value wins; for example, a pair of eights beats a pair of fives (see example 1
below). But if two ranks tie, for example, both players have a pair of queens,
then highest cards in each hand are compared (see example 4 below); if the
highest cards tie then the next highest cards are compared, and so on.\

Consider the following five hands dealt to two players:

| Hand | Player 1                                          | Player 2                                           | Winner   |
|    1 | 5H 5C 6S 7S KD - Pair of Fives                    | 2C 3S 8S 8D TD - Pair of Eights                    | Player 2 |
|    2 | 5D 8C 9S JS AC - Highest card Ace                 | 2C 5C 7D 8S QH - Highest card Queen                | Player 1 |
|    3 | 2D 9C AS AH AC - Three Aces                       | 3D 6D 7D TD QD - Flush with Diamonds               | Player 2 |
|    4 | 4D 6S 9H QH QC - Pair of Queens Highest card Nine | 3D 6D 7H QD QS - Pair of Queens Highest card Seven | Player 1 |
|    5 | 2H 2D 4C 4D 4S - Full House with Three Fours      | 3C 3D 3S 9S 9D - Full House with Three Threes      | Player 1 |

The file, poker.txt, contains one-thousand random hands dealt to two players.
Each line of the file contains ten cards (separated by a single space): the
first five are Player 1's cards and the last five are Player 2's cards. You can
assume that all hands are valid (no invalid characters or repeated cards), each
player's hand is in no specific order, and in each hand there is a clear winner.

How many hands does Player 1 win?

#+begin_src text :tangle src/poker.txt
8C TS KC 9H 4S 7D 2S 5D 3S AC
5C AD 5D AC 9C 7C 5H 8D TD KS
3H 7H 6S KC JS QH TD JC 2D 8S
TH 8H 5C QS TC 9H 4D JC KS JS
7C 5H KC QH JD AS KH 4C AD 4S
5H KS 9C 7D 9H 8D 3S 5D 5C AH
6H 4H 5C 3H 2H 3S QH 5S 6S AS
TD 8C 4H 7C TC KC 4C 3H 7S KS
7C 9C 6D KD 3H 4C QS QC AC KH
JC 6S 5H 2H 2D KD 9D 7C AS JS
AD QH TH 9D 8H TS 6D 3S AS AC
2H 4S 5C 5S TC KC JD 6C TS 3C
QD AS 6H JS 2C 3D 9H KC 4H 8S
KD 8S 9S 7C 2S 3S 6D 6S 4H KC
3C 8C 2D 7D 4D 9S 4S QH 4H JD
8C KC 7S TC 2D TS 8H QD AC 5C
3D KH QD 6C 6S AD AS 8H 2H QS
6S 8D 4C 8S 6C QH TC 6D 7D 9D
2S 8D 8C 4C TS 9S 9D 9C AC 3D
3C QS 2S 4H JH 3D 2D TD 8S 9H
5H QS 8S 6D 3C 8C JD AS 7H 7D
6H TD 9D AS JH 6C QC 9S KD JC
AH 8S QS 4D TH AC TS 3C 3D 5C
5S 4D JS 3D 8H 6C TS 3S AD 8C
6D 7C 5D 5H 3S 5C JC 2H 5S 3D
5H 6H 2S KS 3D 5D JD 7H JS 8H
KH 4H AS JS QS QC TC 6D 7C KS
3D QS TS 2H JS 4D AS 9S JC KD
QD 5H 4D 5D KH 7H 3D JS KD 4H
2C 9H 6H 5C 9D 6C JC 2D TH 9S
7D 6D AS QD JH 4D JS 7C QS 5C
3H KH QD AD 8C 8H 3S TH 9D 5S
AH 9S 4D 9D 8S 4H JS 3C TC 8D
2C KS 5H QD 3S TS 9H AH AD 8S
5C 7H 5D KD 9H 4D 3D 2D KS AD
KS KC 9S 6D 2C QH 9D 9H TS TC
9C 6H 5D QH 4D AD 6D QC JS KH
9S 3H 9D JD 5C 4D 9H AS TC QH
2C 6D JC 9C 3C AD 9S KH 9D 7D
KC 9C 7C JC JS KD 3H AS 3C 7D
QD KH QS 2C 3S 8S 8H 9H 9C JC
QH 8D 3C KC 4C 4H 6D AD 9H 9D
3S KS QS 7H KH 7D 5H 5D JD AD
2H 2C 6H TH TC 7D 8D 4H 8C AS
4S 2H AC QC 3S 6D TH 4D 4C KH
4D TC KS AS 7C 3C 6D 2D 9H 6C
8C TD 5D QS 2C 7H 4C 9C 3H 9H
5H JH TS 7S TD 6H AD QD 8H 8S
5S AD 9C 8C 7C 8D 5H 9D 8S 2S
4H KH KS 9S 2S KC 5S AD 4S 7D
QS 9C QD 6H JS 5D AC 8D 2S AS
KH AC JC 3S 9D 9S 3C 9C 5S JS
AD 3C 3D KS 3S 5C 9C 8C TS 4S
JH 8D 5D 6H KD QS QD 3D 6C KC
8S JD 6C 3S 8C TC QC 3C QH JS
KC JC 8H 2S 9H 9C JH 8S 8C 9S
8S 2H QH 4D QC 9D KC AS TH 3C
8S 6H TH 7C 2H 6S 3C 3H AS 7S
QH 5S JS 4H 5H TS 8H AH AC JC
9D 8H 2S 4S TC JC 3C 7H 3H 5C
3D AD 3C 3S 4C QC AS 5D TH 8C
6S 9D 4C JS KH AH TS JD 8H AD
4C 6S 9D 7S AC 4D 3D 3S TC JD
AD 7H 6H 4H JH KC TD TS 7D 6S
8H JH TC 3S 8D 8C 9S 2C 5C 4D
2C 9D KC QH TH QS JC 9C 4H TS
QS 3C QD 8H KH 4H 8D TD 8S AC
7C 3C TH 5S 8H 8C 9C JD TC KD
QC TC JD TS 8C 3H 6H KD 7C TD
JH QS KS 9C 6D 6S AS 9H KH 6H
2H 4D AH 2D JH 6H TD 5D 4H JD
KD 8C 9S JH QD JS 2C QS 5C 7C
4S TC 7H 8D 2S 6H 7S 9C 7C KC
8C 5D 7H 4S TD QC 8S JS 4H KS
AD 8S JH 6D TD KD 7C 6C 2D 7D
JC 6H 6S JS 4H QH 9H AH 4C 3C
6H 5H AS 7C 7S 3D KH KC 5D 5C
JC 3D TD AS 4D 6D 6S QH JD KS
8C 7S 8S QH 2S JD 5C 7H AH QD
8S 3C 6H 6C 2C 8D TD 7D 4C 4D
5D QH KH 7C 2S 7H JS 6D QC QD
AD 6C 6S 7D TH 6H 2H 8H KH 4H
KS JS KD 5D 2D KH 7D 9C 8C 3D
9C 6D QD 3C KS 3S 7S AH JD 2D
AH QH AS JC 8S 8H 4C KC TH 7D
JC 5H TD 7C 5D KD 4C AD 8H JS
KC 2H AC AH 7D JH KH 5D 7S 6D
9S 5S 9C 6H 8S TD JD 9H 6C AC
7D 8S 6D TS KD 7H AC 5S 7C 5D
AH QC JC 4C TC 8C 2H TS 2C 7D
KD KC 6S 3D 7D 2S 8S 3H 5S 5C
8S 5D 8H 4C 6H KC 3H 7C 5S KD
JH 8C 3D 3C 6C KC TD 7H 7C 4C
JC KC 6H TS QS TD KS 8H 8C 9S
6C 5S 9C QH 7D AH KS KC 9S 2C
4D 4S 8H TD 9C 3S 7D 9D AS TH
6S 7D 3C 6H 5D KD 2C 5C 9D 9C
2H KC 3D AD 3H QD QS 8D JC 4S
8C 3H 9C 7C AD 5D JC 9D JS AS
5D 9H 5C 7H 6S 6C QC JC QD 9S
JC QS JH 2C 6S 9C QC 3D 4S TC
4H 5S 8D 3D 4D 2S KC 2H JS 2C
TD 3S TH KD 4D 7H JH JS KS AC
7S 8C 9S 2D 8S 7D 5C AD 9D AS
8C 7H 2S 6C TH 3H 4C 3S 8H AC
KD 5H JC 8H JD 2D 4H TD JH 5C
3D AS QH KS 7H JD 8S 5S 6D 5H
9S 6S TC QS JC 5C 5D 9C TH 8C
5H 3S JH 9H 2S 2C 6S 7S AS KS
8C QD JC QS TC QC 4H AC KH 6C
TC 5H 7D JH 4H 2H 8D JC KS 4D
5S 9C KH KD 9H 5C TS 3D 7D 2D
5H AS TC 4D 8C 2C TS 9D 3H 8D
6H 8D 2D 9H JD 6C 4S 5H 5S 6D
AD 9C JC 7D 6H 9S 6D JS 9H 3C
AD JH TC QS 4C 5D 9S 7C 9C AH
KD 6H 2H TH 8S QD KS 9D 9H AS
4H 8H 8D 5H 6C AH 5S AS AD 8S
QS 5D 4S 2H TD KS 5H AC 3H JC
9C 7D QD KD AC 6D 5H QH 6H 5S
KC AH QH 2H 7D QS 3H KS 7S JD
6C 8S 3H 6D KS QD 5D 5C 8H TC
9H 4D 4S 6S 9D KH QC 4H 6C JD
TD 2D QH 4S 6H JH KD 3C QD 8C
4S 6H 7C QD 9D AS AH 6S AD 3C
2C KC TH 6H 8D AH 5C 6D 8S 5D
TD TS 7C AD JC QD 9H 3C KC 7H
5D 4D 5S 8H 4H 7D 3H JD KD 2D
JH TD 6H QS 4S KD 5C 8S 7D 8H
AC 3D AS 8C TD 7H KH 5D 6C JD
9D KS 7C 6D QH TC JD KD AS KC
JH 8S 5S 7S 7D AS 2D 3D AD 2H
2H 5D AS 3C QD KC 6H 9H 9S 2C
9D 5D TH 4C JH 3H 8D TC 8H 9H
6H KD 2C TD 2H 6C 9D 2D JS 8C
KD 7S 3C 7C AS QH TS AD 8C 2S
QS 8H 6C JS 4C 9S QC AD TD TS
2H 7C TS TC 8C 3C 9H 2D 6D JC
TC 2H 8D JH KS 6D 3H TD TH 8H
9D TD 9H QC 5D 6C 8H 8C KC TS
2H 8C 3D AH 4D TH TC 7D 8H KC
TS 5C 2D 8C 6S KH AH 5H 6H KC
5S 5D AH TC 4C JD 8D 6H 8C 6C
KC QD 3D 8H 2D JC 9H 4H AD 2S
TD 6S 7D JS KD 4H QS 2S 3S 8C
4C 9H JH TS 3S 4H QC 5S 9S 9C
2C KD 9H JS 9S 3H JC TS 5D AC
AS 2H 5D AD 5H JC 7S TD JS 4C
2D 4S 8H 3D 7D 2C AD KD 9C TS
7H QD JH 5H JS AC 3D TH 4C 8H
6D KH KC QD 5C AD 7C 2D 4H AC
3D 9D TC 8S QD 2C JC 4H JD AH
6C TD 5S TC 8S AH 2C 5D AS AC
TH 7S 3D AS 6C 4C 7H 7D 4H AH
5C 2H KS 6H 7S 4H 5H 3D 3C 7H
3C 9S AC 7S QH 2H 3D 6S 3S 3H
2D 3H AS 2C 6H TC JS 6S 9C 6C
QH KD QD 6D AC 6H KH 2C TS 8C
8H 7D 3S 9H 5D 3H 4S QC 9S 5H
2D 9D 7H 6H 3C 8S 5H 4D 3S 4S
KD 9S 4S TC 7S QC 3S 8S 2H 7H
TC 3D 8C 3H 6C 2H 6H KS KD 4D
KC 3D 9S 3H JS 4S 8H 2D 6C 8S
6H QS 6C TC QD 9H 7D 7C 5H 4D
TD 9D 8D 6S 6C TC 5D TS JS 8H
4H KC JD 9H TC 2C 6S 5H 8H AS
JS 9C 5C 6S 9D JD 8H KC 4C 6D
4D 8D 8S 6C 7C 6H 7H 8H 5C KC
TC 3D JC 6D KS 9S 6H 7S 9C 2C
6C 3S KD 5H TS 7D 9H 9S 6H KH
3D QD 4C 6H TS AC 3S 5C 2H KD
4C AS JS 9S 7C TS 7H 9H JC KS
4H 8C JD 3H 6H AD 9S 4S 5S KS
4C 2C 7D 3D AS 9C 2S QS KC 6C
8S 5H 3D 2S AC 9D 6S 3S 4D TD
QD TH 7S TS 3D AC 7H 6C 5D QC
TC QD AD 9C QS 5C 8D KD 3D 3C
9D 8H AS 3S 7C 8S JD 2D 8D KC
4C TH AC QH JS 8D 7D 7S 9C KH
9D 8D 4C JH 2C 2S QD KD TS 4H
4D 6D 5D 2D JH 3S 8S 3H TC KH
AD 4D 2C QS 8C KD JH JD AH 5C
5C 6C 5H 2H JH 4H KS 7C TC 3H
3C 4C QC 5D JH 9C QD KH 8D TC
3H 9C JS 7H QH AS 7C 9H 5H JC
2D 5S QD 4S 3C KC 6S 6C 5C 4C
5D KH 2D TS 8S 9C AS 9S 7C 4C
7C AH 8C 8D 5S KD QH QS JH 2C
8C 9D AH 2H AC QC 5S 8H 7H 2C
QD 9H 5S QS QC 9C 5H JC TH 4H
6C 6S 3H 5H 3S 6H KS 8D AC 7S
AC QH 7H 8C 4S KC 6C 3D 3S TC
9D 3D JS TH AC 5H 3H 8S 3S TC
QD KH JS KS 9S QC 8D AH 3C AC
5H 6C KH 3S 9S JH 2D QD AS 8C
6C 4D 7S 7H 5S JC 6S 9H 4H JH
AH 5S 6H 9S AD 3S TH 2H 9D 8C
4C 8D 9H 7C QC AD 4S 9C KC 5S
9D 6H 4D TC 4C JH 2S 5D 3S AS
2H 6C 7C KH 5C AD QS TH JD 8S
3S 4S 7S AH AS KC JS 2S AD TH
JS KC 2S 7D 8C 5C 9C TS 5H 9D
7S 9S 4D TD JH JS KH 6H 5D 2C
JD JS JC TH 2D 3D QD 8C AC 5H
7S KH 5S 9D 5D TD 4S 6H 3C 2D
4S 5D AC 8D 4D 7C AD AS AH 9C
6S TH TS KS 2C QC AH AS 3C 4S
2H 8C 3S JC 5C 7C 3H 3C KH JH
7S 3H JC 5S 6H 4C 2S 4D KC 7H
4D 7C 4H 9S 8S 6S AD TC 6C JC
KH QS 3S TC 4C 8H 8S AC 3C TS
QD QS TH 3C TS 7H 7D AH TD JC
TD JD QC 4D 9S 7S TS AD 7D AC
AH 7H 4S 6D 7C 2H 9D KS JC TD
7C AH JD 4H 6D QS TS 2H 2C 5C
TC KC 8C 9S 4C JS 3C JC 6S AH
AS 7D QC 3D 5S JC JD 9D TD KH
TH 3C 2S 6H AH AC 5H 5C 7S 8H
QC 2D AC QD 2S 3S JD QS 6S 8H
KC 4H 3C 9D JS 6H 3S 8S AS 8C
7H KC 7D JD 2H JC QH 5S 3H QS
9H TD 3S 8H 7S AC 5C 6C AH 7C
8D 9H AH JD TD QS 7D 3S 9C 8S
AH QH 3C JD KC 4S 5S 5D TD KS
9H 7H 6S JH TH 4C 7C AD 5C 2D
7C KD 5S TC 9D 6S 6C 5D 2S TH
KC 9H 8D 5H 7H 4H QC 3D 7C AS
6S 8S QC TD 4S 5C TH QS QD 2S
8S 5H TH QC 9H 6S KC 7D 7C 5C
7H KD AH 4D KH 5C 4S 2D KC QH
6S 2C TD JC AS 4D 6C 8C 4H 5S
JC TC JD 5S 6S 8D AS 9D AD 3S
6D 6H 5D 5S TC 3D 7D QS 9D QD
4S 6C 8S 3S 7S AD KS 2D 7D 7C
KC QH JC AC QD 5D 8D QS 7H 7D
JS AH 8S 5H 3D TD 3H 4S 6C JH
4S QS 7D AS 9H JS KS 6D TC 5C
2D 5C 6H TC 4D QH 3D 9H 8S 6C
6D 7H TC TH 5S JD 5C 9C KS KD
8D TD QH 6S 4S 6C 8S KC 5C TC
5S 3D KS AC 4S 7D QD 4C TH 2S
TS 8H 9S 6S 7S QH 3C AH 7H 8C
4C 8C TS JS QC 3D 7D 5D 7S JH
8S 7S 9D QC AC 7C 6D 2H JH KC
JS KD 3C 6S 4S 7C AH QC KS 5H
KS 6S 4H JD QS TC 8H KC 6H AS
KH 7C TC 6S TD JC 5C 7D AH 3S
3H 4C 4H TC TH 6S 7H 6D 9C QH
7D 5H 4S 8C JS 4D 3D 8S QH KC
3H 6S AD 7H 3S QC 8S 4S 7S JS
3S JD KH TH 6H QS 9C 6C 2D QD
4S QH 4D 5H KC 7D 6D 8D TH 5S
TD AD 6S 7H KD KH 9H 5S KC JC
3H QC AS TS 4S QD KS 9C 7S KC
TS 6S QC 6C TH TC 9D 5C 5D KD
JS 3S 4H KD 4C QD 6D 9S JC 9D
8S JS 6D 4H JH 6H 6S 6C KS KH
AC 7D 5D TC 9S KH 6S QD 6H AS
AS 7H 6D QH 8D TH 2S KH 5C 5H
4C 7C 3D QC TC 4S KH 8C 2D JS
6H 5D 7S 5H 9C 9H JH 8S TH 7H
AS JS 2S QD KH 8H 4S AC 8D 8S
3H 4C TD KD 8C JC 5C QS 2D JD
TS 7D 5D 6C 2C QS 2H 3C AH KS
4S 7C 9C 7D JH 6C 5C 8H 9D QD
2S TD 7S 6D 9C 9S QS KH QH 5C
JC 6S 9C QH JH 8D 7S JS KH 2H
8D 5H TH KC 4D 4S 3S 6S 3D QS
2D JD 4C TD 7C 6D TH 7S JC AH
QS 7S 4C TH 9D TS AD 4D 3H 6H
2D 3H 7D JD 3D AS 2S 9C QC 8S
4H 9H 9C 2C 7S JH KD 5C 5D 6H
TC 9H 8H JC 3C 9S 8D KS AD KC
TS 5H JD QS QH QC 8D 5D KH AH
5D AS 8S 6S 4C AH QC QD TH 7H
3H 4H 7D 6S 4S 9H AS 8H JS 9D
JD 8C 2C 9D 7D 5H 5S 9S JC KD
KD 9C 4S QD AH 7C AD 9D AC TD
6S 4H 4S 9C 8D KS TC 9D JH 7C
5S JC 5H 4S QH AC 2C JS 2S 9S
8C 5H AS QD AD 5C 7D 8S QC TD
JC 4C 8D 5C KH QS 4D 6H 2H 2C
TH 4S 2D KC 3H QD AC 7H AD 9D
KH QD AS 8H TH KC 8D 7S QH 8C
JC 6C 7D 8C KH AD QS 2H 6S 2D
JC KH 2D 7D JS QC 5H 4C 5D AD
TS 3S AD 4S TD 2D TH 6S 9H JH
9H 2D QS 2C 4S 3D KH AS AC 9D
KH 6S 8H 4S KD 7D 9D TS QD QC
JH 5H AH KS AS AD JC QC 5S KH
5D 7D 6D KS KD 3D 7C 4D JD 3S
AC JS 8D 5H 9C 3H 4H 4D TS 2C
6H KS KH 9D 7C 2S 6S 8S 2H 3D
6H AC JS 7S 3S TD 8H 3H 4H TH
9H TC QC KC 5C KS 6H 4H AC 8S
TC 7D QH 4S JC TS 6D 6C AC KH
QH 7D 7C JH QS QD TH 3H 5D KS
3D 5S 8D JS 4C 2C KS 7H 9C 4H
5H 8S 4H TD 2C 3S QD QC 3H KC
QC JS KD 9C AD 5S 9D 7D 7H TS
8C JC KH 7C 7S 6C TS 2C QD TH
5S 9D TH 3C 7S QH 8S 9C 2H 5H
5D 9H 6H 2S JS KH 3H 7C 2H 5S
JD 5D 5S 2C TC 2S 6S 6C 3C 8S
4D KH 8H 4H 2D KS 3H 5C 2S 9H
3S 2D TD 7H 8S 6H JD KC 9C 8D
6S QD JH 7C 9H 5H 8S 8H TH TD
QS 7S TD 7D TS JC KD 7C 3C 2C
3C JD 8S 4H 2D 2S TD AS 4D AC
AH KS 6C 4C 4S 7D 8C 9H 6H AS
5S 3C 9S 2C QS KD 4D 4S AC 5D
2D TS 2C JS KH QH 5D 8C AS KC
KD 3H 6C TH 8S 7S KH 6H 9S AC
6H 7S 6C QS AH 2S 2H 4H 5D 5H
5H JC QD 2C 2S JD AS QC 6S 7D
6C TC AS KD 8H 9D 2C 7D JH 9S
2H 4C 6C AH 8S TD 3H TH 7C TS
KD 4S TS 6C QH 8D 9D 9C AH 7D
6D JS 5C QD QC 9C 5D 8C 2H KD
3C QH JH AD 6S AH KC 8S 6D 6H
3D 7C 4C 7S 5S 3S 6S 5H JC 3C
QH 7C 5H 3C 3S 8C TS 4C KD 9C
QD 3S 7S 5H 7H QH JC 7C 8C KD
3C KD KH 2S 4C TS AC 6S 2C 7C
2C KH 3C 4C 6H 4D 5H 5S 7S QD
4D 7C 8S QD TS 9D KS 6H KD 3C
QS 4D TS 7S 4C 3H QD 8D 9S TC
TS QH AC 6S 3C 9H 9D QS 8S 6H
3S 7S 5D 4S JS 2D 6C QH 6S TH
4C 4H AS JS 5D 3D TS 9C AC 8S
6S 9C 7C 3S 5C QS AD AS 6H 3C
9S 8C 7H 3H 6S 7C AS 9H JD KH
3D 3H 7S 4D 6C 7C AC 2H 9C TH
4H 5S 3H AC TC TH 9C 9H 9S 8D
8D 9H 5H 4D 6C 2H QD 6S 5D 3S
4C 5C JD QS 4D 3H TH AC QH 8C
QC 5S 3C 7H AD 4C KS 4H JD 6D
QS AH 3H KS 9H 2S JS JH 5H 2H
2H 5S TH 6S TS 3S KS 3C 5H JS
2D 9S 7H 3D KC JH 6D 7D JS TD
AC JS 8H 2C 8C JH JC 2D TH 7S
5D 9S 8H 2H 3D TC AH JC KD 9C
9D QD JC 2H 6D KH TS 9S QH TH
2C 8D 4S JD 5H 3H TH TC 9C KC
AS 3D 9H 7D 4D TH KH 2H 7S 3H
4H 7S KS 2S JS TS 8S 2H QD 8D
5S 6H JH KS 8H 2S QC AC 6S 3S
JC AS AD QS 8H 6C KH 4C 4D QD
2S 3D TS TD 9S KS 6S QS 5C 8D
3C 6D 4S QC KC JH QD TH KH AD
9H AH 4D KS 2S 8D JH JC 7C QS
2D 6C TH 3C 8H QD QH 2S 3S KS
6H 5D 9S 4C TS TD JS QD 9D JD
5H 8H KH 8S KS 7C TD AD 4S KD
2C 7C JC 5S AS 6C 7D 8S 5H 9C
6S QD 9S TS KH QS 5S QH 3C KC
7D 3H 3C KD 5C AS JH 7H 6H JD
9D 5C 9H KC 8H KS 4S AD 4D 2S
3S JD QD 8D 2S 7C 5S 6S 5H TS
6D 9S KC TD 3S 6H QD JD 5C 8D
5H 9D TS KD 8D 6H TD QC 4C 7D
6D 4S JD 9D AH 9S AS TD 9H QD
2D 5S 2H 9C 6H 9S TD QC 7D TC
3S 2H KS TS 2C 9C 8S JS 9D 7D
3C KC 6D 5D 6C 6H 8S AS 7S QS
JH 9S 2H 8D 4C 8H 9H AD TH KH
QC AS 2S JS 5C 6H KD 3H 7H 2C
QD 8H 2S 8D 3S 6D AH 2C TC 5C
JD JS TS 8S 3H 5D TD KC JC 6H
6S QS TC 3H 5D AH JC 7C 7D 4H
7C 5D 8H 9C 2H 9H JH KH 5S 2C
9C 7H 6S TH 3S QC QD 4C AC JD
2H 5D 9S 7D KC 3S QS 2D AS KH
2S 4S 2H 7D 5C TD TH QH 9S 4D
6D 3S TS 6H 4H KS 9D 8H 5S 2D
9H KS 4H 3S 5C 5D KH 6H 6S JS
KC AS 8C 4C JC KH QC TH QD AH
6S KH 9S 2C 5H TC 3C 7H JC 4D
JD 4S 6S 5S 8D 7H 7S 4D 4C 2H
7H 9H 5D KH 9C 7C TS TC 7S 5H
4C 8D QC TS 4S 9H 3D AD JS 7C
8C QS 5C 5D 3H JS AH KC 4S 9D
TS JD 8S QS TH JH KH 2D QD JS
JD QC 5D 6S 9H 3S 2C 8H 9S TS
2S 4C AD 7H JC 5C 2D 6D 4H 3D
7S JS 2C 4H 8C AD QD 9C 3S TD
JD TS 4C 6H 9H 7D QD 6D 3C AS
AS 7C 4C 6S 5D 5S 5C JS QC 4S
KD 6S 9S 7C 3C 5S 7D JH QD JS
4S 7S JH 2C 8S 5D 7H 3D QH AD
TD 6H 2H 8D 4H 2D 7C AD KH 5D
TS 3S 5H 2C QD AH 2S 5C KH TD
KC 4D 8C 5D AS 6C 2H 2S 9H 7C
KD JS QC TS QS KH JH 2C 5D AD
3S 5H KC 6C 9H 3H 2H AD 7D 7S
7S JS JH KD 8S 7D 2S 9H 7C 2H
9H 2D 8D QC 6S AD AS 8H 5H 6C
2S 7H 6C 6D 7D 8C 5D 9D JC 3C
7C 9C 7H JD 2H KD 3S KH AD 4S
QH AS 9H 4D JD KS KD TS KH 5H
4C 8H 5S 3S 3D 7D TD AD 7S KC
JS 8S 5S JC 8H TH 9C 4D 5D KC
7C 5S 9C QD 2C QH JS 5H 8D KH
TD 2S KS 3D AD KC 7S TC 3C 5D
4C 2S AD QS 6C 9S QD TH QH 5C
8C AD QS 2D 2S KC JD KS 6C JC
8D 4D JS 2H 5D QD 7S 7D QH TS
6S 7H 3S 8C 8S 9D QS 8H 6C 9S
4S TC 2S 5C QD 4D QS 6D TH 6S
3S 5C 9D 6H 8D 4C 7D TC 7C TD
AH 6S AS 7H 5S KD 3H 5H AC 4C
8D 8S AH KS QS 2C AD 6H 7D 5D
6H 9H 9S 2H QS 8S 9C 5D 2D KD
TS QC 5S JH 7D 7S TH 9S 9H AC
7H 3H 6S KC 4D 6D 5C 4S QD TS
TD 2S 7C QD 3H JH 9D 4H 7S 7H
KS 3D 4H 5H TC 2S AS 2D 6D 7D
8H 3C 7H TD 3H AD KC TH 9C KH
TC 4C 2C 9S 9D 9C 5C 2H JD 3C
3H AC TS 5D AD 8D 6H QC 6S 8C
2S TS 3S JD 7H 8S QH 4C 5S 8D
AC 4S 6C 3C KH 3D 7C 2D 8S 2H
4H 6C 8S TH 2H 4S 8H 9S 3H 7S
7C 4C 9C 2C 5C AS 5D KD 4D QH
9H 4H TS AS 7D 8D 5D 9S 8C 2H
QC KD AC AD 2H 7S AS 3S 2D 9S
2H QC 8H TC 6D QD QS 5D KH 3C
TH JD QS 4C 2S 5S AD 7H 3S AS
7H JS 3D 6C 3S 6D AS 9S AC QS
9C TS AS 8C TC 8S 6H 9D 8D 6C
4D JD 9C KC 7C 6D KS 3S 8C AS
3H 6S TC 8D TS 3S KC 9S 7C AS
8C QC 4H 4S 8S 6C 3S TC AH AC
4D 7D 5C AS 2H 6S TS QC AD TC
QD QC 8S 4S TH 3D AH TS JH 4H
5C 2D 9S 2C 3H 3C 9D QD QH 7D
KC 9H 6C KD 7S 3C 4D AS TC 2D
3D JS 4D 9D KS 7D TH QC 3H 3C
8D 5S 2H 9D 3H 8C 4C 4H 3C TH
JC TH 4S 6S JD 2D 4D 6C 3D 4C
TS 3S 2D 4H AC 2C 6S 2H JH 6H
TD 8S AD TC AH AC JH 9S 6S 7S
6C KC 4S JD 8D 9H 5S 7H QH AH
KD 8D TS JH 5C 5H 3H AD AS JS
2D 4H 3D 6C 8C 7S AD 5D 5C 8S
TD 5D 7S 9C 4S 5H 6C 8C 4C 8S
JS QH 9C AS 5C QS JC 3D QC 7C
JC 9C KH JH QS QC 2C TS 3D AD
5D JH AC 5C 9S TS 4C JD 8C KS
KC AS 2D KH 9H 2C 5S 4D 3D 6H
TH AH 2D 8S JC 3D 8C QH 7S 3S
8H QD 4H JC AS KH KS 3C 9S 6D
9S QH 7D 9C 4S AC 7H KH 4D KD
AH AD TH 6D 9C 9S KD KS QH 4H
QD 6H 9C 7C QS 6D 6S 9D 5S JH
AH 8D 5H QD 2H JC KS 4H KH 5S
5C 2S JS 8D 9C 8C 3D AS KC AH
JD 9S 2H QS 8H 5S 8C TH 5C 4C
QC QS 8C 2S 2C 3S 9C 4C KS KH
2D 5D 8S AH AD TD 2C JS KS 8C
TC 5S 5H 8H QC 9H 6H JD 4H 9S
3C JH 4H 9H AH 4S 2H 4C 8D AC
8S TH 4D 7D 6D QD QS 7S TC 7C
KH 6D 2D JD 5H JS QD JH 4H 4S
9C 7S JH 4S 3S TS QC 8C TC 4H
QH 9D 4D JH QS 3S 2C 7C 6C 2D
4H 9S JD 5C 5H AH 9D TS 2D 4C
KS JH TS 5D 2D AH JS 7H AS 8D
JS AH 8C AD KS 5S 8H 2C 6C TH
2H 5D AD AC KS 3D 8H TS 6H QC
6D 4H TS 9C 5H JS JH 6S JD 4C
JH QH 4H 2C 6D 3C 5D 4C QS KC
6H 4H 6C 7H 6S 2S 8S KH QC 8C
3H 3D 5D KS 4H TD AD 3S 4D TS
5S 7C 8S 7D 2C KS 7S 6C 8C JS
5D 2H 3S 7C 5C QD 5H 6D 9C 9H
JS 2S KD 9S 8D TD TS AC 8C 9D
5H QD 2S AC 8C 9H KS 7C 4S 3C
KH AS 3H 8S 9C JS QS 4S AD 4D
AS 2S TD AD 4D 9H JC 4C 5H QS
5D 7C 4H TC 2D 6C JS 4S KC 3S
4C 2C 5D AC 9H 3D JD 8S QS QH
2C 8S 6H 3C QH 6D TC KD AC AH
QC 6C 3S QS 4S AC 8D 5C AD KH
5S 4C AC KH AS QC 2C 5C 8D 9C
8H JD 3C KH 8D 5C 9C QD QH 9D
7H TS 2C 8C 4S TD JC 9C 5H QH
JS 4S 2C 7C TH 6C AS KS 7S JD
JH 7C 9H 7H TC 5H 3D 6D 5D 4D
2C QD JH 2H 9D 5S 3D TD AD KS
JD QH 3S 4D TH 7D 6S QS KS 4H
TC KS 5S 8D 8H AD 2S 2D 4C JH
5S JH TC 3S 2D QS 9D 4C KD 9S
AC KH 3H AS 9D KC 9H QD 6C 6S
9H 7S 3D 5C 7D KC TD 8H 4H 6S
3C 7H 8H TC QD 4D 7S 6S QH 6C
6D AD 4C QD 6C 5D 7D 9D KS TS
JH 2H JD 9S 7S TS KH 8D 5D 8H
2D 9S 4C 7D 9D 5H QD 6D AC 6S
7S 6D JC QD JH 4C 6S QS 2H 7D
8C TD JH KD 2H 5C QS 2C JS 7S
TC 5H 4H JH QD 3S 5S 5D 8S KH
KS KH 7C 2C 5D JH 6S 9C 6D JC
5H AH JD 9C JS KC 2H 6H 4D 5S
AS 3C TH QC 6H 9C 8S 8C TD 7C
KC 2C QD 9C KH 4D 7S 3C TS 9H
9C QC 2S TS 8C TD 9S QD 3S 3C
4D 9D TH JH AH 6S 2S JD QH JS
QD 9H 6C KD 7D 7H 5D 6S 8H AH
8H 3C 4S 2H 5H QS QH 7S 4H AC
QS 3C 7S 9S 4H 3S AH KS 9D 7C
AD 5S 6S 2H 2D 5H TC 4S 3C 8C
QH TS 6S 4D JS KS JH AS 8S 6D
2C 8S 2S TD 5H AS TC TS 6C KC
KC TS 8H 2H 3H 7C 4C 5S TH TD
KD AD KH 7H 7S 5D 5H 5S 2D 9C
AD 9S 3D 7S 8C QC 7C 9C KD KS
3C QC 9S 8C 4D 5C AS QD 6C 2C
2H KC 8S JD 7S AC 8D 5C 2S 4D
9D QH 3D 2S TC 3S KS 3C 9H TD
KD 6S AC 2C 7H 5H 3S 6C 6H 8C
QH TC 8S 6S KH TH 4H 5D TS 4D
8C JS 4H 6H 2C 2H 7D AC QD 3D
QS KC 6S 2D 5S 4H TD 3H JH 4C
7S 5H 7H 8H KH 6H QS TH KD 7D
5H AD KD 7C KH 5S TD 6D 3C 6C
8C 9C 5H JD 7C KC KH 7H 2H 3S
7S 4H AD 4D 8S QS TH 3D 7H 5S
8D TC KS KD 9S 6D AD JD 5C 2S
7H 8H 6C QD 2H 6H 9D TC 9S 7C
8D 6D 4C 7C 6C 3C TH KH JS JH
5S 3S 8S JS 9H AS AD 8H 7S KD
JH 7C 2C KC 5H AS AD 9C 9S JS
AD AC 2C 6S QD 7C 3H TH KS KD
9D JD 4H 8H 4C KH 7S TS 8C KC
3S 5S 2H 7S 6H 7D KS 5C 6D AD
5S 8C 9H QS 7H 7S 2H 6C 7D TD
QS 5S TD AC 9D KC 3D TC 2D 4D
TD 2H 7D JD QD 4C 7H 5D KC 3D
4C 3H 8S KD QH 5S QC 9H TC 5H
9C QD TH 5H TS 5C 9H AH QH 2C
4D 6S 3C AC 6C 3D 2C 2H TD TH
AC 9C 5D QC 4D AD 8D 6D 8C KC
AD 3C 4H AC 8D 8H 7S 9S TD JC
4H 9H QH JS 2D TH TD TC KD KS
5S 6S 9S 8D TH AS KH 5H 5C 8S
JD 2S 9S 6S 5S 8S 5D 7S 7H 9D
5D 8C 4C 9D AD TS 2C 7D KD TC
8S QS 4D KC 5C 8D 4S KH JD KD
AS 5C AD QH 7D 2H 9S 7H 7C TC
2S 8S JD KH 7S 6C 6D AD 5D QC
9H 6H 3S 8C 8H AH TC 4H JS TD
2C TS 4D 7H 2D QC 9C 5D TH 7C
6C 8H QC 5D TS JH 5C 5H 9H 4S
2D QC 7H AS JS 8S 2H 4C 4H 8D
JS 6S AC KD 3D 3C 4S 7H TH KC
QH KH 6S QS 5S 4H 3C QD 3S 3H
7H AS KH 8C 4H 9C 5S 3D 6S TS
9C 7C 3H 5S QD 2C 3D AD AC 5H
JH TD 2D 4C TS 3H KH AD 3S 7S
AS 4C 5H 4D 6S KD JC 3C 6H 2D
3H 6S 8C 2D TH 4S AH QH AD 5H
7C 2S 9H 7H KC 5C 6D 5S 3H JC
3C TC 9C 4H QD TD JH 6D 9H 5S
7C 6S 5C 5D 6C 4S 7H 9H 6H AH
AD 2H 7D KC 2C 4C 2S 9S 7H 3S
TH 4C 8S 6S 3S AD KS AS JH TD
5C TD 4S 4D AD 6S 5D TC 9C 7D
8H 3S 4D 4S 5S 6H 5C AC 3H 3D
9H 3C AC 4S QS 8S 9D QH 5H 4D
JC 6C 5H TS AC 9C JD 8C 7C QD
8S 8H 9C JD 2D QC QH 6H 3C 8D
KS JS 2H 6H 5H QH QS 3H 7C 6D
TC 3H 4S 7H QC 2H 3S 8C JS KH
AH 8H 5S 4C 9H JD 3H 7S JC AC
3C 2D 4C 5S 6C 4S QS 3S JD 3D
5H 2D TC AH KS 6D 7H AD 8C 6H
6C 7S 3C JD 7C 8H KS KH AH 6D
AH 7D 3H 8H 8S 7H QS 5H 9D 2D
JD AC 4H 7S 8S 9S KS AS 9D QH
7S 2C 8S 5S JH QS JC AH KD 4C
AH 2S 9H 4H 8D TS TD 6H QH JD
4H JC 3H QS 6D 7S 9C 8S 9D 8D
5H TD 4S 9S 4C 8C 8D 7H 3H 3D
QS KH 3S 2C 2S 3C 7S TD 4S QD
7C TD 4D 5S KH AC AS 7H 4C 6C
2S 5H 6D JD 9H QS 8S 2C 2H TD
2S TS 6H 9H 7S 4H JC 4C 5D 5S
2C 5H 7D 4H 3S QH JC JS 6D 8H
4C QH 7C QD 3S AD TH 8S 5S TS
9H TC 2S TD JC 7D 3S 3D TH QH
7D 4C 8S 5C JH 8H 6S 3S KC 3H
JC 3H KH TC QH TH 6H 2C AC 5H
QS 2H 9D 2C AS 6S 6C 2S 8C 8S
9H 7D QC TH 4H KD QS AC 7S 3C
4D JH 6S 5S 8H KS 9S QC 3S AS
JD 2D 6S 7S TC 9H KC 3H 7D KD
2H KH 7C 4D 4S 3H JS QD 7D KC
4C JC AS 9D 3C JS 6C 8H QD 4D
AH JS 3S 6C 4C 3D JH 6D 9C 9H
9H 2D 8C 7H 5S KS 6H 9C 2S TC
6C 8C AD 7H 6H 3D KH AS 5D TH
KS 8C 3S TS 8S 4D 5S 9S 6C 4H
9H 4S 4H 5C 7D KC 2D 2H 9D JH
5C JS TC 9D 9H 5H 7S KH JC 6S
7C 9H 8H 4D JC KH JD 2H TD TC
8H 6C 2H 2C KH 6H 9D QS QH 5H
AC 7D 2S 3D QD JC 2D 8D JD JH
2H JC 2D 7H 2C 3C 8D KD TD 4H
3S 4H 6D 8D TS 3H TD 3D 6H TH
JH JC 3S AC QH 9H 7H 8S QC 2C
7H TD QS 4S 8S 9C 2S 5D 4D 2H
3D TS 3H 2S QC 8H 6H KC JC KS
5D JD 7D TC 8C 6C 9S 3D 8D AC
8H 6H JH 6C 5D 8D 8S 4H AD 2C
9D 4H 2D 2C 3S TS AS TC 3C 5D
4D TH 5H KS QS 6C 4S 2H 3D AD
5C KC 6H 2C 5S 3C 4D 2D 9H 9S
JD 4C 3H TH QH 9H 5S AH 8S AC
7D 9S 6S 2H TD 9C 4H 8H QS 4C
3C 6H 5D 4H 8C 9C KC 6S QD QS
3S 9H KD TC 2D JS 8C 6S 4H 4S
2S 4C 8S QS 6H KH 3H TH 8C 5D
2C KH 5S 3S 7S 7H 6C 9D QD 8D
8H KS AC 2D KH TS 6C JS KC 7H
9C KS 5C TD QC AH 6C 5H 9S 7C
5D 4D 3H 4H 6S 7C 7S AH QD TD
2H 7D QC 6S TC TS AH 7S 9D 3H
TH 5H QD 9S KS 7S 7C 6H 8C TD
TH 2D 4D QC 5C 7D JD AH 9C 4H
4H 3H AH 8D 6H QC QH 9H 2H 2C
2D AD 4C TS 6H 7S TH 4H QS TD
3C KD 2H 3H QS JD TC QC 5D 8H
KS JC QD TH 9S KD 8D 8C 2D 9C
3C QD KD 6D 4D 8D AH AD QC 8S
8H 3S 9D 2S 3H KS 6H 4C 7C KC
TH 9S 5C 3D 7D 6H AC 7S 4D 2C
5C 3D JD 4D 2D 6D 5H 9H 4C KH
AS 7H TD 6C 2H 3D QD KS 4C 4S
JC 3C AC 7C JD JS 8H 9S QC 5D
JD 6S 5S 2H AS 8C 7D 5H JH 3D
8D TC 5S 9S 8S 3H JC 5H 7S AS
5C TD 3D 7D 4H 8D 7H 4D 5D JS
QS 9C KS TD 2S 8S 5C 2H 4H AS
TH 7S 4H 7D 3H JD KD 5D 2S KC
JD 7H 4S 8H 4C JS 6H QH 5S 4H
2C QS 8C 5S 3H QC 2S 6C QD AD
8C 3D JD TC 4H 2H AD 5S AC 2S
5D 2C JS 2D AD 9D 3D 4C 4S JH
8D 5H 5D 6H 7S 4D KS 9D TD JD
3D 6D 9C 2S AS 7D 5S 5C 8H JD
7C 8S 3S 6S 5H JD TC AD 7H 7S
2S 9D TS 4D AC 8D 6C QD JD 3H
9S KH 2C 3C AC 3D 5H 6H 8D 5D
KS 3D 2D 6S AS 4C 2S 7C 7H KH
AC 2H 3S JC 5C QH 4D 2D 5H 7S
TS AS JD 8C 6H JC 8S 5S 2C 5D
7S QH 7H 6C QC 8H 2D 7C JD 2S
2C QD 2S 2H JC 9C 5D 2D JD JH
7C 5C 9C 8S 7D 6D 8D 6C 9S JH
2C AD 6S 5H 3S KS 7S 9D KH 4C
7H 6C 2C 5C TH 9D 8D 3S QC AH
5S KC 6H TC 5H 8S TH 6D 3C AH
9C KD 4H AD TD 9S 4S 7D 6H 5D
7H 5C 5H 6D AS 4C KD KH 4H 9D
3C 2S 5C 6C JD QS 2H 9D 7D 3H
AC 2S 6S 7S JS QD 5C QS 6H AD
5H TH QC 7H TC 3S 7C 6D KC 3D
4H 3D QC 9S 8H 2C 3S JC KS 5C
4S 6S 2C 6H 8S 3S 3D 9H 3H JS
4S 8C 4D 2D 8H 9H 7D 9D AH TS
9S 2C 9H 4C 8D AS 7D 3D 6D 5S
6S 4C 7H 8C 3H 5H JC AH 9D 9C
2S 7C 5S JD 8C 3S 3D 4D 7D 6S
3C KC 4S 5D 7D 3D JD 7H 3H 4H
9C 9H 4H 4D TH 6D QD 8S 9S 7S
2H AC 8S 4S AD 8C 2C AH 7D TC
TS 9H 3C AD KS TC 3D 8C 8H JD
QC 8D 2C 3C 7D 7C JD 9H 9C 6C
AH 6S JS JH 5D AS QC 2C JD TD
9H KD 2H 5D 2D 3S 7D TC AH TS
TD 8H AS 5D AH QC AC 6S TC 5H
KS 4S 7H 4D 8D 9C TC 2H 6H 3H
3H KD 4S QD QH 3D 8H 8C TD 7S
8S JD TC AH JS QS 2D KH KS 4D
3C AD JC KD JS KH 4S TH 9H 2C
QC 5S JS 9S KS AS 7C QD 2S JD
KC 5S QS 3S 2D AC 5D 9H 8H KS
6H 9C TC AD 2C 6D 5S JD 6C 7C
QS KH TD QD 2C 3H 8S 2S QC AH
9D 9H JH TC QH 3C 2S JS 5C 7H
6C 3S 3D 2S 4S QD 2D TH 5D 2C
2D 6H 6D 2S JC QH AS 7H 4H KH
5H 6S KS AD TC TS 7C AC 4S 4H
AD 3C 4H QS 8C 9D KS 2H 2D 4D
4S 9D 6C 6D 9C AC 8D 3H 7H KD
JC AH 6C TS JD 6D AD 3S 5D QD
JC JH JD 3S 7S 8S JS QC 3H 4S
JD TH 5C 2C AD JS 7H 9S 2H 7S
8D 3S JH 4D QC AS JD 2C KC 6H
2C AC 5H KD 5S 7H QD JH AH 2D
JC QH 8D 8S TC 5H 5C AH 8C 6C
3H JS 8S QD JH 3C 4H 6D 5C 3S
6D 4S 4C AH 5H 5S 3H JD 7C 8D
8H AH 2H 3H JS 3C 7D QC 4H KD
6S 2H KD 5H 8H 2D 3C 8S 7S QD
2S 7S KC QC AH TC QS 6D 4C 8D
5S 9H 2C 3S QD 7S 6C 2H 7C 9D
3C 6C 5C 5S JD JC KS 3S 5D TS
7C KS 6S 5S 2S 2D TC 2H 5H QS
AS 7H 6S TS 5H 9S 9D 3C KD 2H
4S JS QS 3S 4H 7C 2S AC 6S 9D
8C JH 2H 5H 7C 5D QH QS KH QC
3S TD 3H 7C KC 8D 5H 8S KH 8C
4H KH JD TS 3C 7H AS QC JS 5S
AH 9D 2C 8D 4D 2D 6H 6C KC 6S
2S 6H 9D 3S 7H 4D KH 8H KD 3D
9C TC AC JH KH 4D JD 5H TD 3S
7S 4H 9D AS 4C 7D QS 9S 2S KH
3S 8D 8S KS 8C JC 5C KH 2H 5D
8S QH 2C 4D KC JS QC 9D AC 6H
8S 8C 7C JS JD 6S 4C 9C AC 4S
QH 5D 2C 7D JC 8S 2D JS JH 4C
JS 4C 7S TS JH KC KH 5H QD 4S
QD 8C 8D 2D 6S TD 9D AC QH 5S
QH QC JS 3D 3C 5C 4H KH 8S 7H
7C 2C 5S JC 8S 3H QC 5D 2H KC
5S 8D KD 6H 4H QD QH 6D AH 3D
7S KS 6C 2S 4D AC QS 5H TS JD
7C 2D TC 5D QS AC JS QC 6C KC
2C KS 4D 3H TS 8S AD 4H 7S 9S
QD 9H QH 5H 4H 4D KH 3S JC AD
4D AC KC 8D 6D 4C 2D KH 2C JD
2C 9H 2D AH 3H 6D 9C 7D TC KS
8C 3H KD 7C 5C 2S 4S 5H AS AH
TH JD 4H KD 3H TC 5C 3S AC KH
6D 7H AH 7S QC 6H 2D TD JD AS
JH 5D 7H TC 9S 7D JC AS 5S KH
2H 8C AD TH 6H QD KD 9H 6S 6C
QH KC 9D 4D 3S JS JH 4H 2C 9H
TC 7H KH 4H JC 7D 9S 3H QS 7S
AD 7D JH 6C 7H 4H 3S 3H 4D QH
JD 2H 5C AS 6C QC 4D 3C TC JH
AC JD 3H 6H 4C JC AD 7D 7H 9H
4H TC TS 2C 8C 6S KS 2H JD 9S
4C 3H QS QC 9S 9H 6D KC 9D 9C
5C AD 8C 2C QH TH QD JC 8D 8H
QC 2C 2S QD 9C 4D 3S 8D JH QS
9D 3S 2C 7S 7C JC TD 3C TC 9H
3C TS 8H 5C 4C 2C 6S 8D 7C 4H
KS 7H 2H TC 4H 2C 3S AS AH QS
8C 2D 2H 2C 4S 4C 6S 7D 5S 3S
TH QC 5D TD 3C QS KD KC KS AS
4D AH KD 9H KS 5C 4C 6H JC 7S
KC 4H 5C QS TC 2H JC 9S AH QH
4S 9H 3H 5H 3C QD 2H QC JH 8H
5D AS 7H 2C 3D JH 6H 4C 6S 7D
9C JD 9H AH JS 8S QH 3H KS 8H
3S AC QC TS 4D AD 3D AH 8S 9H
7H 3H QS 9C 9S 5H JH JS AH AC
8D 3C JD 2H AC 9C 7H 5S 4D 8H
7C JH 9H 6C JS 9S 7H 8C 9D 4H
2D AS 9S 6H 4D JS JH 9H AD QD
6H 7S JH KH AH 7H TD 5S 6S 2C
8H JH 6S 5H 5S 9D TC 4C QC 9S
7D 2C KD 3H 5H AS QD 7H JS 4D
TS QH 6C 8H TH 5H 3C 3H 9C 9D
AD KH JS 5D 3H AS AC 9S 5C KC
2C KH 8C JC QS 6D AH 2D KC TC
9D 3H 2S 7C 4D 6D KH KS 8D 7D
9H 2S TC JH AC QC 3H 5S 3S 8H
3S AS KD 8H 4C 3H 7C JH QH TS
7S 6D 7H 9D JH 4C 3D 3S 6C AS
4S 2H 2C 4C 8S 5H KC 8C QC QD
3H 3S 6C QS QC 2D 6S 5D 2C 9D
2H 8D JH 2S 3H 2D 6C 5C 7S AD
9H JS 5D QH 8S TS 2H 7S 6S AD
6D QC 9S 7H 5H 5C 7D KC JD 4H
QC 5S 9H 9C 4D 6S KS 2S 4C 7C
9H 7C 4H 8D 3S 6H 5C 8H JS 7S
2D 6H JS TD 4H 4D JC TH 5H KC
AC 7C 8D TH 3H 9S 2D 4C KC 4D
KD QS 9C 7S 3D KS AD TS 4C 4H
QH 9C 8H 2S 7D KS 7H 5D KD 4C
9C 2S 2H JC 6S 6C TC QC JH 5C
7S AC 8H KC 8S 6H QS JC 3D 6S
JS 2D JH 8C 4S 6H 8H 6D 5D AD
6H 7D 2S 4H 9H 7C AS AC 8H 5S
3C JS 4S 6D 5H 2S QH 6S 9C 2C
3D 5S 6S 9S 4C QS 8D QD 8S TC
9C 3D AH 9H 5S 2C 7D AD JC 3S
7H TC AS 3C 6S 6D 7S KH KC 9H
3S TC 8H 6S 5H JH 8C 7D AC 2S
QD 9D 9C 3S JC 8C KS 8H 5D 4D
JS AH JD 6D 9D 8C 9H 9S 8H 3H
2D 6S 4C 4D 8S AD 4S TC AH 9H
TS AC QC TH KC 6D 4H 7S 8C 2H
3C QD JS 9D 5S JC AH 2H TS 9H
3H 4D QH 5D 9C 5H 7D 4S JC 3S
8S TH 3H 7C 2H JD JS TS AC 8D
9C 2H TD KC JD 2S 8C 5S AD 2C
3D KD 7C 5H 4D QH QD TC 6H 7D
7H 2C KC 5S KD 6H AH QC 7S QH
6H 5C AC 5H 2C 9C 2D 7C TD 2S
4D 9D AH 3D 7C JD 4H 8C 4C KS
TH 3C JS QH 8H 4C AS 3D QS QC
4D 7S 5H JH 6D 7D 6H JS KH 3C
QD 8S 7D 2H 2C 7C JC 2S 5H 8C
QH 8S 9D TC 2H AD 7C 8D QD 6S
3S 7C AD 9H 2H 9S JD TS 4C 2D
3S AS 4H QC 2C 8H 8S 7S TD TC
JH TH TD 3S 4D 4H 5S 5D QS 2C
8C QD QH TC 6D 4S 9S 9D 4H QC
8C JS 9D 6H JD 3H AD 6S TD QC
KC 8S 3D 7C TD 7D 8D 9H 4S 3S
6C 4S 3D 9D KD TC KC KS AC 5S
7C 6S QH 3D JS KD 6H 6D 2D 8C
JD 2S 5S 4H 8S AC 2D 6S TS 5C
5H 8C 5S 3C 4S 3D 7C 8D AS 3H
AS TS 7C 3H AD 7D JC QS 6C 6H
3S 9S 4C AC QH 5H 5D 9H TS 4H
6C 5C 7H 7S TD AD JD 5S 2H 2S
7D 6C KC 3S JD 8D 8S TS QS KH
8S QS 8D 6C TH AC AH 2C 8H 9S
7H TD KH QH 8S 3D 4D AH JD AS
TS 3D 2H JC 2S JH KH 6C QC JS
KC TH 2D 6H 7S 2S TC 8C 9D QS
3C 9D 6S KH 8H 6D 5D TH 2C 2H
6H TC 7D AD 4D 8S TS 9H TD 7S
JS 6D JD JC 2H AC 6C 3D KH 8D
KH JD 9S 5D 4H 4C 3H 7S QS 5C
4H JD 5D 3S 3C 4D KH QH QS 7S
JD TS 8S QD AH 4C 6H 3S 5S 2C
QS 3D JD AS 8D TH 7C 6S QC KS
7S 2H 8C QC 7H AC 6D 2D TH KH
5S 6C 7H KH 7D AH 8C 5C 7S 3D
3C KD AD 7D 6C 4D KS 2D 8C 4S
7C 8D 5S 2D 2S AH AD 2C 9D TD
3C AD 4S KS JH 7C 5C 8C 9C TH
AS TD 4D 7C JD 8C QH 3C 5H 9S
3H 9C 8S 9S 6S QD KS AH 5H JH
QC 9C 5S 4H 2H TD 7D AS 8C 9D
8C 2C 9D KD TC 7S 3D KH QC 3C
4D AS 4C QS 5S 9D 6S JD QH KS
6D AH 6C 4C 5H TS 9H 7D 3D 5S
QS JD 7C 8D 9C AC 3S 6S 6C KH
8H JH 5D 9S 6D AS 6S 3S QC 7H
QD AD 5C JH 2H AH 4H AS KC 2C
JH 9C 2C 6H 2D JS 5D 9H KC 6D
7D 9D KD TH 3H AS 6S QC 6H AD
JD 4H 7D KC 3H JS 3C TH 3D QS
4C 3H 8C QD 5H 6H AS 8H AD JD
TH 8S KD 5D QC 7D JS 5S 5H TS
7D KC 9D QS 3H 3C 6D TS 7S AH
7C 4H 7H AH QC AC 4D 5D 6D TH
3C 4H 2S KD 8H 5H JH TC 6C JD
4S 8C 3D 4H JS TD 7S JH QS KD
7C QC KD 4D 7H 6S AD TD TC KH
5H 9H KC 3H 4D 3D AD 6S QD 6H
TH 7C 6H TS QH 5S 2C KC TD 6S
7C 4D 5S JD JH 7D AC KD KH 4H
7D 6C 8D 8H 5C JH 8S QD TH JD
8D 7D 6C 7C 9D KD AS 5C QH JH
9S 2C 8C 3C 4C KS JH 2D 8D 4H
7S 6C JH KH 8H 3H 9D 2D AH 6D
4D TC 9C 8D 7H TD KS TH KD 3C
JD 9H 8D QD AS KD 9D 2C 2S 9C
8D 3H 5C 7H KS 5H QH 2D 8C 9H
2D TH 6D QD 6C KC 3H 3S AD 4C
4H 3H JS 9D 3C TC 5H QH QC JC
3D 5C 6H 3S 3C JC 5S 7S 2S QH
AC 5C 8C 4D 5D 4H 2S QD 3C 3H
2C TD AH 9C KD JS 6S QD 4C QC
QS 8C 3S 4H TC JS 3H 7C JC AD
5H 4D 9C KS JC TD 9S TS 8S 9H
QD TS 7D AS AC 2C TD 6H 8H AH
6S AD 8C 4S 9H 8D 9D KH 8S 3C
QS 4D 2D 7S KH JS JC AD 4C 3C
QS 9S 7H KC TD TH 5H JS AC JH
6D AC 2S QS 7C AS KS 6S KH 5S
6D 8H KH 3C QS 2H 5C 9C 9D 6C
JS 2C 4C 6H 7D JC AC QD TD 3H
4H QC 8H JD 4C KD KS 5C KC 7S
6D 2D 3H 2S QD 5S 7H AS TH 6S
AS 6D 8D 2C 8S TD 8H QD JC AH
9C 9H 2D TD QH 2H 5C TC 3D 8H
KC 8S 3D KH 2S TS TC 6S 4D JH
9H 9D QS AC KC 6H 5D 4D 8D AH
9S 5C QS 4H 7C 7D 2H 8S AD JS
3D AC 9S AS 2C 2D 2H 3H JC KH
7H QH KH JD TC KS 5S 8H 4C 8D
2H 7H 3S 2S 5H QS 3C AS 9H KD
AD 3D JD 6H 5S 9C 6D AC 9S 3S
3D 5D 9C 2D AC 4S 2S AD 6C 6S
QC 4C 2D 3H 6S KC QH QD 2H JH
QC 3C 8S 4D 9S 2H 5C 8H QS QD
6D KD 6S 7H 3S KH 2H 5C JC 6C
3S 9S TC 6S 8H 2D AD 7S 8S TS
3C 6H 9C 3H 5C JC 8H QH TD QD
3C JS QD 5D TD 2C KH 9H TH AS
9S TC JD 3D 5C 5H AD QH 9H KC
TC 7H 4H 8H 3H TD 6S AC 7C 2S
QS 9D 5D 3C JC KS 4D 6C JH 2S
9S 6S 3C 7H TS 4C KD 6D 3D 9C
2D 9H AH AC 7H 2S JH 3S 7C QC
QD 9H 3C 2H AC AS 8S KD 8C KH
2D 7S TD TH 6D JD 8D 4D 2H 5S
8S QH KD JD QS JH 4D KC 5H 3S
3C KH QC 6D 8H 3S AH 7D TD 2D
5S 9H QH 4S 6S 6C 6D TS TH 7S
6C 4C 6D QS JS 9C TS 3H 8D 8S
JS 5C 7S AS 2C AH 2H AD 5S TC
KD 6C 9C 9D TS 2S JC 4H 2C QD
QS 9H TC 3H KC KS 4H 3C AD TH
KH 9C 2H KD 9D TC 7S KC JH 2D
7C 3S KC AS 8C 5D 9C 9S QH 3H
2D 8C TD 4C 2H QC 5D TC 2C 7D
KS 4D 6C QH TD KH 5D 7C AD 8D
2S 9S 8S 4C 8C 3D 6H QD 7C 7H
6C 8S QH 5H TS 5C 3C 4S 2S 2H
8S 6S 2H JC 3S 3H 9D 8C 2S 7H
QC 2C 8H 9C AC JD 4C 4H 6S 3S
3H 3S 7D 4C 9S 5H 8H JC 3D TC
QH 2S 2D 9S KD QD 9H AD 6D 9C
8D 2D KS 9S JC 4C JD KC 4S TH
KH TS 6D 4D 5C KD 5H AS 9H AD
QD JS 7C 6D 5D 5C TH 5H QH QS
9D QH KH 5H JH 4C 4D TC TH 6C
KH AS TS 9D KD 9C 7S 4D 8H 5S
KH AS 2S 7D 9D 4C TS TH AH 7C
KS 4D AC 8S 9S 8D TH QH 9D 5C
5D 5C 8C QS TC 4C 3D 3S 2C 8D
9D KS 2D 3C KC 4S 8C KH 6C JC
8H AH 6H 7D 7S QD 3C 4C 6C KC
3H 2C QH 8H AS 7D 4C 8C 4H KC
QD 5S 4H 2C TD AH JH QH 4C 8S
3H QS 5S JS 8H 2S 9H 9C 3S 2C
6H TS 7S JC QD AC TD KC 5S 3H
QH AS QS 7D JC KC 2C 4C 5C 5S
QH 3D AS JS 4H 8D 7H JC 2S 9C
5D 4D 2S 4S 9D 9C 2D QS 8H 7H
6D 7H 3H JS TS AC 2D JH 7C 8S
JH 5H KC 3C TC 5S 9H 4C 8H 9D
8S KC 5H 9H AD KS 9D KH 8D AH
JC 2H 9H KS 6S 3H QC 5H AH 9C
5C KH 5S AD 6C JC 9H QC 9C TD
5S 5D JC QH 2D KS 8H QS 2H TS
JH 5H 5S AH 7H 3C 8S AS TD KH
6H 3D JD 2C 4C KC 7S AH 6C JH
4C KS 9D AD 7S KC 7D 8H 3S 9C
7H 5C 5H 3C 8H QC 3D KH 6D JC
2D 4H 5D 7D QC AD AH 9H QH 8H
KD 8C JS 9D 3S 3C 2H 5D 6D 2S
8S 6S TS 3C 6H 8D 5S 3H TD 6C
KS 3D JH 9C 7C 9S QS 5S 4H 6H
7S 6S TH 4S KC KD 3S JC JH KS
7C 3C 2S 6D QH 2C 7S 5H 8H AH
KC 8D QD 6D KH 5C 7H 9D 3D 9C
6H 2D 8S JS 9S 2S 6D KC 7C TC
KD 9C JH 7H KC 8S 2S 7S 3D 6H
4H 9H 2D 4C 8H 7H 5S 8S 2H 8D
AD 7C 3C 7S 5S 4D 9H 3D JC KH
5D AS 7D 6D 9C JC 4C QH QS KH
KD JD 7D 3D QS QC 8S 6D JS QD
6S 8C 5S QH TH 9H AS AC 2C JD
QC KS QH 7S 3C 4C 5C KC 5D AH
6C 4H 9D AH 2C 3H KD 3D TS 5C
TD 8S QS AS JS 3H KD AC 4H KS
7D 5D TS 9H 4H 4C 9C 2H 8C QC
2C 7D 9H 4D KS 4C QH AD KD JS
QD AD AH KH 9D JS 9H JC KD JD
8S 3C 4S TS 7S 4D 5C 2S 6H 7C
JS 7S 5C KD 6D QH 8S TD 2H 6S
QH 6C TC 6H TD 4C 9D 2H QC 8H
3D TS 4D 2H 6H 6S 2C 7H 8S 6C
9H 9D JD JH 3S AH 2C 6S 3H 8S
2C QS 8C 5S 3H 2S 7D 3C AD 4S
5C QC QH AS TS 4S 6S 4C 5H JS
JH 5C TD 4C 6H JS KD KH QS 4H
TC KH JC 4D 9H 9D 8D KC 3C 8H
2H TC 8S AD 9S 4H TS 7H 2C 5C
4H 2S 6C 5S KS AH 9C 7C 8H KD
TS QH TD QS 3C JH AH 2C 8D 7D
5D KC 3H 5S AC 4S 7H QS 4C 2H
3D 7D QC KH JH 6D 6C TD TH KD
5S 8D TH 6C 9D 7D KH 8C 9S 6D
JD QS 7S QC 2S QH JC 4S KS 8D
7S 5S 9S JD KD 9C JC AD 2D 7C
4S 5H AH JH 9C 5D TD 7C 2D 6S
KC 6C 7H 6S 9C QD 5S 4H KS TD
6S 8D KS 2D TH TD 9H JD TS 3S
KH JS 4H 5D 9D TC TD QC JD TS
QS QD AC AD 4C 6S 2D AS 3H KC
4C 7C 3C TD QS 9C KC AS 8D AD
KC 7H QC 6D 8H 6S 5S AH 7S 8C
3S AD 9H JC 6D JD AS KH 6S JH
AD 3D TS KS 7H JH 2D JS QD AC
9C JD 7C 6D TC 6H 6C JC 3D 3S
QC KC 3S JC KD 2C 8D AH QS TS
AS KD 3D JD 8H 7C 8C 5C QD 6C
#+end_src

#+begin_src odin :main no :comments link :tangle src/poker_hands.odin
package poker_hands

import "core:os"
import "core:fmt"
import "core:slice"
import "core:strconv"
import "core:strings"

Suit :: enum {
	Hearts,   // hearts
	Clubs,    // clubs
	Spades,   // spades
	Diamonds, // diamonds
}

Card :: struct {
	value: int,
	suit: Suit,
}

value_to_card_str :: proc(value: int) -> string {
	switch value {
	case 2: return "Two"
	case 3: return "Three"
	case 4: return "Four"
	case 5: return "Five"
	case 6: return "Six"
	case 7: return "Seven"
	case 8: return "Eight"
	case 9: return "Nine"
	case 10: return "Ten"
	case 11: return "Jack"
	case 12: return "Queen"
	case 13: return "King"
	case 14: return "Ace"
	}
	return "unknown card value"
}

get_cards :: proc(hand: string) -> (cards: [5]Card) {
	for i in 0..<5 {
		v := rune(hand[i*3 + 0])
		s := rune(hand[i*3 + 1])
		if v >= '2' && v <= '9' {
			cards[i].value = int(v-'0')
		} else if v == 'T' {
			cards[i].value = 10
		} else if v == 'J' {
			cards[i].value = 11
		} else if v == 'Q' {
			cards[i].value = 12
		} else if v == 'K' {
			cards[i].value = 13
		} else if v == 'A' {
			cards[i].value = 14
		}
		if s == 'H' {
			cards[i].suit = .Hearts
		} else if s == 'C' {
			cards[i].suit = .Clubs
		} else if s == 'S' {
			cards[i].suit = .Spades
		} else if s == 'D' {
			cards[i].suit = .Diamonds
		}
	}
	return
}

rank_cards :: proc(cards: [5]Card) -> (string, [2]int) {
	value_cnts : [15]int
	high_card : int = 0
	rank := ""
	rank_scores := [2]int{0,0} // high card is 0
	for i in 0..<5 {
		value_cnts[cards[i].value] += 1
		if cards[i].value > high_card {
			high_card = cards[i].value
		}
	}

	has_pair := [2]int{0,0}
	has_tri  := 0
	for i in 0..<15 {
		val := 14-i
		if value_cnts[val] >= 2 {
			rank = fmt.tprintf("Pair of %ss", value_to_card_str(val))
			rank_scores[0] = 1 // one pair is 1
			if has_pair[0] > 0 {
				has_pair[1] = val
			} else {
				has_pair[0] = val
			}
			if value_cnts[val] >= 3 {
				rank = fmt.tprintf("Three %ss", value_to_card_str(val))
				rank_scores[0] = 3 // three of a kind
				if has_pair[0] == val {
					has_pair[0] = 0 // this pair is now a tri
				}
				has_tri = val
				if value_cnts[val] >= 4 {
					rank = fmt.tprintf("Four of a Kind %ss", value_to_card_str(val))
					rank_scores[0] = 7 // four of a kind
				}
			}
			if high_card == val { // make this not high card anymore
				high_card = 0
				for i in 0..<5 {
					if cards[i].value > high_card && cards[i].value != val &&
						cards[i].value != has_pair[0] && cards[i].value != has_pair[1] {
						high_card = cards[i].value
					}
				}
			}
			rank = fmt.tprintf("%s Highest card %s", rank, value_to_card_str(high_card))
			if has_tri > 0 {
				rank_scores[1] = has_tri<<4 + high_card
			} else if has_pair[0] > 0 {
				rank_scores[1] = has_pair[0]<<4 + high_card
			} else {
				rank_scores[1] = high_card
			}
		}
	}

	if has_tri > 0 && has_pair[0] > 0 {
		// full house - triple is most important to rank
		rank = fmt.tprintf("Full House With %s and %s", value_to_card_str(has_tri), value_to_card_str(has_pair[0]))
		rank_scores[0] = 6 // full house
		rank_scores[1] = has_tri<<4 + high_card
	}	else if has_pair[0] > 0 && has_pair[1] > 0 {
		if has_pair[0] < has_pair[1] {
			has_pair[0], has_pair[1] = has_pair[1], has_pair[0] // swap
		}
		rank = fmt.tprintf("Two Pair %s and %s with kicker %s", value_to_card_str(has_pair[0]), value_to_card_str(has_pair[1]), value_to_card_str(high_card))
		rank_scores[0] = 2 // two pair
		rank_scores[1] = has_pair[0]<<8 + has_pair[1]<<4 + high_card
	}
	
	is_flush := true
	suit := cards[0].suit
	for i in 1..<5 {
		if cards[i].suit != suit {
			is_flush = false
			break
		}
	}
	if is_flush {
		rank = fmt.tprintf("Flush with %s Highest card %s", suit, value_to_card_str(high_card))
		rank_scores[0] = 5 // flush
		rank_scores[1] = high_card
	}

	is_straight := true
	values : [5]int
	for i in 0..<5 {
		values[i] = cards[i].value
	}
	slice.sort(values[:])
	curr := values[0]
	for i in 1..<5 {
		if i == 4 && values[i] == 14 { // ace at end
			if values[0] != 2 {
				is_straight = false
				break
			}
		} else if values[i] != curr + 1 {
			is_straight = false
			break
		}
		curr = values[i]
	}
	if is_straight {
		rank = fmt.tprintf("Straight Highest card %s", value_to_card_str(high_card))
		rank_scores[0] = 4 // straight
		rank_scores[1] = high_card
	}

	if is_flush && is_straight {
		rank = fmt.tprintf("Straight Flush Highest card %s", value_to_card_str(high_card))
		rank_scores[0] = 8 // straight flush
		rank_scores[1] = high_card
		if high_card == 14 {
			rank = fmt.tprintf("Royal Flush")
			rank_scores[0] = 9 // royal flush
			rank_scores[1] = 0 // these alway tie?
		}
	}
	
	if rank == "" {
		rank = fmt.tprintf("Highest card %s", value_to_card_str(high_card))
		rank_scores[0] = 0 // lowest rank
		rank_scores[1] = high_card
	}

	return rank, rank_scores
}

main :: proc() {
	//hands := []string{"5H 5C 6S 7S KD",
	//                  "2C 3S 8S 8D TD",
	//                  "5D 8C 9S JS AC",
	//                  "2C 5C 7D 8S QH",
	//                  "2D 9C AS AH AC",
	//                  "3D 6D 7D TD QD",
	//                  "4D 6S 9H QH QC",
	//                  "3D 6D 7H QD QS",
	//                  "2H 2D 4C 4D 4S",
	//                  "3C 3D 3S 9S 9D",
	//                 }
  //
	//for h in hands {
	//	cards_1 := get_cards(h)
	//	fmt.println(cards_1)
	//	fmt.println(rank_cards(cards_1))
	//}

	data, ok := os.read_entire_file("poker.txt")
	player_1_wins : int = 0
	player_2_wins : int = 0
	if ok {
		lines := strings.split(string(data), "\n")
		for l,idx in lines {
			if len(l) < 15 {
				fmt.println("bad line", l)
			} else {
				hand_1 := l[0:3*5]
				hand_2 := l[3*5:]
				cards_1 := get_cards(hand_1)
				cards_2 := get_cards(hand_2)
				rank_1, rank_score_1 := rank_cards(cards_1)
				rank_2, rank_score_2 := rank_cards(cards_2)
				if rank_score_1[0] > rank_score_2[0] {
					player_1_wins += 1
				} else {
					if rank_score_1[0] == rank_score_2[0] {
						if rank_score_1[1] == rank_score_2[1] {
							fmt.println("DERP! tie?", hand_1, hand_2) // needs more ranking!
						}
						if rank_score_1[1] > rank_score_2[1] {
							player_1_wins += 1
						} else {
							player_2_wins += 1
						}
					}
				}
			}
		}
		fmt.println(player_1_wins, player_2_wins)
	} else {
		fmt.println("poker.txt not found!")
	}
}
#+end_src
* Prob 055 - Lychrel Numbers
If we take $47$, reverse and add, $47 + 74 = 121$, which is palindromic.
Not all numbers produce palindromes so quickly. For example,

\begin{align}
349 + 943 = 1292\\
1292 + 2921 = 4213\\
4213 + 3124 = 7337
\end{align}

That is, $349$ took three iterations to arrive at a palindrome.
Although no one has proved it yet, it is thought that some numbers, like $196$,
never produce a palindrome. A number that never forms a palindrome through the
reverse and add process is called a Lychrel number. Due to the theoretical
nature of these numbers, and for the purpose of this problem, we shall assume
that a number is Lychrel until proven otherwise. In addition you are given that
for every number below ten-thousand, it will either (i) become a palindrome in
less than fifty iterations, or, (ii) no one, with all the computing power that
exists, has managed so far to map it to a palindrome. In fact, $10677$ is the
first number to be shown to require over fifty iterations before producing a
palindrome: $4668731596684224866951378664$ ($53$ iterations, 28-digits).

Surprisingly, there are palindromic numbers that are themselves Lychrel numbers;
the first example is $4994$.

How many Lychrel numbers are there below ten-thousand?

NOTE: Wording was modified slightly on 24 April 2007 to emphasise the
theoretical nature of Lychrel numbers.

#+begin_src odin :main no :comments link :tangle src/lychrel_numbers.odin
package lychrel_numbers

import "core:fmt"
import "core:strings"
import "core:strconv"
import "../util"

reverse_and_add :: proc(num: f64) -> f64 {
	buf: [32]byte
	str_tmp := strconv.append_float(buf[:], num, 'f', 32, 64)
	dot := strings.index(str_tmp, ".")
	str := str_tmp[1:dot]
	rev, err := strings.reverse(str)

	if err == .None {
		num2, ok := strconv.parse_f64(rev)
		if !ok {
			fmt.println("parse reverse error", str, rev)
			return -2
		}
		tmp := num + num2
		if tmp < 0 {
			fmt.println("overflow!")
		}
		return tmp
	}
	return -1
}

main :: proc() {
	cnt := 0
	for i in 1..<10_000 {
		ii := f64(i)

		iterations := 1
		for ; iterations < 50; iterations += 1 {
			num := reverse_and_add(ii)
			if (util.is_palindrome(num)) {
				//fmt.println(i, "is palindrome in", iterations, "iterations")
				break
			}
			ii = num
		}
		if iterations >= 50 {
			fmt.println(i, "is lychrel")
			cnt += 1
		}
	}
	fmt.println("cnt", cnt)
}
#+end_src

* Prob 056 - Powerful Digit Sum
A googol ($10^{100}$) is a massive number: one followed by one-hundred zeros;
$100^{100}$ is almost unimaginably large: one followed by two-hundred zeros.
Despite their size, the sum of the digits in each number is only $1$.

Considering natural numbers of the form, $a^b$, where $a, b < 100$, what is the
maximum digital sum?

$a^b = c$  ..  $log_a(c) = b$  ..  $\sqrt[b]{c}=a$
$2^3 = 8$  ..  $log_2(8) = 3$  ..  $\sqrt[3]{8}=2$

modulo 9 gives similar result to adding digits
or more simply put:
 11111 is 5 ones so mod 9 is 5

identities:
1. (a + b) mod n = [(a mod n) + (b mod n)] mod n.
2. ab mod n = [(a mod n)(b mod n)] mod n.
3. a^b mod n = [(a mod n)^b] mod n.

consider b^e mod m...
one way to calc this is with:
b = 4, e = 13, and m = 497 is presented again. The algorithm performs the iteration thirteen times:

(e' =  1)   c = (4 * 1) mod 497 = 4 mod 497 = 4
(e' =  2)   c = (4 * 4) mod 497 = 16 mod 497 = 16
(e' =  3)   c = (4 * 16) mod 497 = 64 mod 497 = 64
(e' =  4)   c = (4 * 64) mod 497 = 256 mod 497 = 256
(e' =  5)   c = (4 * 256) mod 497 = 1024 mod 497 = 30
(e' =  6)   c = (4 * 30) mod 497 = 120 mod 497 = 120
(e' =  7)   c = (4 * 120) mod 497 = 480 mod 497 = 480
(e' =  8)   c = (4 * 480) mod 497 = 1920 mod 497 = 429
(e' =  9)   c = (4 * 429) mod 497 = 1716 mod 497 = 225
(e' = 10)   c = (4 * 225) mod 497 = 900 mod 497 = 403
(e' = 11)   c = (4 * 403) mod 497 = 1612 mod 497 = 121
(e' = 12)   c = (4 * 121) mod 497 = 484 mod 497 = 484
(e' = 13)   c = (4 * 484) mod 497 = 1936 mod 497 = 445

if we use mod 9 then
4^13; this comes out to 67,108,864

6 + 7 + 1 + 0 + 8 + 8 + 6 + 4 = 40
4 + 0 = 4
mod 9 is 4 ofcourse

another way:
b = 4,  e = 13  and m = 9

e' = 1   c = (4 * 1) mod 9 = 4
e' = 2   c = (4 * 4) mod 9 = 7
e' = 3   c = (4 * 7) mod 9 = 1
e' = 4   c = (4 * 1) mod 9 = 4
e' = 5   c = (4 * 4) mod 9 = 7
e' = 6   c = (4 * 7) mod 9 = 1
e' = 7   c = (4 * 1) mod 9 = 4
e' = 8   c = (4 * 4) mod 9 = 7
e' = 9   c = (4 * 7) mod 9 = 1
e' = 10  c = (4 * 1) mod 9 = 4
e' = 11  c = (4 * 4) mod 9 = 7
e' = 12  c = (4 * 7) mod 9 = 1
e' = 13  c = (4 * 1) mod 9 = 4 <- ans
40 .. is not 4

note:
The length of a number n in base b is the number of digits in the base-b numeral for n, given by the formula

 L(n,b)=|_log_b(n)_|+1, 
where |_x_| is the floor function.
or
 L(a^b,c) = |_log_c(a^b)_| + 1 = |_b * log_c(a)_| + 1
see next prob for counting digits in a bignum

#+begin_src odin :main no :comments link :tangle src/powerful_digit_sum.odin
package powerful_digit_sum

import "core:fmt"
import "core:math"
import "core:math/big"
import "core:strings"
import "core:strconv"

cnt_digits_int :: proc(str: string) -> int {
	acc := 0
	for c in str {
		acc += strconv._digit_value(c)
	}
	return acc
}

cnt_digits_big :: proc(n: ^big.Int) -> int {
	acc := 0
	denom := new(big.Int); defer free(denom)
	rem := new(big.Int); defer free(rem)
	quot := new(big.Int); defer free(quot)
	zero := new(big.Int); defer free(zero)

	big.set(quot, n)
	big.set(denom, 10)
	big.set(zero, 0)
	
	gtz := true
	tmp : i64
	err : big.Error = .Okay

	for ; gtz && err == .Okay; {
		big.int_mod(rem, quot, denom)
		tmp, err = big.int_get_i64(rem)
		
		if err == .Okay {
			acc += int(tmp)
			big.int_div(quot, quot, denom)
			gtz, err = big.greater_than(quot, zero)
		}
	}
	return acc
}

cnt_digits :: proc{cnt_digits_int, cnt_digits_big}

main :: proc() {
	maxi := 0
	aa := 0
	bb := 0
	for a in 91..<100 {
		for b in 91..<100 {
			//c := math.pow_f64(f64(a), f64(b))
      //
			//buf: [32]byte
			//str_tmp := strconv.append_float(buf[:], c, 'f', 32, 64)
			//dot := strings.index(str_tmp, ".")
			//str := str_tmp[1:dot]
      //
			//fmt.println(str, cnt_digits(str), "a", a, "b", b)
      //
			//// another way without calc'ing the power, but is wrong!
			//r_acc := 0
			//r_c := 1
			//for e in 0..<b {
			//	r_c = (a * r_c) % 9 // this ends up being a^b mod 9.. but what is digit_sum?
			//	r_acc += r_c
			//}
			//fmt.println(str, r_acc-b+1)

			// just use bignums =( really wish there was a nifty trick
			// at least this shows using bignums
			dest := new(big.Int)
			base := new(big.Int)
			big.int_set_from_integer(base, a)
			big.pow(dest, base, b)
			tmp := cnt_digits(dest)
			if tmp > maxi {
				maxi = tmp
				aa = a
				bb = b
			}
		}
	}
	fmt.println("maxi", maxi, aa, bb)
}
#+end_src

#+RESULTS:
: maxi 972 99 95

* Prob 057 - Square Root Convergents
It is possible to show that the square root of two can be expressed as an infinite continued fraction.
$\sqrt 2 =1+ \frac 1 {2+ \frac 1 {2 +\frac 1 {2+ \dots}}}$
By expanding this for the first four iterations, we get:
$1 + \frac 1 2 = \frac  32 = 1.5$
$1 + \frac 1 {2 + \frac 1 2} = \frac 7 5 = 1.4$
$1 + \frac 1 {2 + \frac 1 {2+\frac 1 2}} = \frac {17}{12} = 1.41666 \dots$
$1 + \frac 1 {2 + \frac 1 {2+\frac 1 {2+\frac 1 2}}} = \frac {41}{29} = 1.41379
\dots$

2/2 + 1/2 = 3/2
4/2 + 1/2 = 5/2 .. 1/(5/2) = 2/5 .. 5/5 + 2/5 = 7/5
4/2 + 1/2 = 5/2 .. 10/5 + 2/5 = 12/5 .. 12/12 + 5/12 = 17/12
.. idea here is to calc 4/2 + 1/2 = 5/2 then invert to 2/5 and add 2 then invert
then add 2 then invert.. until the end when we just add 1 instead of 2

The next three expansions are $\frac {99}{70}$, $\frac {239}{169}$, and $\frac
{577}{408}$, but the eighth expansion, $\frac {1393}{985}$, is the first example
where the number of digits in the numerator exceeds the number of digits in the
denominator.

In the first one-thousand expansions, how many fractions contain a numerator
with more digits than the denominator?

#+begin_src odin :main no :comments link :tangle src/square_root_convergents.odin
package square_root_convergents

import "core:fmt"
import "core:math/big"


// L(n,b)=|_log_b(n)_|+1,
number_of_digits :: proc(num: ^big.Int) -> int {
	// assumes base 10
	base := new(big.Int); defer free(base)
	big.set(base, 10)
	ret, err := big.log(num, base.digit[0])
	return ret
}

square_root_two_as_fraction :: proc(expansion_level: int, nom: ^big.Int, denom: ^big.Int) {
	el := expansion_level
	big.set(nom, 3) // first exansion_level 0
	big.set(denom, 2)
	for i in 1..=el {
		if i == 1 {
			big.set(nom, 5)
			big.set(denom, 2)
		}
		big.swap(nom, denom)
		if i != el { // add 2*
			tmp := new(big.Int); defer free(tmp)
			big.mul(tmp, denom, 2)
			big.add(nom, nom, tmp)
		} else { // add 1*
			big.add(nom, nom, denom)
		}
	}
	return
}

main :: proc() {
	cnt := 0
	nom := new(big.Int)
	denom := new(big.Int)

	//big.set(nom, 1010)
	//fmt.println(number_of_digits(nom) + 1)

	for i in 0..<1000 {
		square_root_two_as_fraction(i, nom, denom)
		digit_cnt_nom   := number_of_digits(nom)
		digit_cnt_denom := number_of_digits(denom)
		if digit_cnt_nom > digit_cnt_denom {
			cnt += 1
		}
	}
	fmt.println(cnt)
}
#+end_src

* Prob 058 - Spiral Primes
Starting with $1$ and spiralling anticlockwise in the following way, a square
spiral with side length $7$ is formed.

37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26
43 44 45 46 47 48 49

It is interesting to note that the odd squares lie along the bottom right
diagonal, but what is more interesting is that $8$ out of the $13$ numbers lying
along both diagonals are prime; that is, a ratio of $8/13 \approx 62\%$.

If one complete new layer is wrapped around the spiral above, a square spiral
with side length $9$ will be formed. If this process is continued, what is the
side length of the square spiral for which the ratio of primes along both
diagonals first falls below $10\%$?

#+begin_src odin :main no :comments link :tangle src/spiral_primes.odin
package spiral_primes

import "core:fmt"
import "core:mem"
import "core:strings"
import "vendor:raylib"
import "../util"

MENU_RECT :: raylib.Rectangle{250, 10, 240, 150}

Values :: struct {
	show_menu : bool,
	width     : int,
	height    : int,
	side_n : int,
	diag_primes : int,
}

draw_menu :: proc(values: ^Values) {
  using raylib

  menu_rect := MENU_RECT
  menu_rect.x = f32(values.width) - menu_rect.x
  if !values.show_menu {
    values.show_menu = GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")
  } else {
    panel := GuiPanel(menu_rect, "")
    values.show_menu = !GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")

	  tmp_siden := f32(values.side_n)
    GuiSlider(Rectangle{f32(values.width) - 185, 40, 160, 20}, "side len", "", &tmp_siden, 0, 100)
	  values.side_n = int(tmp_siden)
    str := fmt.tprintf("%v", values.side_n)
    cstr := strings.clone_to_cstring(str)
    GuiTextBox(Rectangle{f32(values.width) - 185, 40, 160, 20}, cstr, 10, false)
	  delete(cstr)

	  n := values.side_n
	  str = fmt.tprintf("%v == %v / %v", f32(values.diag_primes) / f32(4*n+1), f32(values.diag_primes), f32(4*n+1))
    cstr = strings.clone_to_cstring(str)
	  GuiLabel(Rectangle{f32(values.width) - 185, 65, 160, 20}, cstr)
	  delete(cstr)
  }
}

draw_square_prime_spiral :: proc(values: ^Values) {
	n := values.side_n
	curr_side_length := 0
	side_length := 0
	font_size := 10
	dir_xy := [2]int{1,0}
	x := 0
	y := 0
	maxi := (2*n+1) * (2*n+1) // odd squares
	tmp_diag_primes := 0
	// draw a 1 in the center then spiral out
	for i := 1; i <= maxi; i += 1{
		num := strings.clone_to_cstring(fmt.tprintf("%d", i)); defer delete(num)
		raylib.DrawText(num, i32(values.width/2+x*20), i32(values.height/2+y*20), i32(font_size), raylib.BLACK)
		// goto next gridcell
		x += dir_xy.x
		y += dir_xy.y
		side_length += 1
		
		if side_length > curr_side_length {
			if dir_xy.x == 1 { // manage spiral directions
				dir_xy = [2]int{0,-1}
			} else if dir_xy.y == -1 {
				dir_xy = [2]int{-1,0}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
				curr_side_length += 1
			} else if dir_xy.x == -1 {
				dir_xy = [2]int{0,1}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
			} else {
				dir_xy = [2]int{1,0}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
				curr_side_length += 1
			}
			side_length = 0
		}
	}
	values.diag_primes = tmp_diag_primes
}

count_diag_primes :: proc(side_n: int) -> int {
	n := side_n
	curr_side_length := 0
	side_length := 0
	dir_xy := [2]int{1,0}
	maxi := (2*n+1) * (2*n+1) // odd squares
	tmp_diag_primes := 0

	for i := 1; i <= maxi; i += 1{
		side_length += 1
		if side_length > curr_side_length {
			if dir_xy.x == 1 { // manage spiral directions
				dir_xy = [2]int{0,-1}
			} else if dir_xy.y == -1 {
				dir_xy = [2]int{-1,0}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
				curr_side_length += 1
			} else if dir_xy.x == -1 {
				dir_xy = [2]int{0,1}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
			} else {
				dir_xy = [2]int{1,0}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
				curr_side_length += 1
			}
			side_length = 0
		}
	}
	return tmp_diag_primes
}

main :: proc() {
	using raylib

	ta := mem.Tracking_Allocator{};
	mem.tracking_allocator_init(&ta, context.allocator);
	context.allocator = mem.tracking_allocator(&ta);

	values : Values
	values.width = 500
	values.height = 500
	values.side_n = 2
	values.diag_primes = 0

	InitWindow(i32(values.width), i32(values.height), "Window_Title")
	SetTargetFPS(60)

	// actually solve the problem here
	percentage : f64 = 1.0
	for i := 13120; percentage > 0.10; i += 1 { // just guessed a big idx 'til i got close
		side_length := 2*i + 1
		pn := f64(count_diag_primes(i))
		pd := f64(4*(i)+1)
		percentage = pn / pd
		fmt.println( side_length, percentage, pn, pd)
	}
	// ------------------------------

	for !WindowShouldClose() {
		// Update ------------------------------

		// Draw   ------------------------------
		BeginDrawing()
		ClearBackground(BLUE)
		draw_square_prime_spiral(&values)
		draw_menu(&values)
		EndDrawing()
	}
	CloseWindow()

	if len(ta.allocation_map) > 0 {
		for _, v in ta.allocation_map {
			fmt.printf("Leaked %v bytes @ %v\n", v.size, v.location);
		}
	}
	if len(ta.bad_free_array) > 0 {
		fmt.println("Bad frees:");
		for v in ta.bad_free_array {
			fmt.println(v);
		}
	}
}
#+end_src

* Prob 059 - XOR Decryption
Each character on a computer is assigned a unique code and the preferred
standard is ASCII (American Standard Code for Information Interchange). For
example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.

A modern encryption method is to take a text file, convert the bytes to ASCII,
then XOR each byte with a given value, taken from a secret key. The advantage
with the XOR function is that using the same encryption key on the cipher text,
restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.

For unbreakable encryption, the key is the same length as the plain text
message, and the key is made up of random bytes. The user would keep the
encrypted message and the encryption key in different locations, and without
both "halves", it is impossible to decrypt the message.

Unfortunately, this method is impractical for most users, so the modified method
is to use a password as a key. If the password is shorter than the message,
which is likely, the key is repeated cyclically throughout the message. The
balance for this method is using a sufficiently long password key for security,
but short enough to be memorable.

Your task has been made easy, as the encryption key consists of three lower case
characters. Using 0059_cipher.txt (right click and 'Save Link/Target As...'), a
file containing the encrypted ASCII codes, and the knowledge that the plain text
must contain common English words, decrypt the message and find the sum of the
ASCII values in the original text.

#+begin_src text :tangle src/0059_ciper.txt
36,22,80,0,0,4,23,25,19,17,88,4,4,19,21,11,88,22,23,23,29,69,12,24,0,88,25,11,12,2,10,28,5,6,12,25,10,22,80,10,30,80,10,22,21,69,23,22,69,61,5,9,29,2,66,11,80,8,23,3,17,88,19,0,20,21,7,10,17,17,29,20,69,8,17,21,29,2,22,84,80,71,60,21,69,11,5,8,21,25,22,88,3,0,10,25,0,10,5,8,88,2,0,27,25,21,10,31,6,25,2,16,21,82,69,35,63,11,88,4,13,29,80,22,13,29,22,88,31,3,88,3,0,10,25,0,11,80,10,30,80,23,29,19,12,8,2,10,27,17,9,11,45,95,88,57,69,16,17,19,29,80,23,29,19,0,22,4,9,1,80,3,23,5,11,28,92,69,9,5,12,12,21,69,13,30,0,0,0,0,27,4,0,28,28,28,84,80,4,22,80,0,20,21,2,25,30,17,88,21,29,8,2,0,11,3,12,23,30,69,30,31,23,88,4,13,29,80,0,22,4,12,10,21,69,11,5,8,88,31,3,88,4,13,17,3,69,11,21,23,17,21,22,88,65,69,83,80,84,87,68,69,83,80,84,87,73,69,83,80,84,87,65,83,88,91,69,29,4,6,86,92,69,15,24,12,27,24,69,28,21,21,29,30,1,11,80,10,22,80,17,16,21,69,9,5,4,28,2,4,12,5,23,29,80,10,30,80,17,16,21,69,27,25,23,27,28,0,84,80,22,23,80,17,16,17,17,88,25,3,88,4,13,29,80,17,10,5,0,88,3,16,21,80,10,30,80,17,16,25,22,88,3,0,10,25,0,11,80,12,11,80,10,26,4,4,17,30,0,28,92,69,30,2,10,21,80,12,12,80,4,12,80,10,22,19,0,88,4,13,29,80,20,13,17,1,10,17,17,13,2,0,88,31,3,88,4,13,29,80,6,17,2,6,20,21,69,30,31,9,20,31,18,11,94,69,54,17,8,29,28,28,84,80,44,88,24,4,14,21,69,30,31,16,22,20,69,12,24,4,12,80,17,16,21,69,11,5,8,88,31,3,88,4,13,17,3,69,11,21,23,17,21,22,88,25,22,88,17,69,11,25,29,12,24,69,8,17,23,12,80,10,30,80,17,16,21,69,11,1,16,25,2,0,88,31,3,88,4,13,29,80,21,29,2,12,21,21,17,29,2,69,23,22,69,12,24,0,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,67,80,10,10,80,7,1,80,21,13,4,17,17,30,2,88,4,13,29,80,22,13,29,69,23,22,69,12,24,12,11,80,22,29,2,12,29,3,69,29,1,16,25,28,69,12,31,69,11,92,69,17,4,69,16,17,22,88,4,13,29,80,23,25,4,12,23,80,22,9,2,17,80,70,76,88,29,16,20,4,12,8,28,12,29,20,69,26,9,69,11,80,17,23,80,84,88,31,3,88,4,13,29,80,21,29,2,12,21,21,17,29,2,69,12,31,69,12,24,0,88,20,12,25,29,0,12,21,23,86,80,44,88,7,12,20,28,69,11,31,10,22,80,22,16,31,18,88,4,13,25,4,69,12,24,0,88,3,16,21,80,10,30,80,17,16,25,22,88,3,0,10,25,0,11,80,17,23,80,7,29,80,4,8,0,23,23,8,12,21,17,17,29,28,28,88,65,75,78,68,81,65,67,81,72,70,83,64,68,87,74,70,81,75,70,81,67,80,4,22,20,69,30,2,10,21,80,8,13,28,17,17,0,9,1,25,11,31,80,17,16,25,22,88,30,16,21,18,0,10,80,7,1,80,22,17,8,73,88,17,11,28,80,17,16,21,11,88,4,4,19,25,11,31,80,17,16,21,69,11,1,16,25,2,0,88,2,10,23,4,73,88,4,13,29,80,11,13,29,7,29,2,69,75,94,84,76,65,80,65,66,83,77,67,80,64,73,82,65,67,87,75,72,69,17,3,69,17,30,1,29,21,1,88,0,23,23,20,16,27,21,1,84,80,18,16,25,6,16,80,0,0,0,23,29,3,22,29,3,69,12,24,0,88,0,0,10,25,8,29,4,0,10,80,10,30,80,4,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,86,80,35,23,28,9,23,7,12,22,23,69,25,23,4,17,30,69,12,24,0,88,3,4,21,21,69,11,4,0,8,3,69,26,9,69,15,24,12,27,24,69,49,80,13,25,20,69,25,2,23,17,6,0,28,80,4,12,80,17,16,25,22,88,3,16,21,92,69,49,80,13,25,6,0,88,20,12,11,19,10,14,21,23,29,20,69,12,24,4,12,80,17,16,21,69,11,5,8,88,31,3,88,4,13,29,80,22,29,2,12,29,3,69,73,80,78,88,65,74,73,70,69,83,80,84,87,72,84,88,91,69,73,95,87,77,70,69,83,80,84,87,70,87,77,80,78,88,21,17,27,94,69,25,28,22,23,80,1,29,0,0,22,20,22,88,31,11,88,4,13,29,80,20,13,17,1,10,17,17,13,2,0,88,31,3,88,4,13,29,80,6,17,2,6,20,21,75,88,62,4,21,21,9,1,92,69,12,24,0,88,3,16,21,80,10,30,80,17,16,25,22,88,29,16,20,4,12,8,28,12,29,20,69,26,9,69,65,64,69,31,25,19,29,3,69,12,24,0,88,18,12,9,5,4,28,2,4,12,21,69,80,22,10,13,2,17,16,80,21,23,7,0,10,89,69,23,22,69,12,24,0,88,19,12,10,19,16,21,22,0,10,21,11,27,21,69,23,22,69,12,24,0,88,0,0,10,25,8,29,4,0,10,80,10,30,80,4,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,86,80,36,22,20,69,26,9,69,11,25,8,17,28,4,10,80,23,29,17,22,23,30,12,22,23,69,49,80,13,25,6,0,88,28,12,19,21,18,17,3,0,88,18,0,29,30,69,25,18,9,29,80,17,23,80,1,29,4,0,10,29,12,22,21,69,12,24,0,88,3,16,21,3,69,23,22,69,12,24,0,88,3,16,26,3,0,9,5,0,22,4,69,11,21,23,17,21,22,88,25,11,88,7,13,17,19,13,88,4,13,29,80,0,0,0,10,22,21,11,12,3,69,25,2,0,88,21,19,29,30,69,22,5,8,26,21,23,11,94
#+end_src

#+begin_src odin :main no :comments link :tangle src/xor_decryption.odin
package xor_decryption

import "core:os"
import "core:fmt"
import "core:mem"
import "core:strings"
import "core:strconv"
import "vendor:raylib"

MENU_RECT :: raylib.Rectangle{250, 10, 240, 150}

Values :: struct {
	show_menu         : bool,
	width             : int,
	height            : int,
	abc               : int `3317`, // index into aaa-zzz
	abcs              : [3]u8 `exp`,
	percent_printable : f32 `.98`,
	accum_ascii       : uint,
}

set_abcs :: proc(values: ^Values) {
	tmp := values.abc
	// values.abc to base 26
	ch_arr := []rune{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}
	rem  : int
	quot : int = 1
	str := ""
	for ; quot != 0; {
		rem  = tmp % 26
		quot = tmp / 26
		tmp = quot
		str = fmt.tprintf("%s%c", str, ch_arr[rem])
	}
	for ; len(str) < 3; {
		str = fmt.tprintf("%s%c", str, 'a')
	}
	str2 := strings.reverse(str); defer delete(str2)
	values.abcs[0] = str2[0]
	values.abcs[1] = str2[1]
	values.abcs[2] = str2[2]
}

draw_menu :: proc(values: ^Values) {
  using raylib

  menu_rect := MENU_RECT
  menu_rect.x = f32(values.width) - menu_rect.x
  if !values.show_menu {
    values.show_menu = GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")
  } else {
    panel := GuiPanel(menu_rect, "")
    values.show_menu = !GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")

	  tmp_abc := f32(values.abc)
    GuiSlider(Rectangle{f32(values.width) - 185, 40, 160, 20}, "abc key", "", &tmp_abc, 0, 17575)
	  values.abc = int(tmp_abc)
    str := fmt.tprintf("%v", values.abc)
    cstr := strings.clone_to_cstring(str)
    GuiTextBox(Rectangle{f32(values.width) - 185, 40, 160, 20}, cstr, 10, false)
	  delete(cstr)

    GuiSlider(Rectangle{f32(values.width) - 185, 65, 160, 20}, "printable %", "", &values.percent_printable, 0, 1)
    str = fmt.tprintf("%v", values.percent_printable)
    cstr = strings.clone_to_cstring(str)
    GuiTextBox(Rectangle{f32(values.width) - 185, 65, 160, 20}, cstr, 10, false)
	  delete(cstr)
	  
	  set_abcs(values)
	  str2 := fmt.tprintf("%c%c%c", values.abcs[0], values.abcs[1], values.abcs[2])
    cstr = strings.clone_to_cstring(str2)
	  GuiLabel(Rectangle{f32(values.width) - 185, 90, 160, 20}, cstr)
	  delete(cstr)

	  str2 = fmt.tprintf("accum_ascii %v", values.accum_ascii)
    cstr = strings.clone_to_cstring(str2)
	  GuiLabel(Rectangle{f32(values.width) - 185, 115, 160, 20}, cstr)
	  delete(cstr)
  }
}

draw_cypher_text :: proc(values: ^Values, txt: []u8) {
	using raylib

	text_1 := make([]u8, len(txt)); defer delete(text_1)

	values.accum_ascii = 0
	for c,i in txt {
		text_1[i] = c ~ u8(values.abcs[i % 3])
		values.accum_ascii += uint(text_1[i])
	}
	
	text := strings.string_from_ptr(&text_1[0], len(text_1))
	lines, err := strings.split(text, "\n")
	y := 0
	text_2 : cstring
	for l in lines {
		ll := l
		tmp := int(values.width/10)
		for ; len(ll) > tmp; {
			lc := ll[0:tmp]
			ll = ll[tmp:]

			text_2 = strings.clone_to_cstring(lc)
			DrawTextEx(GetFontDefault(), text_2, Vector2{0,f32(y)}, 10, 1, BLACK)
			delete(text_2)
			y += 10
		}
		text_2 = strings.clone_to_cstring(ll)
		DrawTextEx(GetFontDefault(), text_2, Vector2{0,f32(y)}, 10, 1, BLACK)
		delete(text_2)
	}
	delete(lines)
}

find_probable_abc :: proc(values: ^Values, txt: []u8, up_down: int) {
	text_1 := make([]u8, len(txt)+1); defer delete(text_1)
	text_1[len(txt)] = 0

	cnt := 0
	cnt_tries := 0

	for ; values.percent_printable > (f32(cnt) / f32(len(txt))) && cnt_tries < 1000; {
		values.abc += up_down
		if values.abc < 0 do values.abc = 0
		set_abcs(values)
		cnt = 0
		
		for c,i in txt {
			text_1[i] = c ~ u8(values.abcs[i % 3])
			if text_1[i] == ' ' || text_1[i] == '.' ||
				text_1[i] == ',' || text_1[i] == '?' ||
				text_1[i] == '!' || text_1[i] == ';' ||
				text_1[i] == '-' || text_1[i] == '(' ||
				text_1[i] == ')' || text_1[i] == '\'' ||
				(text_1[i] >= '0' && text_1[i] <= '9') ||
				(text_1[i] >= 'a' && text_1[i] <= 'z') ||
				(text_1[i] >= 'A' && text_1[i] <= 'Z') {
				cnt += 1
			}
		}
		cnt_tries += 1
		fmt.println(f32(cnt) / f32(len(txt)))
	}
}

main :: proc() {
	using raylib

	ta := mem.Tracking_Allocator{};
	mem.tracking_allocator_init(&ta, context.allocator);
	context.allocator = mem.tracking_allocator(&ta);

	{
		values : Values
		values.width = 500
		values.height = 500
		values.abc = 3317
		values.percent_printable = 0.98
		set_abcs(&values)

		cypher_text_csv, ok := os.read_entire_file("0059_ciper.txt"); defer delete(cypher_text_csv)
		if !ok {
			fmt.println("no 0059_ciper.txt file!")
			return
		}
		// convert cvs into into string
		clines, err := strings.split(string(cypher_text_csv), ",")
		cypher_text := make([]u8, len(clines)); defer delete(cypher_text)

		for cl,idx in clines {
			c, ok := strconv.parse_int(cl)
			cypher_text[idx] = u8(c)
		}
		delete(clines)		

		SetWindowState(ConfigFlags{ConfigFlag.WINDOW_RESIZABLE})
		InitWindow(i32(values.width), i32(values.height), "Window_Title")
		SetTargetFPS(60)

		for !WindowShouldClose() {
			// Update ------------------------------
			values.width = int(GetScreenWidth())
			values.height = int(GetScreenHeight())

			if IsKeyPressed(KeyboardKey.LEFT) {
				find_probable_abc(&values, cypher_text, -1)
			} else if IsKeyPressed(KeyboardKey.RIGHT) {
				find_probable_abc(&values, cypher_text, 1)
			}

			// Draw   ------------------------------
			BeginDrawing()
			ClearBackground(BLUE)
			
			draw_cypher_text(&values, cypher_text)
			
			draw_menu(&values)
			EndDrawing()
		}
		CloseWindow()
	}

	if len(ta.allocation_map) > 0 {
		for _, v in ta.allocation_map {
			fmt.printf("Leaked %v bytes @ %v\n", v.size, v.location);
		}
	}
	if len(ta.bad_free_array) > 0 {
		fmt.println("Bad frees:");
		for v in ta.bad_free_array {
			fmt.println(v);
		}
	}
}
#+end_src

* Prob 060 - Prime Pair Sets
The primes $3$, $7$, $109$, and $673$, are quite remarkable. By taking any two
primes and concatenating them in any order the result will always be prime. For
example, taking $7$ and $109$, both $7109$ and $1097$ are prime. The sum of
these four primes, $792$, represents the lowest sum for a set of four primes
with this property.

Find the lowest sum for a set of five primes for which any two primes
concatenate to produce another prime.

#+begin_src odin :main no :comments link :tangle src/prime_pair_sets.odin
package prime_pair_sets

import "core:fmt"
import "core:strconv"
import "../util"

get_new_choose_four :: proc(new_prime: int) -> [dynamic][4]int {
	CN :: struct {
		one  : [dynamic][1]int,
		two  : [dynamic][2]int,
		thr  : [dynamic][3]int,
	}
	@static last_choose_n  : CN
	@static new_ones_added : [dynamic][4]int

	if len(last_choose_n.one) == 0 {
		append(&last_choose_n.one, [1]int{2}) // setup initial prime lists
		append(&last_choose_n.one, [1]int{3})
		append(&last_choose_n.one, [1]int{5})
		
		append(&last_choose_n.two, [2]int{2,3})
		append(&last_choose_n.two, [2]int{2,5})
		append(&last_choose_n.two, [2]int{3,5})
		
		append(&last_choose_n.thr, [3]int{2,3,5})
	}

	clear(&new_ones_added)
	for i,ii in last_choose_n.thr {
		tmp := new([4]int)
		for _,j in i {
			tmp^[j] = last_choose_n.thr[ii][j]
		}
		tmp[3] = new_prime
		append(&new_ones_added, tmp^)
	}

	// update last_choose_n lists
	for i,ii in last_choose_n.two {
		tmp := new([3]int)
		for _,j in i {
			tmp^[j] = last_choose_n.two[ii][j]
		}
		tmp[2] = new_prime
		// here the magic sauce, if some primes don't work ex: [2,3] which makes 32, don't keep them around they'll never work
		if any_two_concat_primes_is_prime(tmp[:]) {
			append(&last_choose_n.thr, tmp^)
		}
	}
	for i,ii in last_choose_n.one {
		tmp := new([2]int)
		for _,j in i {
			tmp^[j] = last_choose_n.one[ii][j]
		}
		tmp[1] = new_prime
		if any_two_concat_primes_is_prime(tmp[:]) {
			append(&last_choose_n.two, tmp^)
		}
	}
	append(&last_choose_n.one, [1]int{new_prime})
	
	return new_ones_added
}

get_new_choose_five :: proc(new_prime: int) -> [dynamic][5]int {
	CN :: struct {
		one  : [dynamic][1]int,
		two  : [dynamic][2]int,
		thr  : [dynamic][3]int,
		four : [dynamic][4]int,
	}
	@static last_choose_n  : CN
	@static new_ones_added : [dynamic][5]int

	//| n4 | [1],[2],[3],[4]     | [1,2],[1,3],[1,4],[2,3],[2,4],[3,4]                           | [1,2,3],[1,2,4],[1,3,4],[2,3,4]                                                   | [1,2,3,4]
	if len(last_choose_n.one) == 0 {
		append(&last_choose_n.one, [1]int{2}) // setup initial prime lists
		append(&last_choose_n.one, [1]int{3})
		append(&last_choose_n.one, [1]int{5})
		append(&last_choose_n.one, [1]int{7})
		
		append(&last_choose_n.two, [2]int{2,3})
		append(&last_choose_n.two, [2]int{2,5})
		append(&last_choose_n.two, [2]int{2,7})
		append(&last_choose_n.two, [2]int{3,5})
		append(&last_choose_n.two, [2]int{3,7})
		append(&last_choose_n.two, [2]int{5,7})
		
		append(&last_choose_n.thr, [3]int{2,3,5})
		append(&last_choose_n.thr, [3]int{2,3,7})
		append(&last_choose_n.thr, [3]int{2,5,7})
		append(&last_choose_n.thr, [3]int{3,5,7})

		append(&last_choose_n.four, [4]int{2,3,5,7})
	}

	clear(&new_ones_added)
	for i,ii in last_choose_n.four {
		tmp := new([5]int)
		for _,j in i {
			tmp^[j] = last_choose_n.four[ii][j]
		}
		tmp[4] = new_prime
		append(&new_ones_added, tmp^)
	}

	// update last_choose_n lists
	for i,ii in last_choose_n.thr {
		tmp := new([4]int)
		for _,j in i {
			tmp^[j] = last_choose_n.thr[ii][j]
		}
		tmp[3] = new_prime
		if any_two_concat_primes_is_prime(tmp[:]) {
			append(&last_choose_n.four, tmp^)
		}
	}
	for i,ii in last_choose_n.two {
		tmp := new([3]int)
		for _,j in i {
			tmp^[j] = last_choose_n.two[ii][j]
		}
		tmp[2] = new_prime
		if any_two_concat_primes_is_prime(tmp[:]) {		
			append(&last_choose_n.thr, tmp^)
		}
	}
	for i,ii in last_choose_n.one {
		tmp := new([2]int)
		for _,j in i {
			tmp^[j] = last_choose_n.one[ii][j]
		}
		tmp[1] = new_prime
		if any_two_concat_primes_is_prime(tmp[:]) {
			append(&last_choose_n.two, tmp^)
		}
	}
	append(&last_choose_n.one, [1]int{new_prime})
	
	// [1,2,3,4]                                           |             |
	// [1,2,3,4] + [1,2,3,5],[1,2,4,5],[1,3,4,5],[2,3,4,5] | [1,2,3,4,5] |
	
	return new_ones_added
}

any_two_concat_primes_is_prime :: proc(primes: []int) -> bool {
	combos : [dynamic][]int; defer delete(combos)
	util.get_combinations(primes, 2, &combos)
	for i in combos {
		pstr := fmt.tprintf("%v%v", i[0], i[1])
		p,_ := strconv.parse_int(pstr)
		if !util.is_prime(p) {
			return false
		}
		pstr = fmt.tprintf("%v%v", i[1], i[0])
		p,_ = strconv.parse_int(pstr)
		if !util.is_prime(p) {
			return false
		}
	}

	return true
}

main :: proc() {
	//mprimes := []int{3,7,109,673}
	//fmt.println("derp", any_two_concat_primes_is_prime(mprimes))

	// UGGG.. this is soooo slow, but will eventually find the 5 primes in question.. last one is 8389
	// maybe convert primes to strings before hand... TODO
	BELOW :: 10000
	for i in 9..<BELOW {
		if util.is_prime(i) {
			tmp := get_new_choose_five(i)
			for &j in tmp {
				if any_two_concat_primes_is_prime(j[:]) {
					fmt.println(j)
				}
			}
		}
	}
}
#+end_src

* Prob 061 - Cyclical Figurate Numbers
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

| Triangle   | $1, 3, 6, 10, 15, \dots$  | $P_{3,n}=n(n+1)/2$  |
| Square     | $1, 4, 9, 16, 25, \dots$  | $P_{4,n}=n^2$       |
| Pentagonal | $1, 5, 12, 22, 35, \dots$ | $P_{5,n}=n(3n-1)/2$ |
| Hexagonal  | $1, 6, 15, 28, 45, \dots$ | $P_{6,n}=n(2n-1)$   |
| Heptagonal | $1, 7, 18, 34, 55, \dots$ | $P_{7,n}=n(5n-3)/2$ |
| Octagonal  | $1, 8, 21, 40, 65, \dots$ | $P_{8,n}=n(3n-2)$   |

The ordered set of three *4*-digit numbers: $8128$, $2882$, $8281$, has three
interesting properties.

1) The set is cyclic, in that the last two digits of each number is the first
   two digits of the next number (including the last number with the first).
2) Each polygonal type: triangle ($P_{3,127}=8128$), square ($P_{4,91}=8281$), and
   pentagonal ($P_{5,44}=2882$), is represented by a different number in the set.
3) This is the only set of *4*-digit numbers with this property.

Find the sum of the only ordered set of six cyclic *4*-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.

