:org_mode_options:
#+TODO: ACTIVE | DISABLED
#+STARTUP: indent
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+STARTUP: overview
#+OPTIONS: ^:nil
:END:

* Prob 051 - Prime Digit Replacements
By replacing the 1st digit of the 2-digit number *3, it turns out that six of
the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit
number is the first example having seven primes among the ten generated numbers,
yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993.
Consequently 56003, being the first member of this family, is the smallest prime
with this property.

Find the smallest prime which, by replacing part of the number (not necessarily
adjacent digits) with the same digit, is part of an eight prime value family.

#+begin_src odin :main no :comments link :tangle src/prime_digit_replacements.odin
package prime_digit_replacements

import "core:fmt"
import "core:strings"
import "core:strconv"
import "../util"

main :: proc() {
	places : [dynamic]int; defer delete(places) // list of 1st, 2nd, etc places that we test for replacement with a digit 0-9
	
	x := 56_000 // start here
	looking_for_family_size := 8 // ex: 6 out of 9 prime value family
	largest_so_far := 0

	no_more := false
	for ; x < 1_000_000; x += 1 {
		if util.is_prime(x) {

			xstr := fmt.tprintf("%d", x)
			//fmt.printf("%d len: %d\n", x, len(xstr))

			arr := make([]int, len(xstr))           // index into digits of prime
			for i in 0..<len(xstr) {
				arr[i] = i
			}
			num_stars := 1
			for ; num_stars < len(xstr)-1; num_stars += 1 {
				places : [dynamic][]int
				util.get_combinations(arr, num_stars, &places) // all the combinations of where some number of *'s would go ie: 56**3

				// remove from places when *'s don't contain same digit number
				for j, j_idx in places {
					same_num : u8
					remove := false
					for k in 0..<len(j) {
						if k == 0 {
							same_num = xstr[j[k]] // first
						} else if same_num != xstr[j[k]] {
							remove = true
							break
						}
					}
					if remove {
						//fmt.println(x, "gets no", j)
						places[j_idx] = []int{}
					}
				}

				no_test := false
				for j in places {
					family_size := 1
					
					for star_digit in 0..=9 {
						xstr2 := strings.clone(xstr)
						x2_num := 0
						
						for k in j { // all the places where star_digit will replace a prime digit
							// note: zero (0) can't replace first digit
							if k == 0 && star_digit == 0 {
								no_test = true
								break
							}
							str_tmp := fmt.tprintf("%d", star_digit)
							raw_data(xstr2)[k] = str_tmp[0]
						}
						x2_num, _ = strconv.parse_int(xstr2)
						if x2_num != x { // don't test original prime
							//fmt.println("test", xstr2, util.is_prime(x2_num))
							if util.is_prime(x2_num) {
								family_size += 1
							}
						}
					}
					if family_size >= looking_for_family_size {
						fmt.println("YAY", x, "with", family_size, "primes and", num_stars, "star replacement", j)
						no_more = true
						break
					}
					if family_size > largest_so_far {
						largest_so_far = family_size
						fmt.println("so far", x, "with", family_size, "primes and", num_stars, "star replacement", j)
					}
				} // end for j in places
				if no_more do break
			}
			if no_more do break
		}
	}
}
#+end_src

#+RESULTS:
| so far 56003 with 3 primes and 1 star replacement [0] |    |    |
| so far 56003 with 7 primes and 2 star replacement [2  | 3] |    |
| YAY 121313 with 8 primes and 3 star replacement [0    |  2 | 4] |
* Prob 052 - Permuted Multiples
It can be seen that the number, 125874, and its double, 251748, contain exactly
the same digits, but in a different order.

Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain
the same digits.

#+begin_src odin :main no :comments link :tangle src/permuted_multiples.odin
package permuted_multiples

import "core:c"
import "core:fmt"
import "core:strconv"

get_digit_cnts :: proc(#any_int num: int) -> (ret: [10]int) {
	// returns int array 0-9 with count of those digits in the num(ber)
	//                            0 1 2 3 4 5 6 7 8 9
	// ex: 1258744 would be []int{0,1,1,0,2,1,0,1,1,0}... or two 4's etc..
	str := fmt.tprintf("%d", num)
	for _,i in str {
		val := strconv._digit_value(rune(str[i]))
		if val <= 9 && val >= 0 {
			ret[val] += 1
		}
	}
	return
}

main :: proc() {
	//fmt.println(get_digit_cnts(1258744))
	num : i32 = 1
	for ; num < c.INT32_MAX; num += 1 {
		x1 := get_digit_cnts(num)
		x2 := get_digit_cnts(2*num)
		x3 := get_digit_cnts(3*num)
		x4 := get_digit_cnts(4*num)
		x5 := get_digit_cnts(5*num)
		x6 := get_digit_cnts(6*num)
		if x1 == x2 &&
			x2 == x3 &&
			x3 == x4 &&
			x4 == x5 &&
			x5 == x6
		{
			fmt.println(num)
			break
		}
	}
}
#+end_src

#+RESULTS:
: 142857
* Prob 053 - Combinatoric Selections
There are exactly ten ways of selecting three from five, 12345:
123, 124, 125, 134, 135, 145, 234, 235, 245, and 345

In combinatorics, we use the notation, $\displaystyle \binom 5 3 = 10$.
In general, $\displaystyle \binom n r = \dfrac{n!}{r!(n-r)!}$, where r \le n, n! = n \times (n-1) \times ... \times 3 \times 2 \times 1, and 0! = 1.

It is not until n = 23, that a value exceeds one-million: $\displaystyle \binom {23} {10} = 1144066$.

How many, not necessarily distinct, values of $\displaystyle \binom n r$ for
1 \le n \le 100, are greater than one-million?

#+begin_src odin :main no :comments link :tangle src/combinatoric_selections.odin
package combinatoric_selections

import "core:fmt"
import "../util"

main :: proc() {
	//fmt.println(util.nCr(5, 3))
	//fmt.println(util.nCr(23,10))

	cnt := 0
	for n in 1..=100 {
		for r in 0..=n {
			tmp := util.nCr(n, r)
			if tmp > 1_000_000 || tmp == -1 {
				cnt += 1
			}
		}
	}
	fmt.println(cnt)
}
#+end_src

#+RESULTS:
: 4075

* Prob 054 - Poker Hands
Problem 54
In the card game poker, a hand consists of five cards and are ranked, from
lowest to highest, in the following way:

1. High Card: Highest value card.
2. One Pair: Two cards of the same value.
3. Two Pairs: Two different pairs.
4. Three of a Kind: Three cards of the same value.
5. Straight: All cards are consecutive values.
6. Flush: All cards of the same suit.
7. Full House: Three of a kind and a pair.
8. Four of a Kind: Four cards of the same value.
9. Straight Flush: All cards are consecutive values of same suit.
10. Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.

The cards are valued in the order:
2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.

If two players have the same ranked hands then the rank made up of the highest
value wins; for example, a pair of eights beats a pair of fives (see example 1
below). But if two ranks tie, for example, both players have a pair of queens,
then highest cards in each hand are compared (see example 4 below); if the
highest cards tie then the next highest cards are compared, and so on.\

Consider the following five hands dealt to two players:

| Hand | Player 1                                          | Player 2                                           | Winner   |
|    1 | 5H 5C 6S 7S KD - Pair of Fives                    | 2C 3S 8S 8D TD - Pair of Eights                    | Player 2 |
|    2 | 5D 8C 9S JS AC - Highest card Ace                 | 2C 5C 7D 8S QH - Highest card Queen                | Player 1 |
|    3 | 2D 9C AS AH AC - Three Aces                       | 3D 6D 7D TD QD - Flush with Diamonds               | Player 2 |
|    4 | 4D 6S 9H QH QC - Pair of Queens Highest card Nine | 3D 6D 7H QD QS - Pair of Queens Highest card Seven | Player 1 |
|    5 | 2H 2D 4C 4D 4S - Full House with Three Fours      | 3C 3D 3S 9S 9D - Full House with Three Threes      | Player 1 |

The file, poker.txt, contains one-thousand random hands dealt to two players.
Each line of the file contains ten cards (separated by a single space): the
first five are Player 1's cards and the last five are Player 2's cards. You can
assume that all hands are valid (no invalid characters or repeated cards), each
player's hand is in no specific order, and in each hand there is a clear winner.

How many hands does Player 1 win?

#+begin_verse
change below to begin_src/end_src to tangle poker.txt file
this is here to hide below block in github
#+end_verse
#+begin_verse text :tangle src/poker.txt
8C TS KC 9H 4S 7D 2S 5D 3S AC
5C AD 5D AC 9C 7C 5H 8D TD KS
3H 7H 6S KC JS QH TD JC 2D 8S
TH 8H 5C QS TC 9H 4D JC KS JS
7C 5H KC QH JD AS KH 4C AD 4S
5H KS 9C 7D 9H 8D 3S 5D 5C AH
6H 4H 5C 3H 2H 3S QH 5S 6S AS
TD 8C 4H 7C TC KC 4C 3H 7S KS
7C 9C 6D KD 3H 4C QS QC AC KH
JC 6S 5H 2H 2D KD 9D 7C AS JS
AD QH TH 9D 8H TS 6D 3S AS AC
2H 4S 5C 5S TC KC JD 6C TS 3C
QD AS 6H JS 2C 3D 9H KC 4H 8S
KD 8S 9S 7C 2S 3S 6D 6S 4H KC
3C 8C 2D 7D 4D 9S 4S QH 4H JD
8C KC 7S TC 2D TS 8H QD AC 5C
3D KH QD 6C 6S AD AS 8H 2H QS
6S 8D 4C 8S 6C QH TC 6D 7D 9D
2S 8D 8C 4C TS 9S 9D 9C AC 3D
3C QS 2S 4H JH 3D 2D TD 8S 9H
5H QS 8S 6D 3C 8C JD AS 7H 7D
6H TD 9D AS JH 6C QC 9S KD JC
AH 8S QS 4D TH AC TS 3C 3D 5C
5S 4D JS 3D 8H 6C TS 3S AD 8C
6D 7C 5D 5H 3S 5C JC 2H 5S 3D
5H 6H 2S KS 3D 5D JD 7H JS 8H
KH 4H AS JS QS QC TC 6D 7C KS
3D QS TS 2H JS 4D AS 9S JC KD
QD 5H 4D 5D KH 7H 3D JS KD 4H
2C 9H 6H 5C 9D 6C JC 2D TH 9S
7D 6D AS QD JH 4D JS 7C QS 5C
3H KH QD AD 8C 8H 3S TH 9D 5S
AH 9S 4D 9D 8S 4H JS 3C TC 8D
2C KS 5H QD 3S TS 9H AH AD 8S
5C 7H 5D KD 9H 4D 3D 2D KS AD
KS KC 9S 6D 2C QH 9D 9H TS TC
9C 6H 5D QH 4D AD 6D QC JS KH
9S 3H 9D JD 5C 4D 9H AS TC QH
2C 6D JC 9C 3C AD 9S KH 9D 7D
KC 9C 7C JC JS KD 3H AS 3C 7D
QD KH QS 2C 3S 8S 8H 9H 9C JC
QH 8D 3C KC 4C 4H 6D AD 9H 9D
3S KS QS 7H KH 7D 5H 5D JD AD
2H 2C 6H TH TC 7D 8D 4H 8C AS
4S 2H AC QC 3S 6D TH 4D 4C KH
4D TC KS AS 7C 3C 6D 2D 9H 6C
8C TD 5D QS 2C 7H 4C 9C 3H 9H
5H JH TS 7S TD 6H AD QD 8H 8S
5S AD 9C 8C 7C 8D 5H 9D 8S 2S
4H KH KS 9S 2S KC 5S AD 4S 7D
QS 9C QD 6H JS 5D AC 8D 2S AS
KH AC JC 3S 9D 9S 3C 9C 5S JS
AD 3C 3D KS 3S 5C 9C 8C TS 4S
JH 8D 5D 6H KD QS QD 3D 6C KC
8S JD 6C 3S 8C TC QC 3C QH JS
KC JC 8H 2S 9H 9C JH 8S 8C 9S
8S 2H QH 4D QC 9D KC AS TH 3C
8S 6H TH 7C 2H 6S 3C 3H AS 7S
QH 5S JS 4H 5H TS 8H AH AC JC
9D 8H 2S 4S TC JC 3C 7H 3H 5C
3D AD 3C 3S 4C QC AS 5D TH 8C
6S 9D 4C JS KH AH TS JD 8H AD
4C 6S 9D 7S AC 4D 3D 3S TC JD
AD 7H 6H 4H JH KC TD TS 7D 6S
8H JH TC 3S 8D 8C 9S 2C 5C 4D
2C 9D KC QH TH QS JC 9C 4H TS
QS 3C QD 8H KH 4H 8D TD 8S AC
7C 3C TH 5S 8H 8C 9C JD TC KD
QC TC JD TS 8C 3H 6H KD 7C TD
JH QS KS 9C 6D 6S AS 9H KH 6H
2H 4D AH 2D JH 6H TD 5D 4H JD
KD 8C 9S JH QD JS 2C QS 5C 7C
4S TC 7H 8D 2S 6H 7S 9C 7C KC
8C 5D 7H 4S TD QC 8S JS 4H KS
AD 8S JH 6D TD KD 7C 6C 2D 7D
JC 6H 6S JS 4H QH 9H AH 4C 3C
6H 5H AS 7C 7S 3D KH KC 5D 5C
JC 3D TD AS 4D 6D 6S QH JD KS
8C 7S 8S QH 2S JD 5C 7H AH QD
8S 3C 6H 6C 2C 8D TD 7D 4C 4D
5D QH KH 7C 2S 7H JS 6D QC QD
AD 6C 6S 7D TH 6H 2H 8H KH 4H
KS JS KD 5D 2D KH 7D 9C 8C 3D
9C 6D QD 3C KS 3S 7S AH JD 2D
AH QH AS JC 8S 8H 4C KC TH 7D
JC 5H TD 7C 5D KD 4C AD 8H JS
KC 2H AC AH 7D JH KH 5D 7S 6D
9S 5S 9C 6H 8S TD JD 9H 6C AC
7D 8S 6D TS KD 7H AC 5S 7C 5D
AH QC JC 4C TC 8C 2H TS 2C 7D
KD KC 6S 3D 7D 2S 8S 3H 5S 5C
8S 5D 8H 4C 6H KC 3H 7C 5S KD
JH 8C 3D 3C 6C KC TD 7H 7C 4C
JC KC 6H TS QS TD KS 8H 8C 9S
6C 5S 9C QH 7D AH KS KC 9S 2C
4D 4S 8H TD 9C 3S 7D 9D AS TH
6S 7D 3C 6H 5D KD 2C 5C 9D 9C
2H KC 3D AD 3H QD QS 8D JC 4S
8C 3H 9C 7C AD 5D JC 9D JS AS
5D 9H 5C 7H 6S 6C QC JC QD 9S
JC QS JH 2C 6S 9C QC 3D 4S TC
4H 5S 8D 3D 4D 2S KC 2H JS 2C
TD 3S TH KD 4D 7H JH JS KS AC
7S 8C 9S 2D 8S 7D 5C AD 9D AS
8C 7H 2S 6C TH 3H 4C 3S 8H AC
KD 5H JC 8H JD 2D 4H TD JH 5C
3D AS QH KS 7H JD 8S 5S 6D 5H
9S 6S TC QS JC 5C 5D 9C TH 8C
5H 3S JH 9H 2S 2C 6S 7S AS KS
8C QD JC QS TC QC 4H AC KH 6C
TC 5H 7D JH 4H 2H 8D JC KS 4D
5S 9C KH KD 9H 5C TS 3D 7D 2D
5H AS TC 4D 8C 2C TS 9D 3H 8D
6H 8D 2D 9H JD 6C 4S 5H 5S 6D
AD 9C JC 7D 6H 9S 6D JS 9H 3C
AD JH TC QS 4C 5D 9S 7C 9C AH
KD 6H 2H TH 8S QD KS 9D 9H AS
4H 8H 8D 5H 6C AH 5S AS AD 8S
QS 5D 4S 2H TD KS 5H AC 3H JC
9C 7D QD KD AC 6D 5H QH 6H 5S
KC AH QH 2H 7D QS 3H KS 7S JD
6C 8S 3H 6D KS QD 5D 5C 8H TC
9H 4D 4S 6S 9D KH QC 4H 6C JD
TD 2D QH 4S 6H JH KD 3C QD 8C
4S 6H 7C QD 9D AS AH 6S AD 3C
2C KC TH 6H 8D AH 5C 6D 8S 5D
TD TS 7C AD JC QD 9H 3C KC 7H
5D 4D 5S 8H 4H 7D 3H JD KD 2D
JH TD 6H QS 4S KD 5C 8S 7D 8H
AC 3D AS 8C TD 7H KH 5D 6C JD
9D KS 7C 6D QH TC JD KD AS KC
JH 8S 5S 7S 7D AS 2D 3D AD 2H
2H 5D AS 3C QD KC 6H 9H 9S 2C
9D 5D TH 4C JH 3H 8D TC 8H 9H
6H KD 2C TD 2H 6C 9D 2D JS 8C
KD 7S 3C 7C AS QH TS AD 8C 2S
QS 8H 6C JS 4C 9S QC AD TD TS
2H 7C TS TC 8C 3C 9H 2D 6D JC
TC 2H 8D JH KS 6D 3H TD TH 8H
9D TD 9H QC 5D 6C 8H 8C KC TS
2H 8C 3D AH 4D TH TC 7D 8H KC
TS 5C 2D 8C 6S KH AH 5H 6H KC
5S 5D AH TC 4C JD 8D 6H 8C 6C
KC QD 3D 8H 2D JC 9H 4H AD 2S
TD 6S 7D JS KD 4H QS 2S 3S 8C
4C 9H JH TS 3S 4H QC 5S 9S 9C
2C KD 9H JS 9S 3H JC TS 5D AC
AS 2H 5D AD 5H JC 7S TD JS 4C
2D 4S 8H 3D 7D 2C AD KD 9C TS
7H QD JH 5H JS AC 3D TH 4C 8H
6D KH KC QD 5C AD 7C 2D 4H AC
3D 9D TC 8S QD 2C JC 4H JD AH
6C TD 5S TC 8S AH 2C 5D AS AC
TH 7S 3D AS 6C 4C 7H 7D 4H AH
5C 2H KS 6H 7S 4H 5H 3D 3C 7H
3C 9S AC 7S QH 2H 3D 6S 3S 3H
2D 3H AS 2C 6H TC JS 6S 9C 6C
QH KD QD 6D AC 6H KH 2C TS 8C
8H 7D 3S 9H 5D 3H 4S QC 9S 5H
2D 9D 7H 6H 3C 8S 5H 4D 3S 4S
KD 9S 4S TC 7S QC 3S 8S 2H 7H
TC 3D 8C 3H 6C 2H 6H KS KD 4D
KC 3D 9S 3H JS 4S 8H 2D 6C 8S
6H QS 6C TC QD 9H 7D 7C 5H 4D
TD 9D 8D 6S 6C TC 5D TS JS 8H
4H KC JD 9H TC 2C 6S 5H 8H AS
JS 9C 5C 6S 9D JD 8H KC 4C 6D
4D 8D 8S 6C 7C 6H 7H 8H 5C KC
TC 3D JC 6D KS 9S 6H 7S 9C 2C
6C 3S KD 5H TS 7D 9H 9S 6H KH
3D QD 4C 6H TS AC 3S 5C 2H KD
4C AS JS 9S 7C TS 7H 9H JC KS
4H 8C JD 3H 6H AD 9S 4S 5S KS
4C 2C 7D 3D AS 9C 2S QS KC 6C
8S 5H 3D 2S AC 9D 6S 3S 4D TD
QD TH 7S TS 3D AC 7H 6C 5D QC
TC QD AD 9C QS 5C 8D KD 3D 3C
9D 8H AS 3S 7C 8S JD 2D 8D KC
4C TH AC QH JS 8D 7D 7S 9C KH
9D 8D 4C JH 2C 2S QD KD TS 4H
4D 6D 5D 2D JH 3S 8S 3H TC KH
AD 4D 2C QS 8C KD JH JD AH 5C
5C 6C 5H 2H JH 4H KS 7C TC 3H
3C 4C QC 5D JH 9C QD KH 8D TC
3H 9C JS 7H QH AS 7C 9H 5H JC
2D 5S QD 4S 3C KC 6S 6C 5C 4C
5D KH 2D TS 8S 9C AS 9S 7C 4C
7C AH 8C 8D 5S KD QH QS JH 2C
8C 9D AH 2H AC QC 5S 8H 7H 2C
QD 9H 5S QS QC 9C 5H JC TH 4H
6C 6S 3H 5H 3S 6H KS 8D AC 7S
AC QH 7H 8C 4S KC 6C 3D 3S TC
9D 3D JS TH AC 5H 3H 8S 3S TC
QD KH JS KS 9S QC 8D AH 3C AC
5H 6C KH 3S 9S JH 2D QD AS 8C
6C 4D 7S 7H 5S JC 6S 9H 4H JH
AH 5S 6H 9S AD 3S TH 2H 9D 8C
4C 8D 9H 7C QC AD 4S 9C KC 5S
9D 6H 4D TC 4C JH 2S 5D 3S AS
2H 6C 7C KH 5C AD QS TH JD 8S
3S 4S 7S AH AS KC JS 2S AD TH
JS KC 2S 7D 8C 5C 9C TS 5H 9D
7S 9S 4D TD JH JS KH 6H 5D 2C
JD JS JC TH 2D 3D QD 8C AC 5H
7S KH 5S 9D 5D TD 4S 6H 3C 2D
4S 5D AC 8D 4D 7C AD AS AH 9C
6S TH TS KS 2C QC AH AS 3C 4S
2H 8C 3S JC 5C 7C 3H 3C KH JH
7S 3H JC 5S 6H 4C 2S 4D KC 7H
4D 7C 4H 9S 8S 6S AD TC 6C JC
KH QS 3S TC 4C 8H 8S AC 3C TS
QD QS TH 3C TS 7H 7D AH TD JC
TD JD QC 4D 9S 7S TS AD 7D AC
AH 7H 4S 6D 7C 2H 9D KS JC TD
7C AH JD 4H 6D QS TS 2H 2C 5C
TC KC 8C 9S 4C JS 3C JC 6S AH
AS 7D QC 3D 5S JC JD 9D TD KH
TH 3C 2S 6H AH AC 5H 5C 7S 8H
QC 2D AC QD 2S 3S JD QS 6S 8H
KC 4H 3C 9D JS 6H 3S 8S AS 8C
7H KC 7D JD 2H JC QH 5S 3H QS
9H TD 3S 8H 7S AC 5C 6C AH 7C
8D 9H AH JD TD QS 7D 3S 9C 8S
AH QH 3C JD KC 4S 5S 5D TD KS
9H 7H 6S JH TH 4C 7C AD 5C 2D
7C KD 5S TC 9D 6S 6C 5D 2S TH
KC 9H 8D 5H 7H 4H QC 3D 7C AS
6S 8S QC TD 4S 5C TH QS QD 2S
8S 5H TH QC 9H 6S KC 7D 7C 5C
7H KD AH 4D KH 5C 4S 2D KC QH
6S 2C TD JC AS 4D 6C 8C 4H 5S
JC TC JD 5S 6S 8D AS 9D AD 3S
6D 6H 5D 5S TC 3D 7D QS 9D QD
4S 6C 8S 3S 7S AD KS 2D 7D 7C
KC QH JC AC QD 5D 8D QS 7H 7D
JS AH 8S 5H 3D TD 3H 4S 6C JH
4S QS 7D AS 9H JS KS 6D TC 5C
2D 5C 6H TC 4D QH 3D 9H 8S 6C
6D 7H TC TH 5S JD 5C 9C KS KD
8D TD QH 6S 4S 6C 8S KC 5C TC
5S 3D KS AC 4S 7D QD 4C TH 2S
TS 8H 9S 6S 7S QH 3C AH 7H 8C
4C 8C TS JS QC 3D 7D 5D 7S JH
8S 7S 9D QC AC 7C 6D 2H JH KC
JS KD 3C 6S 4S 7C AH QC KS 5H
KS 6S 4H JD QS TC 8H KC 6H AS
KH 7C TC 6S TD JC 5C 7D AH 3S
3H 4C 4H TC TH 6S 7H 6D 9C QH
7D 5H 4S 8C JS 4D 3D 8S QH KC
3H 6S AD 7H 3S QC 8S 4S 7S JS
3S JD KH TH 6H QS 9C 6C 2D QD
4S QH 4D 5H KC 7D 6D 8D TH 5S
TD AD 6S 7H KD KH 9H 5S KC JC
3H QC AS TS 4S QD KS 9C 7S KC
TS 6S QC 6C TH TC 9D 5C 5D KD
JS 3S 4H KD 4C QD 6D 9S JC 9D
8S JS 6D 4H JH 6H 6S 6C KS KH
AC 7D 5D TC 9S KH 6S QD 6H AS
AS 7H 6D QH 8D TH 2S KH 5C 5H
4C 7C 3D QC TC 4S KH 8C 2D JS
6H 5D 7S 5H 9C 9H JH 8S TH 7H
AS JS 2S QD KH 8H 4S AC 8D 8S
3H 4C TD KD 8C JC 5C QS 2D JD
TS 7D 5D 6C 2C QS 2H 3C AH KS
4S 7C 9C 7D JH 6C 5C 8H 9D QD
2S TD 7S 6D 9C 9S QS KH QH 5C
JC 6S 9C QH JH 8D 7S JS KH 2H
8D 5H TH KC 4D 4S 3S 6S 3D QS
2D JD 4C TD 7C 6D TH 7S JC AH
QS 7S 4C TH 9D TS AD 4D 3H 6H
2D 3H 7D JD 3D AS 2S 9C QC 8S
4H 9H 9C 2C 7S JH KD 5C 5D 6H
TC 9H 8H JC 3C 9S 8D KS AD KC
TS 5H JD QS QH QC 8D 5D KH AH
5D AS 8S 6S 4C AH QC QD TH 7H
3H 4H 7D 6S 4S 9H AS 8H JS 9D
JD 8C 2C 9D 7D 5H 5S 9S JC KD
KD 9C 4S QD AH 7C AD 9D AC TD
6S 4H 4S 9C 8D KS TC 9D JH 7C
5S JC 5H 4S QH AC 2C JS 2S 9S
8C 5H AS QD AD 5C 7D 8S QC TD
JC 4C 8D 5C KH QS 4D 6H 2H 2C
TH 4S 2D KC 3H QD AC 7H AD 9D
KH QD AS 8H TH KC 8D 7S QH 8C
JC 6C 7D 8C KH AD QS 2H 6S 2D
JC KH 2D 7D JS QC 5H 4C 5D AD
TS 3S AD 4S TD 2D TH 6S 9H JH
9H 2D QS 2C 4S 3D KH AS AC 9D
KH 6S 8H 4S KD 7D 9D TS QD QC
JH 5H AH KS AS AD JC QC 5S KH
5D 7D 6D KS KD 3D 7C 4D JD 3S
AC JS 8D 5H 9C 3H 4H 4D TS 2C
6H KS KH 9D 7C 2S 6S 8S 2H 3D
6H AC JS 7S 3S TD 8H 3H 4H TH
9H TC QC KC 5C KS 6H 4H AC 8S
TC 7D QH 4S JC TS 6D 6C AC KH
QH 7D 7C JH QS QD TH 3H 5D KS
3D 5S 8D JS 4C 2C KS 7H 9C 4H
5H 8S 4H TD 2C 3S QD QC 3H KC
QC JS KD 9C AD 5S 9D 7D 7H TS
8C JC KH 7C 7S 6C TS 2C QD TH
5S 9D TH 3C 7S QH 8S 9C 2H 5H
5D 9H 6H 2S JS KH 3H 7C 2H 5S
JD 5D 5S 2C TC 2S 6S 6C 3C 8S
4D KH 8H 4H 2D KS 3H 5C 2S 9H
3S 2D TD 7H 8S 6H JD KC 9C 8D
6S QD JH 7C 9H 5H 8S 8H TH TD
QS 7S TD 7D TS JC KD 7C 3C 2C
3C JD 8S 4H 2D 2S TD AS 4D AC
AH KS 6C 4C 4S 7D 8C 9H 6H AS
5S 3C 9S 2C QS KD 4D 4S AC 5D
2D TS 2C JS KH QH 5D 8C AS KC
KD 3H 6C TH 8S 7S KH 6H 9S AC
6H 7S 6C QS AH 2S 2H 4H 5D 5H
5H JC QD 2C 2S JD AS QC 6S 7D
6C TC AS KD 8H 9D 2C 7D JH 9S
2H 4C 6C AH 8S TD 3H TH 7C TS
KD 4S TS 6C QH 8D 9D 9C AH 7D
6D JS 5C QD QC 9C 5D 8C 2H KD
3C QH JH AD 6S AH KC 8S 6D 6H
3D 7C 4C 7S 5S 3S 6S 5H JC 3C
QH 7C 5H 3C 3S 8C TS 4C KD 9C
QD 3S 7S 5H 7H QH JC 7C 8C KD
3C KD KH 2S 4C TS AC 6S 2C 7C
2C KH 3C 4C 6H 4D 5H 5S 7S QD
4D 7C 8S QD TS 9D KS 6H KD 3C
QS 4D TS 7S 4C 3H QD 8D 9S TC
TS QH AC 6S 3C 9H 9D QS 8S 6H
3S 7S 5D 4S JS 2D 6C QH 6S TH
4C 4H AS JS 5D 3D TS 9C AC 8S
6S 9C 7C 3S 5C QS AD AS 6H 3C
9S 8C 7H 3H 6S 7C AS 9H JD KH
3D 3H 7S 4D 6C 7C AC 2H 9C TH
4H 5S 3H AC TC TH 9C 9H 9S 8D
8D 9H 5H 4D 6C 2H QD 6S 5D 3S
4C 5C JD QS 4D 3H TH AC QH 8C
QC 5S 3C 7H AD 4C KS 4H JD 6D
QS AH 3H KS 9H 2S JS JH 5H 2H
2H 5S TH 6S TS 3S KS 3C 5H JS
2D 9S 7H 3D KC JH 6D 7D JS TD
AC JS 8H 2C 8C JH JC 2D TH 7S
5D 9S 8H 2H 3D TC AH JC KD 9C
9D QD JC 2H 6D KH TS 9S QH TH
2C 8D 4S JD 5H 3H TH TC 9C KC
AS 3D 9H 7D 4D TH KH 2H 7S 3H
4H 7S KS 2S JS TS 8S 2H QD 8D
5S 6H JH KS 8H 2S QC AC 6S 3S
JC AS AD QS 8H 6C KH 4C 4D QD
2S 3D TS TD 9S KS 6S QS 5C 8D
3C 6D 4S QC KC JH QD TH KH AD
9H AH 4D KS 2S 8D JH JC 7C QS
2D 6C TH 3C 8H QD QH 2S 3S KS
6H 5D 9S 4C TS TD JS QD 9D JD
5H 8H KH 8S KS 7C TD AD 4S KD
2C 7C JC 5S AS 6C 7D 8S 5H 9C
6S QD 9S TS KH QS 5S QH 3C KC
7D 3H 3C KD 5C AS JH 7H 6H JD
9D 5C 9H KC 8H KS 4S AD 4D 2S
3S JD QD 8D 2S 7C 5S 6S 5H TS
6D 9S KC TD 3S 6H QD JD 5C 8D
5H 9D TS KD 8D 6H TD QC 4C 7D
6D 4S JD 9D AH 9S AS TD 9H QD
2D 5S 2H 9C 6H 9S TD QC 7D TC
3S 2H KS TS 2C 9C 8S JS 9D 7D
3C KC 6D 5D 6C 6H 8S AS 7S QS
JH 9S 2H 8D 4C 8H 9H AD TH KH
QC AS 2S JS 5C 6H KD 3H 7H 2C
QD 8H 2S 8D 3S 6D AH 2C TC 5C
JD JS TS 8S 3H 5D TD KC JC 6H
6S QS TC 3H 5D AH JC 7C 7D 4H
7C 5D 8H 9C 2H 9H JH KH 5S 2C
9C 7H 6S TH 3S QC QD 4C AC JD
2H 5D 9S 7D KC 3S QS 2D AS KH
2S 4S 2H 7D 5C TD TH QH 9S 4D
6D 3S TS 6H 4H KS 9D 8H 5S 2D
9H KS 4H 3S 5C 5D KH 6H 6S JS
KC AS 8C 4C JC KH QC TH QD AH
6S KH 9S 2C 5H TC 3C 7H JC 4D
JD 4S 6S 5S 8D 7H 7S 4D 4C 2H
7H 9H 5D KH 9C 7C TS TC 7S 5H
4C 8D QC TS 4S 9H 3D AD JS 7C
8C QS 5C 5D 3H JS AH KC 4S 9D
TS JD 8S QS TH JH KH 2D QD JS
JD QC 5D 6S 9H 3S 2C 8H 9S TS
2S 4C AD 7H JC 5C 2D 6D 4H 3D
7S JS 2C 4H 8C AD QD 9C 3S TD
JD TS 4C 6H 9H 7D QD 6D 3C AS
AS 7C 4C 6S 5D 5S 5C JS QC 4S
KD 6S 9S 7C 3C 5S 7D JH QD JS
4S 7S JH 2C 8S 5D 7H 3D QH AD
TD 6H 2H 8D 4H 2D 7C AD KH 5D
TS 3S 5H 2C QD AH 2S 5C KH TD
KC 4D 8C 5D AS 6C 2H 2S 9H 7C
KD JS QC TS QS KH JH 2C 5D AD
3S 5H KC 6C 9H 3H 2H AD 7D 7S
7S JS JH KD 8S 7D 2S 9H 7C 2H
9H 2D 8D QC 6S AD AS 8H 5H 6C
2S 7H 6C 6D 7D 8C 5D 9D JC 3C
7C 9C 7H JD 2H KD 3S KH AD 4S
QH AS 9H 4D JD KS KD TS KH 5H
4C 8H 5S 3S 3D 7D TD AD 7S KC
JS 8S 5S JC 8H TH 9C 4D 5D KC
7C 5S 9C QD 2C QH JS 5H 8D KH
TD 2S KS 3D AD KC 7S TC 3C 5D
4C 2S AD QS 6C 9S QD TH QH 5C
8C AD QS 2D 2S KC JD KS 6C JC
8D 4D JS 2H 5D QD 7S 7D QH TS
6S 7H 3S 8C 8S 9D QS 8H 6C 9S
4S TC 2S 5C QD 4D QS 6D TH 6S
3S 5C 9D 6H 8D 4C 7D TC 7C TD
AH 6S AS 7H 5S KD 3H 5H AC 4C
8D 8S AH KS QS 2C AD 6H 7D 5D
6H 9H 9S 2H QS 8S 9C 5D 2D KD
TS QC 5S JH 7D 7S TH 9S 9H AC
7H 3H 6S KC 4D 6D 5C 4S QD TS
TD 2S 7C QD 3H JH 9D 4H 7S 7H
KS 3D 4H 5H TC 2S AS 2D 6D 7D
8H 3C 7H TD 3H AD KC TH 9C KH
TC 4C 2C 9S 9D 9C 5C 2H JD 3C
3H AC TS 5D AD 8D 6H QC 6S 8C
2S TS 3S JD 7H 8S QH 4C 5S 8D
AC 4S 6C 3C KH 3D 7C 2D 8S 2H
4H 6C 8S TH 2H 4S 8H 9S 3H 7S
7C 4C 9C 2C 5C AS 5D KD 4D QH
9H 4H TS AS 7D 8D 5D 9S 8C 2H
QC KD AC AD 2H 7S AS 3S 2D 9S
2H QC 8H TC 6D QD QS 5D KH 3C
TH JD QS 4C 2S 5S AD 7H 3S AS
7H JS 3D 6C 3S 6D AS 9S AC QS
9C TS AS 8C TC 8S 6H 9D 8D 6C
4D JD 9C KC 7C 6D KS 3S 8C AS
3H 6S TC 8D TS 3S KC 9S 7C AS
8C QC 4H 4S 8S 6C 3S TC AH AC
4D 7D 5C AS 2H 6S TS QC AD TC
QD QC 8S 4S TH 3D AH TS JH 4H
5C 2D 9S 2C 3H 3C 9D QD QH 7D
KC 9H 6C KD 7S 3C 4D AS TC 2D
3D JS 4D 9D KS 7D TH QC 3H 3C
8D 5S 2H 9D 3H 8C 4C 4H 3C TH
JC TH 4S 6S JD 2D 4D 6C 3D 4C
TS 3S 2D 4H AC 2C 6S 2H JH 6H
TD 8S AD TC AH AC JH 9S 6S 7S
6C KC 4S JD 8D 9H 5S 7H QH AH
KD 8D TS JH 5C 5H 3H AD AS JS
2D 4H 3D 6C 8C 7S AD 5D 5C 8S
TD 5D 7S 9C 4S 5H 6C 8C 4C 8S
JS QH 9C AS 5C QS JC 3D QC 7C
JC 9C KH JH QS QC 2C TS 3D AD
5D JH AC 5C 9S TS 4C JD 8C KS
KC AS 2D KH 9H 2C 5S 4D 3D 6H
TH AH 2D 8S JC 3D 8C QH 7S 3S
8H QD 4H JC AS KH KS 3C 9S 6D
9S QH 7D 9C 4S AC 7H KH 4D KD
AH AD TH 6D 9C 9S KD KS QH 4H
QD 6H 9C 7C QS 6D 6S 9D 5S JH
AH 8D 5H QD 2H JC KS 4H KH 5S
5C 2S JS 8D 9C 8C 3D AS KC AH
JD 9S 2H QS 8H 5S 8C TH 5C 4C
QC QS 8C 2S 2C 3S 9C 4C KS KH
2D 5D 8S AH AD TD 2C JS KS 8C
TC 5S 5H 8H QC 9H 6H JD 4H 9S
3C JH 4H 9H AH 4S 2H 4C 8D AC
8S TH 4D 7D 6D QD QS 7S TC 7C
KH 6D 2D JD 5H JS QD JH 4H 4S
9C 7S JH 4S 3S TS QC 8C TC 4H
QH 9D 4D JH QS 3S 2C 7C 6C 2D
4H 9S JD 5C 5H AH 9D TS 2D 4C
KS JH TS 5D 2D AH JS 7H AS 8D
JS AH 8C AD KS 5S 8H 2C 6C TH
2H 5D AD AC KS 3D 8H TS 6H QC
6D 4H TS 9C 5H JS JH 6S JD 4C
JH QH 4H 2C 6D 3C 5D 4C QS KC
6H 4H 6C 7H 6S 2S 8S KH QC 8C
3H 3D 5D KS 4H TD AD 3S 4D TS
5S 7C 8S 7D 2C KS 7S 6C 8C JS
5D 2H 3S 7C 5C QD 5H 6D 9C 9H
JS 2S KD 9S 8D TD TS AC 8C 9D
5H QD 2S AC 8C 9H KS 7C 4S 3C
KH AS 3H 8S 9C JS QS 4S AD 4D
AS 2S TD AD 4D 9H JC 4C 5H QS
5D 7C 4H TC 2D 6C JS 4S KC 3S
4C 2C 5D AC 9H 3D JD 8S QS QH
2C 8S 6H 3C QH 6D TC KD AC AH
QC 6C 3S QS 4S AC 8D 5C AD KH
5S 4C AC KH AS QC 2C 5C 8D 9C
8H JD 3C KH 8D 5C 9C QD QH 9D
7H TS 2C 8C 4S TD JC 9C 5H QH
JS 4S 2C 7C TH 6C AS KS 7S JD
JH 7C 9H 7H TC 5H 3D 6D 5D 4D
2C QD JH 2H 9D 5S 3D TD AD KS
JD QH 3S 4D TH 7D 6S QS KS 4H
TC KS 5S 8D 8H AD 2S 2D 4C JH
5S JH TC 3S 2D QS 9D 4C KD 9S
AC KH 3H AS 9D KC 9H QD 6C 6S
9H 7S 3D 5C 7D KC TD 8H 4H 6S
3C 7H 8H TC QD 4D 7S 6S QH 6C
6D AD 4C QD 6C 5D 7D 9D KS TS
JH 2H JD 9S 7S TS KH 8D 5D 8H
2D 9S 4C 7D 9D 5H QD 6D AC 6S
7S 6D JC QD JH 4C 6S QS 2H 7D
8C TD JH KD 2H 5C QS 2C JS 7S
TC 5H 4H JH QD 3S 5S 5D 8S KH
KS KH 7C 2C 5D JH 6S 9C 6D JC
5H AH JD 9C JS KC 2H 6H 4D 5S
AS 3C TH QC 6H 9C 8S 8C TD 7C
KC 2C QD 9C KH 4D 7S 3C TS 9H
9C QC 2S TS 8C TD 9S QD 3S 3C
4D 9D TH JH AH 6S 2S JD QH JS
QD 9H 6C KD 7D 7H 5D 6S 8H AH
8H 3C 4S 2H 5H QS QH 7S 4H AC
QS 3C 7S 9S 4H 3S AH KS 9D 7C
AD 5S 6S 2H 2D 5H TC 4S 3C 8C
QH TS 6S 4D JS KS JH AS 8S 6D
2C 8S 2S TD 5H AS TC TS 6C KC
KC TS 8H 2H 3H 7C 4C 5S TH TD
KD AD KH 7H 7S 5D 5H 5S 2D 9C
AD 9S 3D 7S 8C QC 7C 9C KD KS
3C QC 9S 8C 4D 5C AS QD 6C 2C
2H KC 8S JD 7S AC 8D 5C 2S 4D
9D QH 3D 2S TC 3S KS 3C 9H TD
KD 6S AC 2C 7H 5H 3S 6C 6H 8C
QH TC 8S 6S KH TH 4H 5D TS 4D
8C JS 4H 6H 2C 2H 7D AC QD 3D
QS KC 6S 2D 5S 4H TD 3H JH 4C
7S 5H 7H 8H KH 6H QS TH KD 7D
5H AD KD 7C KH 5S TD 6D 3C 6C
8C 9C 5H JD 7C KC KH 7H 2H 3S
7S 4H AD 4D 8S QS TH 3D 7H 5S
8D TC KS KD 9S 6D AD JD 5C 2S
7H 8H 6C QD 2H 6H 9D TC 9S 7C
8D 6D 4C 7C 6C 3C TH KH JS JH
5S 3S 8S JS 9H AS AD 8H 7S KD
JH 7C 2C KC 5H AS AD 9C 9S JS
AD AC 2C 6S QD 7C 3H TH KS KD
9D JD 4H 8H 4C KH 7S TS 8C KC
3S 5S 2H 7S 6H 7D KS 5C 6D AD
5S 8C 9H QS 7H 7S 2H 6C 7D TD
QS 5S TD AC 9D KC 3D TC 2D 4D
TD 2H 7D JD QD 4C 7H 5D KC 3D
4C 3H 8S KD QH 5S QC 9H TC 5H
9C QD TH 5H TS 5C 9H AH QH 2C
4D 6S 3C AC 6C 3D 2C 2H TD TH
AC 9C 5D QC 4D AD 8D 6D 8C KC
AD 3C 4H AC 8D 8H 7S 9S TD JC
4H 9H QH JS 2D TH TD TC KD KS
5S 6S 9S 8D TH AS KH 5H 5C 8S
JD 2S 9S 6S 5S 8S 5D 7S 7H 9D
5D 8C 4C 9D AD TS 2C 7D KD TC
8S QS 4D KC 5C 8D 4S KH JD KD
AS 5C AD QH 7D 2H 9S 7H 7C TC
2S 8S JD KH 7S 6C 6D AD 5D QC
9H 6H 3S 8C 8H AH TC 4H JS TD
2C TS 4D 7H 2D QC 9C 5D TH 7C
6C 8H QC 5D TS JH 5C 5H 9H 4S
2D QC 7H AS JS 8S 2H 4C 4H 8D
JS 6S AC KD 3D 3C 4S 7H TH KC
QH KH 6S QS 5S 4H 3C QD 3S 3H
7H AS KH 8C 4H 9C 5S 3D 6S TS
9C 7C 3H 5S QD 2C 3D AD AC 5H
JH TD 2D 4C TS 3H KH AD 3S 7S
AS 4C 5H 4D 6S KD JC 3C 6H 2D
3H 6S 8C 2D TH 4S AH QH AD 5H
7C 2S 9H 7H KC 5C 6D 5S 3H JC
3C TC 9C 4H QD TD JH 6D 9H 5S
7C 6S 5C 5D 6C 4S 7H 9H 6H AH
AD 2H 7D KC 2C 4C 2S 9S 7H 3S
TH 4C 8S 6S 3S AD KS AS JH TD
5C TD 4S 4D AD 6S 5D TC 9C 7D
8H 3S 4D 4S 5S 6H 5C AC 3H 3D
9H 3C AC 4S QS 8S 9D QH 5H 4D
JC 6C 5H TS AC 9C JD 8C 7C QD
8S 8H 9C JD 2D QC QH 6H 3C 8D
KS JS 2H 6H 5H QH QS 3H 7C 6D
TC 3H 4S 7H QC 2H 3S 8C JS KH
AH 8H 5S 4C 9H JD 3H 7S JC AC
3C 2D 4C 5S 6C 4S QS 3S JD 3D
5H 2D TC AH KS 6D 7H AD 8C 6H
6C 7S 3C JD 7C 8H KS KH AH 6D
AH 7D 3H 8H 8S 7H QS 5H 9D 2D
JD AC 4H 7S 8S 9S KS AS 9D QH
7S 2C 8S 5S JH QS JC AH KD 4C
AH 2S 9H 4H 8D TS TD 6H QH JD
4H JC 3H QS 6D 7S 9C 8S 9D 8D
5H TD 4S 9S 4C 8C 8D 7H 3H 3D
QS KH 3S 2C 2S 3C 7S TD 4S QD
7C TD 4D 5S KH AC AS 7H 4C 6C
2S 5H 6D JD 9H QS 8S 2C 2H TD
2S TS 6H 9H 7S 4H JC 4C 5D 5S
2C 5H 7D 4H 3S QH JC JS 6D 8H
4C QH 7C QD 3S AD TH 8S 5S TS
9H TC 2S TD JC 7D 3S 3D TH QH
7D 4C 8S 5C JH 8H 6S 3S KC 3H
JC 3H KH TC QH TH 6H 2C AC 5H
QS 2H 9D 2C AS 6S 6C 2S 8C 8S
9H 7D QC TH 4H KD QS AC 7S 3C
4D JH 6S 5S 8H KS 9S QC 3S AS
JD 2D 6S 7S TC 9H KC 3H 7D KD
2H KH 7C 4D 4S 3H JS QD 7D KC
4C JC AS 9D 3C JS 6C 8H QD 4D
AH JS 3S 6C 4C 3D JH 6D 9C 9H
9H 2D 8C 7H 5S KS 6H 9C 2S TC
6C 8C AD 7H 6H 3D KH AS 5D TH
KS 8C 3S TS 8S 4D 5S 9S 6C 4H
9H 4S 4H 5C 7D KC 2D 2H 9D JH
5C JS TC 9D 9H 5H 7S KH JC 6S
7C 9H 8H 4D JC KH JD 2H TD TC
8H 6C 2H 2C KH 6H 9D QS QH 5H
AC 7D 2S 3D QD JC 2D 8D JD JH
2H JC 2D 7H 2C 3C 8D KD TD 4H
3S 4H 6D 8D TS 3H TD 3D 6H TH
JH JC 3S AC QH 9H 7H 8S QC 2C
7H TD QS 4S 8S 9C 2S 5D 4D 2H
3D TS 3H 2S QC 8H 6H KC JC KS
5D JD 7D TC 8C 6C 9S 3D 8D AC
8H 6H JH 6C 5D 8D 8S 4H AD 2C
9D 4H 2D 2C 3S TS AS TC 3C 5D
4D TH 5H KS QS 6C 4S 2H 3D AD
5C KC 6H 2C 5S 3C 4D 2D 9H 9S
JD 4C 3H TH QH 9H 5S AH 8S AC
7D 9S 6S 2H TD 9C 4H 8H QS 4C
3C 6H 5D 4H 8C 9C KC 6S QD QS
3S 9H KD TC 2D JS 8C 6S 4H 4S
2S 4C 8S QS 6H KH 3H TH 8C 5D
2C KH 5S 3S 7S 7H 6C 9D QD 8D
8H KS AC 2D KH TS 6C JS KC 7H
9C KS 5C TD QC AH 6C 5H 9S 7C
5D 4D 3H 4H 6S 7C 7S AH QD TD
2H 7D QC 6S TC TS AH 7S 9D 3H
TH 5H QD 9S KS 7S 7C 6H 8C TD
TH 2D 4D QC 5C 7D JD AH 9C 4H
4H 3H AH 8D 6H QC QH 9H 2H 2C
2D AD 4C TS 6H 7S TH 4H QS TD
3C KD 2H 3H QS JD TC QC 5D 8H
KS JC QD TH 9S KD 8D 8C 2D 9C
3C QD KD 6D 4D 8D AH AD QC 8S
8H 3S 9D 2S 3H KS 6H 4C 7C KC
TH 9S 5C 3D 7D 6H AC 7S 4D 2C
5C 3D JD 4D 2D 6D 5H 9H 4C KH
AS 7H TD 6C 2H 3D QD KS 4C 4S
JC 3C AC 7C JD JS 8H 9S QC 5D
JD 6S 5S 2H AS 8C 7D 5H JH 3D
8D TC 5S 9S 8S 3H JC 5H 7S AS
5C TD 3D 7D 4H 8D 7H 4D 5D JS
QS 9C KS TD 2S 8S 5C 2H 4H AS
TH 7S 4H 7D 3H JD KD 5D 2S KC
JD 7H 4S 8H 4C JS 6H QH 5S 4H
2C QS 8C 5S 3H QC 2S 6C QD AD
8C 3D JD TC 4H 2H AD 5S AC 2S
5D 2C JS 2D AD 9D 3D 4C 4S JH
8D 5H 5D 6H 7S 4D KS 9D TD JD
3D 6D 9C 2S AS 7D 5S 5C 8H JD
7C 8S 3S 6S 5H JD TC AD 7H 7S
2S 9D TS 4D AC 8D 6C QD JD 3H
9S KH 2C 3C AC 3D 5H 6H 8D 5D
KS 3D 2D 6S AS 4C 2S 7C 7H KH
AC 2H 3S JC 5C QH 4D 2D 5H 7S
TS AS JD 8C 6H JC 8S 5S 2C 5D
7S QH 7H 6C QC 8H 2D 7C JD 2S
2C QD 2S 2H JC 9C 5D 2D JD JH
7C 5C 9C 8S 7D 6D 8D 6C 9S JH
2C AD 6S 5H 3S KS 7S 9D KH 4C
7H 6C 2C 5C TH 9D 8D 3S QC AH
5S KC 6H TC 5H 8S TH 6D 3C AH
9C KD 4H AD TD 9S 4S 7D 6H 5D
7H 5C 5H 6D AS 4C KD KH 4H 9D
3C 2S 5C 6C JD QS 2H 9D 7D 3H
AC 2S 6S 7S JS QD 5C QS 6H AD
5H TH QC 7H TC 3S 7C 6D KC 3D
4H 3D QC 9S 8H 2C 3S JC KS 5C
4S 6S 2C 6H 8S 3S 3D 9H 3H JS
4S 8C 4D 2D 8H 9H 7D 9D AH TS
9S 2C 9H 4C 8D AS 7D 3D 6D 5S
6S 4C 7H 8C 3H 5H JC AH 9D 9C
2S 7C 5S JD 8C 3S 3D 4D 7D 6S
3C KC 4S 5D 7D 3D JD 7H 3H 4H
9C 9H 4H 4D TH 6D QD 8S 9S 7S
2H AC 8S 4S AD 8C 2C AH 7D TC
TS 9H 3C AD KS TC 3D 8C 8H JD
QC 8D 2C 3C 7D 7C JD 9H 9C 6C
AH 6S JS JH 5D AS QC 2C JD TD
9H KD 2H 5D 2D 3S 7D TC AH TS
TD 8H AS 5D AH QC AC 6S TC 5H
KS 4S 7H 4D 8D 9C TC 2H 6H 3H
3H KD 4S QD QH 3D 8H 8C TD 7S
8S JD TC AH JS QS 2D KH KS 4D
3C AD JC KD JS KH 4S TH 9H 2C
QC 5S JS 9S KS AS 7C QD 2S JD
KC 5S QS 3S 2D AC 5D 9H 8H KS
6H 9C TC AD 2C 6D 5S JD 6C 7C
QS KH TD QD 2C 3H 8S 2S QC AH
9D 9H JH TC QH 3C 2S JS 5C 7H
6C 3S 3D 2S 4S QD 2D TH 5D 2C
2D 6H 6D 2S JC QH AS 7H 4H KH
5H 6S KS AD TC TS 7C AC 4S 4H
AD 3C 4H QS 8C 9D KS 2H 2D 4D
4S 9D 6C 6D 9C AC 8D 3H 7H KD
JC AH 6C TS JD 6D AD 3S 5D QD
JC JH JD 3S 7S 8S JS QC 3H 4S
JD TH 5C 2C AD JS 7H 9S 2H 7S
8D 3S JH 4D QC AS JD 2C KC 6H
2C AC 5H KD 5S 7H QD JH AH 2D
JC QH 8D 8S TC 5H 5C AH 8C 6C
3H JS 8S QD JH 3C 4H 6D 5C 3S
6D 4S 4C AH 5H 5S 3H JD 7C 8D
8H AH 2H 3H JS 3C 7D QC 4H KD
6S 2H KD 5H 8H 2D 3C 8S 7S QD
2S 7S KC QC AH TC QS 6D 4C 8D
5S 9H 2C 3S QD 7S 6C 2H 7C 9D
3C 6C 5C 5S JD JC KS 3S 5D TS
7C KS 6S 5S 2S 2D TC 2H 5H QS
AS 7H 6S TS 5H 9S 9D 3C KD 2H
4S JS QS 3S 4H 7C 2S AC 6S 9D
8C JH 2H 5H 7C 5D QH QS KH QC
3S TD 3H 7C KC 8D 5H 8S KH 8C
4H KH JD TS 3C 7H AS QC JS 5S
AH 9D 2C 8D 4D 2D 6H 6C KC 6S
2S 6H 9D 3S 7H 4D KH 8H KD 3D
9C TC AC JH KH 4D JD 5H TD 3S
7S 4H 9D AS 4C 7D QS 9S 2S KH
3S 8D 8S KS 8C JC 5C KH 2H 5D
8S QH 2C 4D KC JS QC 9D AC 6H
8S 8C 7C JS JD 6S 4C 9C AC 4S
QH 5D 2C 7D JC 8S 2D JS JH 4C
JS 4C 7S TS JH KC KH 5H QD 4S
QD 8C 8D 2D 6S TD 9D AC QH 5S
QH QC JS 3D 3C 5C 4H KH 8S 7H
7C 2C 5S JC 8S 3H QC 5D 2H KC
5S 8D KD 6H 4H QD QH 6D AH 3D
7S KS 6C 2S 4D AC QS 5H TS JD
7C 2D TC 5D QS AC JS QC 6C KC
2C KS 4D 3H TS 8S AD 4H 7S 9S
QD 9H QH 5H 4H 4D KH 3S JC AD
4D AC KC 8D 6D 4C 2D KH 2C JD
2C 9H 2D AH 3H 6D 9C 7D TC KS
8C 3H KD 7C 5C 2S 4S 5H AS AH
TH JD 4H KD 3H TC 5C 3S AC KH
6D 7H AH 7S QC 6H 2D TD JD AS
JH 5D 7H TC 9S 7D JC AS 5S KH
2H 8C AD TH 6H QD KD 9H 6S 6C
QH KC 9D 4D 3S JS JH 4H 2C 9H
TC 7H KH 4H JC 7D 9S 3H QS 7S
AD 7D JH 6C 7H 4H 3S 3H 4D QH
JD 2H 5C AS 6C QC 4D 3C TC JH
AC JD 3H 6H 4C JC AD 7D 7H 9H
4H TC TS 2C 8C 6S KS 2H JD 9S
4C 3H QS QC 9S 9H 6D KC 9D 9C
5C AD 8C 2C QH TH QD JC 8D 8H
QC 2C 2S QD 9C 4D 3S 8D JH QS
9D 3S 2C 7S 7C JC TD 3C TC 9H
3C TS 8H 5C 4C 2C 6S 8D 7C 4H
KS 7H 2H TC 4H 2C 3S AS AH QS
8C 2D 2H 2C 4S 4C 6S 7D 5S 3S
TH QC 5D TD 3C QS KD KC KS AS
4D AH KD 9H KS 5C 4C 6H JC 7S
KC 4H 5C QS TC 2H JC 9S AH QH
4S 9H 3H 5H 3C QD 2H QC JH 8H
5D AS 7H 2C 3D JH 6H 4C 6S 7D
9C JD 9H AH JS 8S QH 3H KS 8H
3S AC QC TS 4D AD 3D AH 8S 9H
7H 3H QS 9C 9S 5H JH JS AH AC
8D 3C JD 2H AC 9C 7H 5S 4D 8H
7C JH 9H 6C JS 9S 7H 8C 9D 4H
2D AS 9S 6H 4D JS JH 9H AD QD
6H 7S JH KH AH 7H TD 5S 6S 2C
8H JH 6S 5H 5S 9D TC 4C QC 9S
7D 2C KD 3H 5H AS QD 7H JS 4D
TS QH 6C 8H TH 5H 3C 3H 9C 9D
AD KH JS 5D 3H AS AC 9S 5C KC
2C KH 8C JC QS 6D AH 2D KC TC
9D 3H 2S 7C 4D 6D KH KS 8D 7D
9H 2S TC JH AC QC 3H 5S 3S 8H
3S AS KD 8H 4C 3H 7C JH QH TS
7S 6D 7H 9D JH 4C 3D 3S 6C AS
4S 2H 2C 4C 8S 5H KC 8C QC QD
3H 3S 6C QS QC 2D 6S 5D 2C 9D
2H 8D JH 2S 3H 2D 6C 5C 7S AD
9H JS 5D QH 8S TS 2H 7S 6S AD
6D QC 9S 7H 5H 5C 7D KC JD 4H
QC 5S 9H 9C 4D 6S KS 2S 4C 7C
9H 7C 4H 8D 3S 6H 5C 8H JS 7S
2D 6H JS TD 4H 4D JC TH 5H KC
AC 7C 8D TH 3H 9S 2D 4C KC 4D
KD QS 9C 7S 3D KS AD TS 4C 4H
QH 9C 8H 2S 7D KS 7H 5D KD 4C
9C 2S 2H JC 6S 6C TC QC JH 5C
7S AC 8H KC 8S 6H QS JC 3D 6S
JS 2D JH 8C 4S 6H 8H 6D 5D AD
6H 7D 2S 4H 9H 7C AS AC 8H 5S
3C JS 4S 6D 5H 2S QH 6S 9C 2C
3D 5S 6S 9S 4C QS 8D QD 8S TC
9C 3D AH 9H 5S 2C 7D AD JC 3S
7H TC AS 3C 6S 6D 7S KH KC 9H
3S TC 8H 6S 5H JH 8C 7D AC 2S
QD 9D 9C 3S JC 8C KS 8H 5D 4D
JS AH JD 6D 9D 8C 9H 9S 8H 3H
2D 6S 4C 4D 8S AD 4S TC AH 9H
TS AC QC TH KC 6D 4H 7S 8C 2H
3C QD JS 9D 5S JC AH 2H TS 9H
3H 4D QH 5D 9C 5H 7D 4S JC 3S
8S TH 3H 7C 2H JD JS TS AC 8D
9C 2H TD KC JD 2S 8C 5S AD 2C
3D KD 7C 5H 4D QH QD TC 6H 7D
7H 2C KC 5S KD 6H AH QC 7S QH
6H 5C AC 5H 2C 9C 2D 7C TD 2S
4D 9D AH 3D 7C JD 4H 8C 4C KS
TH 3C JS QH 8H 4C AS 3D QS QC
4D 7S 5H JH 6D 7D 6H JS KH 3C
QD 8S 7D 2H 2C 7C JC 2S 5H 8C
QH 8S 9D TC 2H AD 7C 8D QD 6S
3S 7C AD 9H 2H 9S JD TS 4C 2D
3S AS 4H QC 2C 8H 8S 7S TD TC
JH TH TD 3S 4D 4H 5S 5D QS 2C
8C QD QH TC 6D 4S 9S 9D 4H QC
8C JS 9D 6H JD 3H AD 6S TD QC
KC 8S 3D 7C TD 7D 8D 9H 4S 3S
6C 4S 3D 9D KD TC KC KS AC 5S
7C 6S QH 3D JS KD 6H 6D 2D 8C
JD 2S 5S 4H 8S AC 2D 6S TS 5C
5H 8C 5S 3C 4S 3D 7C 8D AS 3H
AS TS 7C 3H AD 7D JC QS 6C 6H
3S 9S 4C AC QH 5H 5D 9H TS 4H
6C 5C 7H 7S TD AD JD 5S 2H 2S
7D 6C KC 3S JD 8D 8S TS QS KH
8S QS 8D 6C TH AC AH 2C 8H 9S
7H TD KH QH 8S 3D 4D AH JD AS
TS 3D 2H JC 2S JH KH 6C QC JS
KC TH 2D 6H 7S 2S TC 8C 9D QS
3C 9D 6S KH 8H 6D 5D TH 2C 2H
6H TC 7D AD 4D 8S TS 9H TD 7S
JS 6D JD JC 2H AC 6C 3D KH 8D
KH JD 9S 5D 4H 4C 3H 7S QS 5C
4H JD 5D 3S 3C 4D KH QH QS 7S
JD TS 8S QD AH 4C 6H 3S 5S 2C
QS 3D JD AS 8D TH 7C 6S QC KS
7S 2H 8C QC 7H AC 6D 2D TH KH
5S 6C 7H KH 7D AH 8C 5C 7S 3D
3C KD AD 7D 6C 4D KS 2D 8C 4S
7C 8D 5S 2D 2S AH AD 2C 9D TD
3C AD 4S KS JH 7C 5C 8C 9C TH
AS TD 4D 7C JD 8C QH 3C 5H 9S
3H 9C 8S 9S 6S QD KS AH 5H JH
QC 9C 5S 4H 2H TD 7D AS 8C 9D
8C 2C 9D KD TC 7S 3D KH QC 3C
4D AS 4C QS 5S 9D 6S JD QH KS
6D AH 6C 4C 5H TS 9H 7D 3D 5S
QS JD 7C 8D 9C AC 3S 6S 6C KH
8H JH 5D 9S 6D AS 6S 3S QC 7H
QD AD 5C JH 2H AH 4H AS KC 2C
JH 9C 2C 6H 2D JS 5D 9H KC 6D
7D 9D KD TH 3H AS 6S QC 6H AD
JD 4H 7D KC 3H JS 3C TH 3D QS
4C 3H 8C QD 5H 6H AS 8H AD JD
TH 8S KD 5D QC 7D JS 5S 5H TS
7D KC 9D QS 3H 3C 6D TS 7S AH
7C 4H 7H AH QC AC 4D 5D 6D TH
3C 4H 2S KD 8H 5H JH TC 6C JD
4S 8C 3D 4H JS TD 7S JH QS KD
7C QC KD 4D 7H 6S AD TD TC KH
5H 9H KC 3H 4D 3D AD 6S QD 6H
TH 7C 6H TS QH 5S 2C KC TD 6S
7C 4D 5S JD JH 7D AC KD KH 4H
7D 6C 8D 8H 5C JH 8S QD TH JD
8D 7D 6C 7C 9D KD AS 5C QH JH
9S 2C 8C 3C 4C KS JH 2D 8D 4H
7S 6C JH KH 8H 3H 9D 2D AH 6D
4D TC 9C 8D 7H TD KS TH KD 3C
JD 9H 8D QD AS KD 9D 2C 2S 9C
8D 3H 5C 7H KS 5H QH 2D 8C 9H
2D TH 6D QD 6C KC 3H 3S AD 4C
4H 3H JS 9D 3C TC 5H QH QC JC
3D 5C 6H 3S 3C JC 5S 7S 2S QH
AC 5C 8C 4D 5D 4H 2S QD 3C 3H
2C TD AH 9C KD JS 6S QD 4C QC
QS 8C 3S 4H TC JS 3H 7C JC AD
5H 4D 9C KS JC TD 9S TS 8S 9H
QD TS 7D AS AC 2C TD 6H 8H AH
6S AD 8C 4S 9H 8D 9D KH 8S 3C
QS 4D 2D 7S KH JS JC AD 4C 3C
QS 9S 7H KC TD TH 5H JS AC JH
6D AC 2S QS 7C AS KS 6S KH 5S
6D 8H KH 3C QS 2H 5C 9C 9D 6C
JS 2C 4C 6H 7D JC AC QD TD 3H
4H QC 8H JD 4C KD KS 5C KC 7S
6D 2D 3H 2S QD 5S 7H AS TH 6S
AS 6D 8D 2C 8S TD 8H QD JC AH
9C 9H 2D TD QH 2H 5C TC 3D 8H
KC 8S 3D KH 2S TS TC 6S 4D JH
9H 9D QS AC KC 6H 5D 4D 8D AH
9S 5C QS 4H 7C 7D 2H 8S AD JS
3D AC 9S AS 2C 2D 2H 3H JC KH
7H QH KH JD TC KS 5S 8H 4C 8D
2H 7H 3S 2S 5H QS 3C AS 9H KD
AD 3D JD 6H 5S 9C 6D AC 9S 3S
3D 5D 9C 2D AC 4S 2S AD 6C 6S
QC 4C 2D 3H 6S KC QH QD 2H JH
QC 3C 8S 4D 9S 2H 5C 8H QS QD
6D KD 6S 7H 3S KH 2H 5C JC 6C
3S 9S TC 6S 8H 2D AD 7S 8S TS
3C 6H 9C 3H 5C JC 8H QH TD QD
3C JS QD 5D TD 2C KH 9H TH AS
9S TC JD 3D 5C 5H AD QH 9H KC
TC 7H 4H 8H 3H TD 6S AC 7C 2S
QS 9D 5D 3C JC KS 4D 6C JH 2S
9S 6S 3C 7H TS 4C KD 6D 3D 9C
2D 9H AH AC 7H 2S JH 3S 7C QC
QD 9H 3C 2H AC AS 8S KD 8C KH
2D 7S TD TH 6D JD 8D 4D 2H 5S
8S QH KD JD QS JH 4D KC 5H 3S
3C KH QC 6D 8H 3S AH 7D TD 2D
5S 9H QH 4S 6S 6C 6D TS TH 7S
6C 4C 6D QS JS 9C TS 3H 8D 8S
JS 5C 7S AS 2C AH 2H AD 5S TC
KD 6C 9C 9D TS 2S JC 4H 2C QD
QS 9H TC 3H KC KS 4H 3C AD TH
KH 9C 2H KD 9D TC 7S KC JH 2D
7C 3S KC AS 8C 5D 9C 9S QH 3H
2D 8C TD 4C 2H QC 5D TC 2C 7D
KS 4D 6C QH TD KH 5D 7C AD 8D
2S 9S 8S 4C 8C 3D 6H QD 7C 7H
6C 8S QH 5H TS 5C 3C 4S 2S 2H
8S 6S 2H JC 3S 3H 9D 8C 2S 7H
QC 2C 8H 9C AC JD 4C 4H 6S 3S
3H 3S 7D 4C 9S 5H 8H JC 3D TC
QH 2S 2D 9S KD QD 9H AD 6D 9C
8D 2D KS 9S JC 4C JD KC 4S TH
KH TS 6D 4D 5C KD 5H AS 9H AD
QD JS 7C 6D 5D 5C TH 5H QH QS
9D QH KH 5H JH 4C 4D TC TH 6C
KH AS TS 9D KD 9C 7S 4D 8H 5S
KH AS 2S 7D 9D 4C TS TH AH 7C
KS 4D AC 8S 9S 8D TH QH 9D 5C
5D 5C 8C QS TC 4C 3D 3S 2C 8D
9D KS 2D 3C KC 4S 8C KH 6C JC
8H AH 6H 7D 7S QD 3C 4C 6C KC
3H 2C QH 8H AS 7D 4C 8C 4H KC
QD 5S 4H 2C TD AH JH QH 4C 8S
3H QS 5S JS 8H 2S 9H 9C 3S 2C
6H TS 7S JC QD AC TD KC 5S 3H
QH AS QS 7D JC KC 2C 4C 5C 5S
QH 3D AS JS 4H 8D 7H JC 2S 9C
5D 4D 2S 4S 9D 9C 2D QS 8H 7H
6D 7H 3H JS TS AC 2D JH 7C 8S
JH 5H KC 3C TC 5S 9H 4C 8H 9D
8S KC 5H 9H AD KS 9D KH 8D AH
JC 2H 9H KS 6S 3H QC 5H AH 9C
5C KH 5S AD 6C JC 9H QC 9C TD
5S 5D JC QH 2D KS 8H QS 2H TS
JH 5H 5S AH 7H 3C 8S AS TD KH
6H 3D JD 2C 4C KC 7S AH 6C JH
4C KS 9D AD 7S KC 7D 8H 3S 9C
7H 5C 5H 3C 8H QC 3D KH 6D JC
2D 4H 5D 7D QC AD AH 9H QH 8H
KD 8C JS 9D 3S 3C 2H 5D 6D 2S
8S 6S TS 3C 6H 8D 5S 3H TD 6C
KS 3D JH 9C 7C 9S QS 5S 4H 6H
7S 6S TH 4S KC KD 3S JC JH KS
7C 3C 2S 6D QH 2C 7S 5H 8H AH
KC 8D QD 6D KH 5C 7H 9D 3D 9C
6H 2D 8S JS 9S 2S 6D KC 7C TC
KD 9C JH 7H KC 8S 2S 7S 3D 6H
4H 9H 2D 4C 8H 7H 5S 8S 2H 8D
AD 7C 3C 7S 5S 4D 9H 3D JC KH
5D AS 7D 6D 9C JC 4C QH QS KH
KD JD 7D 3D QS QC 8S 6D JS QD
6S 8C 5S QH TH 9H AS AC 2C JD
QC KS QH 7S 3C 4C 5C KC 5D AH
6C 4H 9D AH 2C 3H KD 3D TS 5C
TD 8S QS AS JS 3H KD AC 4H KS
7D 5D TS 9H 4H 4C 9C 2H 8C QC
2C 7D 9H 4D KS 4C QH AD KD JS
QD AD AH KH 9D JS 9H JC KD JD
8S 3C 4S TS 7S 4D 5C 2S 6H 7C
JS 7S 5C KD 6D QH 8S TD 2H 6S
QH 6C TC 6H TD 4C 9D 2H QC 8H
3D TS 4D 2H 6H 6S 2C 7H 8S 6C
9H 9D JD JH 3S AH 2C 6S 3H 8S
2C QS 8C 5S 3H 2S 7D 3C AD 4S
5C QC QH AS TS 4S 6S 4C 5H JS
JH 5C TD 4C 6H JS KD KH QS 4H
TC KH JC 4D 9H 9D 8D KC 3C 8H
2H TC 8S AD 9S 4H TS 7H 2C 5C
4H 2S 6C 5S KS AH 9C 7C 8H KD
TS QH TD QS 3C JH AH 2C 8D 7D
5D KC 3H 5S AC 4S 7H QS 4C 2H
3D 7D QC KH JH 6D 6C TD TH KD
5S 8D TH 6C 9D 7D KH 8C 9S 6D
JD QS 7S QC 2S QH JC 4S KS 8D
7S 5S 9S JD KD 9C JC AD 2D 7C
4S 5H AH JH 9C 5D TD 7C 2D 6S
KC 6C 7H 6S 9C QD 5S 4H KS TD
6S 8D KS 2D TH TD 9H JD TS 3S
KH JS 4H 5D 9D TC TD QC JD TS
QS QD AC AD 4C 6S 2D AS 3H KC
4C 7C 3C TD QS 9C KC AS 8D AD
KC 7H QC 6D 8H 6S 5S AH 7S 8C
3S AD 9H JC 6D JD AS KH 6S JH
AD 3D TS KS 7H JH 2D JS QD AC
9C JD 7C 6D TC 6H 6C JC 3D 3S
QC KC 3S JC KD 2C 8D AH QS TS
AS KD 3D JD 8H 7C 8C 5C QD 6C
#+end_verse

#+begin_src odin :main no :comments link :tangle src/poker_hands.odin
package poker_hands

import "core:os"
import "core:fmt"
import "core:slice"
import "core:strconv"
import "core:strings"

Suit :: enum {
	Hearts,   // hearts
	Clubs,    // clubs
	Spades,   // spades
	Diamonds, // diamonds
}

Card :: struct {
	value: int,
	suit: Suit,
}

value_to_card_str :: proc(value: int) -> string {
	switch value {
	case 2: return "Two"
	case 3: return "Three"
	case 4: return "Four"
	case 5: return "Five"
	case 6: return "Six"
	case 7: return "Seven"
	case 8: return "Eight"
	case 9: return "Nine"
	case 10: return "Ten"
	case 11: return "Jack"
	case 12: return "Queen"
	case 13: return "King"
	case 14: return "Ace"
	}
	return "unknown card value"
}

get_cards :: proc(hand: string) -> (cards: [5]Card) {
	for i in 0..<5 {
		v := rune(hand[i*3 + 0])
		s := rune(hand[i*3 + 1])
		if v >= '2' && v <= '9' {
			cards[i].value = int(v-'0')
		} else if v == 'T' {
			cards[i].value = 10
		} else if v == 'J' {
			cards[i].value = 11
		} else if v == 'Q' {
			cards[i].value = 12
		} else if v == 'K' {
			cards[i].value = 13
		} else if v == 'A' {
			cards[i].value = 14
		}
		if s == 'H' {
			cards[i].suit = .Hearts
		} else if s == 'C' {
			cards[i].suit = .Clubs
		} else if s == 'S' {
			cards[i].suit = .Spades
		} else if s == 'D' {
			cards[i].suit = .Diamonds
		}
	}
	return
}

rank_cards :: proc(cards: [5]Card) -> (string, [2]int) {
	value_cnts : [15]int
	high_card : int = 0
	rank := ""
	rank_scores := [2]int{0,0} // high card is 0
	for i in 0..<5 {
		value_cnts[cards[i].value] += 1
		if cards[i].value > high_card {
			high_card = cards[i].value
		}
	}

	has_pair := [2]int{0,0}
	has_tri  := 0
	for i in 0..<15 {
		val := 14-i
		if value_cnts[val] >= 2 {
			rank = fmt.tprintf("Pair of %ss", value_to_card_str(val))
			rank_scores[0] = 1 // one pair is 1
			if has_pair[0] > 0 {
				has_pair[1] = val
			} else {
				has_pair[0] = val
			}
			if value_cnts[val] >= 3 {
				rank = fmt.tprintf("Three %ss", value_to_card_str(val))
				rank_scores[0] = 3 // three of a kind
				if has_pair[0] == val {
					has_pair[0] = 0 // this pair is now a tri
				}
				has_tri = val
				if value_cnts[val] >= 4 {
					rank = fmt.tprintf("Four of a Kind %ss", value_to_card_str(val))
					rank_scores[0] = 7 // four of a kind
				}
			}
			if high_card == val { // make this not high card anymore
				high_card = 0
				for i in 0..<5 {
					if cards[i].value > high_card && cards[i].value != val &&
						cards[i].value != has_pair[0] && cards[i].value != has_pair[1] {
						high_card = cards[i].value
					}
				}
			}
			rank = fmt.tprintf("%s Highest card %s", rank, value_to_card_str(high_card))
			if has_tri > 0 {
				rank_scores[1] = has_tri<<4 + high_card
			} else if has_pair[0] > 0 {
				rank_scores[1] = has_pair[0]<<4 + high_card
			} else {
				rank_scores[1] = high_card
			}
		}
	}

	if has_tri > 0 && has_pair[0] > 0 {
		// full house - triple is most important to rank
		rank = fmt.tprintf("Full House With %s and %s", value_to_card_str(has_tri), value_to_card_str(has_pair[0]))
		rank_scores[0] = 6 // full house
		rank_scores[1] = has_tri<<4 + high_card
	}	else if has_pair[0] > 0 && has_pair[1] > 0 {
		if has_pair[0] < has_pair[1] {
			has_pair[0], has_pair[1] = has_pair[1], has_pair[0] // swap
		}
		rank = fmt.tprintf("Two Pair %s and %s with kicker %s", value_to_card_str(has_pair[0]), value_to_card_str(has_pair[1]), value_to_card_str(high_card))
		rank_scores[0] = 2 // two pair
		rank_scores[1] = has_pair[0]<<8 + has_pair[1]<<4 + high_card
	}
	
	is_flush := true
	suit := cards[0].suit
	for i in 1..<5 {
		if cards[i].suit != suit {
			is_flush = false
			break
		}
	}
	if is_flush {
		rank = fmt.tprintf("Flush with %s Highest card %s", suit, value_to_card_str(high_card))
		rank_scores[0] = 5 // flush
		rank_scores[1] = high_card
	}

	is_straight := true
	values : [5]int
	for i in 0..<5 {
		values[i] = cards[i].value
	}
	slice.sort(values[:])
	curr := values[0]
	for i in 1..<5 {
		if i == 4 && values[i] == 14 { // ace at end
			if values[0] != 2 {
				is_straight = false
				break
			}
		} else if values[i] != curr + 1 {
			is_straight = false
			break
		}
		curr = values[i]
	}
	if is_straight {
		rank = fmt.tprintf("Straight Highest card %s", value_to_card_str(high_card))
		rank_scores[0] = 4 // straight
		rank_scores[1] = high_card
	}

	if is_flush && is_straight {
		rank = fmt.tprintf("Straight Flush Highest card %s", value_to_card_str(high_card))
		rank_scores[0] = 8 // straight flush
		rank_scores[1] = high_card
		if high_card == 14 {
			rank = fmt.tprintf("Royal Flush")
			rank_scores[0] = 9 // royal flush
			rank_scores[1] = 0 // these alway tie?
		}
	}
	
	if rank == "" {
		rank = fmt.tprintf("Highest card %s", value_to_card_str(high_card))
		rank_scores[0] = 0 // lowest rank
		rank_scores[1] = high_card
	}

	return rank, rank_scores
}

main :: proc() {
	//hands := []string{"5H 5C 6S 7S KD",
	//                  "2C 3S 8S 8D TD",
	//                  "5D 8C 9S JS AC",
	//                  "2C 5C 7D 8S QH",
	//                  "2D 9C AS AH AC",
	//                  "3D 6D 7D TD QD",
	//                  "4D 6S 9H QH QC",
	//                  "3D 6D 7H QD QS",
	//                  "2H 2D 4C 4D 4S",
	//                  "3C 3D 3S 9S 9D",
	//                 }
  //
	//for h in hands {
	//	cards_1 := get_cards(h)
	//	fmt.println(cards_1)
	//	fmt.println(rank_cards(cards_1))
	//}

	data, ok := os.read_entire_file("poker.txt")
	player_1_wins : int = 0
	player_2_wins : int = 0
	if ok {
		lines := strings.split(string(data), "\n")
		for l,idx in lines {
			if len(l) < 15 {
				fmt.println("bad line", l)
			} else {
				hand_1 := l[0:3*5]
				hand_2 := l[3*5:]
				cards_1 := get_cards(hand_1)
				cards_2 := get_cards(hand_2)
				rank_1, rank_score_1 := rank_cards(cards_1)
				rank_2, rank_score_2 := rank_cards(cards_2)
				if rank_score_1[0] > rank_score_2[0] {
					player_1_wins += 1
				} else {
					if rank_score_1[0] == rank_score_2[0] {
						if rank_score_1[1] == rank_score_2[1] {
							fmt.println("DERP! tie?", hand_1, hand_2) // needs more ranking!
						}
						if rank_score_1[1] > rank_score_2[1] {
							player_1_wins += 1
						} else {
							player_2_wins += 1
						}
					}
				}
			}
		}
		fmt.println(player_1_wins, player_2_wins)
	} else {
		fmt.println("poker.txt not found!")
	}
}
#+end_src
* Prob 055 - Lychrel Numbers
If we take $47$, reverse and add, $47 + 74 = 121$, which is palindromic.
Not all numbers produce palindromes so quickly. For example,

$$\begin{align}\\
349 + 943 &= 1292\\
1292 + 2921 &= 4213\\
4213 + 3124 &= 7337
\end{align}$$

That is, $349$ took three iterations to arrive at a palindrome.
Although no one has proved it yet, it is thought that some numbers, like $196$,
never produce a palindrome. A number that never forms a palindrome through the
reverse and add process is called a Lychrel number. Due to the theoretical
nature of these numbers, and for the purpose of this problem, we shall assume
that a number is Lychrel until proven otherwise. In addition you are given that
for every number below ten-thousand, it will either (i) become a palindrome in
less than fifty iterations, or, (ii) no one, with all the computing power that
exists, has managed so far to map it to a palindrome. In fact, $10677$ is the
first number to be shown to require over fifty iterations before producing a
palindrome: $4668731596684224866951378664$ ($53$ iterations, 28-digits).

Surprisingly, there are palindromic numbers that are themselves Lychrel numbers;
the first example is $4994$.

How many Lychrel numbers are there below ten-thousand?

NOTE: Wording was modified slightly on 24 April 2007 to emphasise the
theoretical nature of Lychrel numbers.

#+begin_src odin :main no :comments link :tangle src/lychrel_numbers.odin
package lychrel_numbers

import "core:fmt"
import "core:strings"
import "core:strconv"
import "../util"

reverse_and_add :: proc(num: f64) -> f64 {
	buf: [32]byte
	str_tmp := strconv.append_float(buf[:], num, 'f', 32, 64)
	dot := strings.index(str_tmp, ".")
	str := str_tmp[1:dot]
	rev, err := strings.reverse(str)

	if err == .None {
		num2, ok := strconv.parse_f64(rev)
		if !ok {
			fmt.println("parse reverse error", str, rev)
			return -2
		}
		tmp := num + num2
		if tmp < 0 {
			fmt.println("overflow!")
		}
		return tmp
	}
	return -1
}

main :: proc() {
	cnt := 0
	for i in 1..<10_000 {
		ii := f64(i)

		iterations := 1
		for ; iterations < 50; iterations += 1 {
			num := reverse_and_add(ii)
			if (util.is_palindrome(num)) {
				//fmt.println(i, "is palindrome in", iterations, "iterations")
				break
			}
			ii = num
		}
		if iterations >= 50 {
			fmt.println(i, "is lychrel")
			cnt += 1
		}
	}
	fmt.println("cnt", cnt)
}
#+end_src

* Prob 056 - Powerful Digit Sum
A googol ($10^{100}$) is a massive number: one followed by one-hundred zeros;
$100^{100}$ is almost unimaginably large: one followed by two-hundred zeros.
Despite their size, the sum of the digits in each number is only $1$.

Considering natural numbers of the form, $a^b$, where $a, b < 100$, what is the
maximum digital sum?

$a^b = c$  ..  $log_a(c) = b$  ..  $\sqrt[b]{c}=a$
$2^3 = 8$  ..  $log_2(8) = 3$  ..  $\sqrt[3]{8}=2$

modulo 9 gives similar result to adding digits
or more simply put:
 11111 is 5 ones so mod 9 is 5

identities:
1. (a + b) mod n = [(a mod n) + (b mod n)] mod n.
2. ab mod n = [(a mod n)(b mod n)] mod n.
3. a^b mod n = [(a mod n)^b] mod n.

consider b^e mod m...
one way to calc this is with:
b = 4, e = 13, and m = 497 is presented again. The algorithm performs the iteration thirteen times:

(e' =  1)   c = (4 * 1) mod 497 = 4 mod 497 = 4
(e' =  2)   c = (4 * 4) mod 497 = 16 mod 497 = 16
(e' =  3)   c = (4 * 16) mod 497 = 64 mod 497 = 64
(e' =  4)   c = (4 * 64) mod 497 = 256 mod 497 = 256
(e' =  5)   c = (4 * 256) mod 497 = 1024 mod 497 = 30
(e' =  6)   c = (4 * 30) mod 497 = 120 mod 497 = 120
(e' =  7)   c = (4 * 120) mod 497 = 480 mod 497 = 480
(e' =  8)   c = (4 * 480) mod 497 = 1920 mod 497 = 429
(e' =  9)   c = (4 * 429) mod 497 = 1716 mod 497 = 225
(e' = 10)   c = (4 * 225) mod 497 = 900 mod 497 = 403
(e' = 11)   c = (4 * 403) mod 497 = 1612 mod 497 = 121
(e' = 12)   c = (4 * 121) mod 497 = 484 mod 497 = 484
(e' = 13)   c = (4 * 484) mod 497 = 1936 mod 497 = 445

if we use mod 9 then
4^13; this comes out to 67,108,864

6 + 7 + 1 + 0 + 8 + 8 + 6 + 4 = 40
4 + 0 = 4
mod 9 is 4 ofcourse

another way:
b = 4,  e = 13  and m = 9

e' = 1   c = (4 * 1) mod 9 = 4
e' = 2   c = (4 * 4) mod 9 = 7
e' = 3   c = (4 * 7) mod 9 = 1
e' = 4   c = (4 * 1) mod 9 = 4
e' = 5   c = (4 * 4) mod 9 = 7
e' = 6   c = (4 * 7) mod 9 = 1
e' = 7   c = (4 * 1) mod 9 = 4
e' = 8   c = (4 * 4) mod 9 = 7
e' = 9   c = (4 * 7) mod 9 = 1
e' = 10  c = (4 * 1) mod 9 = 4
e' = 11  c = (4 * 4) mod 9 = 7
e' = 12  c = (4 * 7) mod 9 = 1
e' = 13  c = (4 * 1) mod 9 = 4 <- ans
40 .. is not 4

note:
The length of a number n in base b is the number of digits in the base-b numeral for n, given by the formula

 L(n,b)=|_log_b(n)_|+1, 
where |_x_| is the floor function.
or
 L(a^b,c) = |_log_c(a^b)_| + 1 = |_b * log_c(a)_| + 1
see next prob for counting digits in a bignum

#+begin_src odin :main no :comments link :tangle src/powerful_digit_sum.odin
package powerful_digit_sum

import "core:fmt"
import "core:math"
import "core:math/big"
import "core:strings"
import "core:strconv"

cnt_digits_int :: proc(str: string) -> int {
	acc := 0
	for c in str {
		acc += strconv._digit_value(c)
	}
	return acc
}

cnt_digits_big :: proc(n: ^big.Int) -> int {
	acc := 0
	denom := new(big.Int); defer free(denom)
	rem := new(big.Int); defer free(rem)
	quot := new(big.Int); defer free(quot)
	zero := new(big.Int); defer free(zero)

	big.set(quot, n)
	big.set(denom, 10)
	big.set(zero, 0)
	
	gtz := true
	tmp : i64
	err : big.Error = .Okay

	for ; gtz && err == .Okay; {
		big.int_mod(rem, quot, denom)
		tmp, err = big.int_get_i64(rem)
		
		if err == .Okay {
			acc += int(tmp)
			big.int_div(quot, quot, denom)
			gtz, err = big.greater_than(quot, zero)
		}
	}
	return acc
}

cnt_digits :: proc{cnt_digits_int, cnt_digits_big}

main :: proc() {
	maxi := 0
	aa := 0
	bb := 0
	for a in 91..<100 {
		for b in 91..<100 {
			//c := math.pow_f64(f64(a), f64(b))
      //
			//buf: [32]byte
			//str_tmp := strconv.append_float(buf[:], c, 'f', 32, 64)
			//dot := strings.index(str_tmp, ".")
			//str := str_tmp[1:dot]
      //
			//fmt.println(str, cnt_digits(str), "a", a, "b", b)
      //
			//// another way without calc'ing the power, but is wrong!
			//r_acc := 0
			//r_c := 1
			//for e in 0..<b {
			//	r_c = (a * r_c) % 9 // this ends up being a^b mod 9.. but what is digit_sum?
			//	r_acc += r_c
			//}
			//fmt.println(str, r_acc-b+1)

			// just use bignums =( really wish there was a nifty trick
			// at least this shows using bignums
			dest := new(big.Int)
			base := new(big.Int)
			big.int_set_from_integer(base, a)
			big.pow(dest, base, b)
			tmp := cnt_digits(dest)
			if tmp > maxi {
				maxi = tmp
				aa = a
				bb = b
			}
		}
	}
	fmt.println("maxi", maxi, aa, bb)
}
#+end_src

#+RESULTS:
: maxi 972 99 95

* Prob 057 - Square Root Convergents
It is possible to show that the square root of two can be expressed as an infinite continued fraction.
$\sqrt 2 =1+ \frac 1 {2+ \frac 1 {2 +\frac 1 {2+ \dots}}}$
By expanding this for the first four iterations, we get:
$1 + \frac 1 2 = \frac  32 = 1.5$
$1 + \frac 1 {2 + \frac 1 2} = \frac 7 5 = 1.4$
$1 + \frac 1 {2 + \frac 1 {2+\frac 1 2}} = \frac {17}{12} = 1.41666 \dots$
$1 + \frac 1 {2 + \frac 1 {2+\frac 1 {2+\frac 1 2}}} = \frac {41}{29} = 1.41379
\dots$

2/2 + 1/2 = 3/2
4/2 + 1/2 = 5/2 .. 1/(5/2) = 2/5 .. 5/5 + 2/5 = 7/5
4/2 + 1/2 = 5/2 .. 10/5 + 2/5 = 12/5 .. 12/12 + 5/12 = 17/12
.. idea here is to calc 4/2 + 1/2 = 5/2 then invert to 2/5 and add 2 then invert
then add 2 then invert.. until the end when we just add 1 instead of 2

The next three expansions are $\frac {99}{70}$, $\frac {239}{169}$, and $\frac
{577}{408}$, but the eighth expansion, $\frac {1393}{985}$, is the first example
where the number of digits in the numerator exceeds the number of digits in the
denominator.

In the first one-thousand expansions, how many fractions contain a numerator
with more digits than the denominator?

#+begin_src odin :main no :comments link :tangle src/square_root_convergents.odin
package square_root_convergents

import "core:fmt"
import "core:math/big"


// L(n,b)=|_log_b(n)_|+1,
number_of_digits :: proc(num: ^big.Int) -> int {
	// assumes base 10
	base := new(big.Int); defer free(base)
	big.set(base, 10)
	ret, err := big.log(num, base.digit[0])
	return ret
}

square_root_two_as_fraction :: proc(expansion_level: int, nom: ^big.Int, denom: ^big.Int) {
	el := expansion_level
	big.set(nom, 3) // first exansion_level 0
	big.set(denom, 2)
	for i in 1..=el {
		if i == 1 {
			big.set(nom, 5)
			big.set(denom, 2)
		}
		big.swap(nom, denom)
		if i != el { // add 2*
			tmp := new(big.Int); defer free(tmp)
			big.mul(tmp, denom, 2)
			big.add(nom, nom, tmp)
		} else { // add 1*
			big.add(nom, nom, denom)
		}
	}
	return
}

main :: proc() {
	cnt := 0
	nom := new(big.Int)
	denom := new(big.Int)

	//big.set(nom, 1010)
	//fmt.println(number_of_digits(nom) + 1)

	for i in 0..<1000 {
		square_root_two_as_fraction(i, nom, denom)
		digit_cnt_nom   := number_of_digits(nom)
		digit_cnt_denom := number_of_digits(denom)
		if digit_cnt_nom > digit_cnt_denom {
			cnt += 1
		}
	}
	fmt.println(cnt)
}
#+end_src

* Prob 058 - Spiral Primes
Starting with $1$ and spiralling anticlockwise in the following way, a square
spiral with side length $7$ is formed.

$$\begin{matrix}\\
&37 &36 &35 &34 &33 &32 &31\\
&38 &17 &16 &15 &14 &13 &30\\
&39 &18 &5  &4  &3  &12 &29\\
&40 &19 &6  &1  &2  &11 &28\\
&41 &20 &7  &8  &9  &10 &27\\
&42 &21 &22 &23 &24 &25 &26\\
&43 &44 &45 &46 &47 &48 &49
\end{matrix}$$

It is interesting to note that the odd squares lie along the bottom right
diagonal, but what is more interesting is that $8$ out of the $13$ numbers lying
along both diagonals are prime; that is, a ratio of $8/13 \approx 62\%$.

If one complete new layer is wrapped around the spiral above, a square spiral
with side length $9$ will be formed. If this process is continued, what is the
side length of the square spiral for which the ratio of primes along both
diagonals first falls below $10\%$?

#+begin_src odin :main no :comments link :tangle src/spiral_primes.odin
package spiral_primes

import "core:fmt"
import "core:mem"
import "core:strings"
import "vendor:raylib"
import "../util"

MENU_RECT :: raylib.Rectangle{250, 10, 240, 150}

Values :: struct {
	show_menu : bool,
	width     : int,
	height    : int,
	side_n : int,
	diag_primes : int,
}

draw_menu :: proc(values: ^Values) {
  using raylib

  menu_rect := MENU_RECT
  menu_rect.x = f32(values.width) - menu_rect.x
  if !values.show_menu {
    values.show_menu = GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")
  } else {
    panel := GuiPanel(menu_rect, "")
    values.show_menu = !GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")

	  tmp_siden := f32(values.side_n)
    GuiSlider(Rectangle{f32(values.width) - 185, 40, 160, 20}, "side len", "", &tmp_siden, 0, 100)
	  values.side_n = int(tmp_siden)
    str := fmt.tprintf("%v", values.side_n)
    cstr := strings.clone_to_cstring(str)
    GuiTextBox(Rectangle{f32(values.width) - 185, 40, 160, 20}, cstr, 10, false)
	  delete(cstr)

	  n := values.side_n
	  str = fmt.tprintf("%v == %v / %v", f32(values.diag_primes) / f32(4*n+1), f32(values.diag_primes), f32(4*n+1))
    cstr = strings.clone_to_cstring(str)
	  GuiLabel(Rectangle{f32(values.width) - 185, 65, 160, 20}, cstr)
	  delete(cstr)
  }
}

draw_square_prime_spiral :: proc(values: ^Values) {
	n := values.side_n
	curr_side_length := 0
	side_length := 0
	font_size := 10
	dir_xy := [2]int{1,0}
	x := 0
	y := 0
	maxi := (2*n+1) * (2*n+1) // odd squares
	tmp_diag_primes := 0
	// draw a 1 in the center then spiral out
	for i := 1; i <= maxi; i += 1{
		num := strings.clone_to_cstring(fmt.tprintf("%d", i)); defer delete(num)
		raylib.DrawText(num, i32(values.width/2+x*20), i32(values.height/2+y*20), i32(font_size), raylib.BLACK)
		// goto next gridcell
		x += dir_xy.x
		y += dir_xy.y
		side_length += 1
		
		if side_length > curr_side_length {
			if dir_xy.x == 1 { // manage spiral directions
				dir_xy = [2]int{0,-1}
			} else if dir_xy.y == -1 {
				dir_xy = [2]int{-1,0}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
				curr_side_length += 1
			} else if dir_xy.x == -1 {
				dir_xy = [2]int{0,1}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
			} else {
				dir_xy = [2]int{1,0}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
				curr_side_length += 1
			}
			side_length = 0
		}
	}
	values.diag_primes = tmp_diag_primes
}

count_diag_primes :: proc(side_n: int) -> int {
	n := side_n
	curr_side_length := 0
	side_length := 0
	dir_xy := [2]int{1,0}
	maxi := (2*n+1) * (2*n+1) // odd squares
	tmp_diag_primes := 0

	for i := 1; i <= maxi; i += 1{
		side_length += 1
		if side_length > curr_side_length {
			if dir_xy.x == 1 { // manage spiral directions
				dir_xy = [2]int{0,-1}
			} else if dir_xy.y == -1 {
				dir_xy = [2]int{-1,0}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
				curr_side_length += 1
			} else if dir_xy.x == -1 {
				dir_xy = [2]int{0,1}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
			} else {
				dir_xy = [2]int{1,0}
				if util.is_prime(i+1) {
					tmp_diag_primes += 1
				}
				curr_side_length += 1
			}
			side_length = 0
		}
	}
	return tmp_diag_primes
}

main :: proc() {
	using raylib

	ta := mem.Tracking_Allocator{};
	mem.tracking_allocator_init(&ta, context.allocator);
	context.allocator = mem.tracking_allocator(&ta);

	values : Values
	values.width = 500
	values.height = 500
	values.side_n = 2
	values.diag_primes = 0

	InitWindow(i32(values.width), i32(values.height), "Window_Title")
	SetTargetFPS(60)

	// actually solve the problem here
	percentage : f64 = 1.0
	for i := 13120; percentage > 0.10; i += 1 { // just guessed a big idx 'til i got close
		side_length := 2*i + 1
		pn := f64(count_diag_primes(i))
		pd := f64(4*(i)+1)
		percentage = pn / pd
		fmt.println( side_length, percentage, pn, pd)
	}
	// ------------------------------

	for !WindowShouldClose() {
		// Update ------------------------------

		// Draw   ------------------------------
		BeginDrawing()
		ClearBackground(BLUE)
		draw_square_prime_spiral(&values)
		draw_menu(&values)
		EndDrawing()
	}
	CloseWindow()

	if len(ta.allocation_map) > 0 {
		for _, v in ta.allocation_map {
			fmt.printf("Leaked %v bytes @ %v\n", v.size, v.location);
		}
	}
	if len(ta.bad_free_array) > 0 {
		fmt.println("Bad frees:");
		for v in ta.bad_free_array {
			fmt.println(v);
		}
	}
}
#+end_src

* Prob 059 - XOR Decryption
Each character on a computer is assigned a unique code and the preferred
standard is ASCII (American Standard Code for Information Interchange). For
example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.

A modern encryption method is to take a text file, convert the bytes to ASCII,
then XOR each byte with a given value, taken from a secret key. The advantage
with the XOR function is that using the same encryption key on the cipher text,
restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.

For unbreakable encryption, the key is the same length as the plain text
message, and the key is made up of random bytes. The user would keep the
encrypted message and the encryption key in different locations, and without
both "halves", it is impossible to decrypt the message.

Unfortunately, this method is impractical for most users, so the modified method
is to use a password as a key. If the password is shorter than the message,
which is likely, the key is repeated cyclically throughout the message. The
balance for this method is using a sufficiently long password key for security,
but short enough to be memorable.

Your task has been made easy, as the encryption key consists of three lower case
characters. Using 0059_cipher.txt (right click and 'Save Link/Target As...'), a
file containing the encrypted ASCII codes, and the knowledge that the plain text
must contain common English words, decrypt the message and find the sum of the
ASCII values in the original text.

#+begin_src text :tangle src/0059_ciper.txt
36,22,80,0,0,4,23,25,19,17,88,4,4,19,21,11,88,22,23,23,29,69,12,24,0,88,25,11,12,2,10,28,5,6,12,25,10,22,80,10,30,80,10,22,21,69,23,22,69,61,5,9,29,2,66,11,80,8,23,3,17,88,19,0,20,21,7,10,17,17,29,20,69,8,17,21,29,2,22,84,80,71,60,21,69,11,5,8,21,25,22,88,3,0,10,25,0,10,5,8,88,2,0,27,25,21,10,31,6,25,2,16,21,82,69,35,63,11,88,4,13,29,80,22,13,29,22,88,31,3,88,3,0,10,25,0,11,80,10,30,80,23,29,19,12,8,2,10,27,17,9,11,45,95,88,57,69,16,17,19,29,80,23,29,19,0,22,4,9,1,80,3,23,5,11,28,92,69,9,5,12,12,21,69,13,30,0,0,0,0,27,4,0,28,28,28,84,80,4,22,80,0,20,21,2,25,30,17,88,21,29,8,2,0,11,3,12,23,30,69,30,31,23,88,4,13,29,80,0,22,4,12,10,21,69,11,5,8,88,31,3,88,4,13,17,3,69,11,21,23,17,21,22,88,65,69,83,80,84,87,68,69,83,80,84,87,73,69,83,80,84,87,65,83,88,91,69,29,4,6,86,92,69,15,24,12,27,24,69,28,21,21,29,30,1,11,80,10,22,80,17,16,21,69,9,5,4,28,2,4,12,5,23,29,80,10,30,80,17,16,21,69,27,25,23,27,28,0,84,80,22,23,80,17,16,17,17,88,25,3,88,4,13,29,80,17,10,5,0,88,3,16,21,80,10,30,80,17,16,25,22,88,3,0,10,25,0,11,80,12,11,80,10,26,4,4,17,30,0,28,92,69,30,2,10,21,80,12,12,80,4,12,80,10,22,19,0,88,4,13,29,80,20,13,17,1,10,17,17,13,2,0,88,31,3,88,4,13,29,80,6,17,2,6,20,21,69,30,31,9,20,31,18,11,94,69,54,17,8,29,28,28,84,80,44,88,24,4,14,21,69,30,31,16,22,20,69,12,24,4,12,80,17,16,21,69,11,5,8,88,31,3,88,4,13,17,3,69,11,21,23,17,21,22,88,25,22,88,17,69,11,25,29,12,24,69,8,17,23,12,80,10,30,80,17,16,21,69,11,1,16,25,2,0,88,31,3,88,4,13,29,80,21,29,2,12,21,21,17,29,2,69,23,22,69,12,24,0,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,67,80,10,10,80,7,1,80,21,13,4,17,17,30,2,88,4,13,29,80,22,13,29,69,23,22,69,12,24,12,11,80,22,29,2,12,29,3,69,29,1,16,25,28,69,12,31,69,11,92,69,17,4,69,16,17,22,88,4,13,29,80,23,25,4,12,23,80,22,9,2,17,80,70,76,88,29,16,20,4,12,8,28,12,29,20,69,26,9,69,11,80,17,23,80,84,88,31,3,88,4,13,29,80,21,29,2,12,21,21,17,29,2,69,12,31,69,12,24,0,88,20,12,25,29,0,12,21,23,86,80,44,88,7,12,20,28,69,11,31,10,22,80,22,16,31,18,88,4,13,25,4,69,12,24,0,88,3,16,21,80,10,30,80,17,16,25,22,88,3,0,10,25,0,11,80,17,23,80,7,29,80,4,8,0,23,23,8,12,21,17,17,29,28,28,88,65,75,78,68,81,65,67,81,72,70,83,64,68,87,74,70,81,75,70,81,67,80,4,22,20,69,30,2,10,21,80,8,13,28,17,17,0,9,1,25,11,31,80,17,16,25,22,88,30,16,21,18,0,10,80,7,1,80,22,17,8,73,88,17,11,28,80,17,16,21,11,88,4,4,19,25,11,31,80,17,16,21,69,11,1,16,25,2,0,88,2,10,23,4,73,88,4,13,29,80,11,13,29,7,29,2,69,75,94,84,76,65,80,65,66,83,77,67,80,64,73,82,65,67,87,75,72,69,17,3,69,17,30,1,29,21,1,88,0,23,23,20,16,27,21,1,84,80,18,16,25,6,16,80,0,0,0,23,29,3,22,29,3,69,12,24,0,88,0,0,10,25,8,29,4,0,10,80,10,30,80,4,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,86,80,35,23,28,9,23,7,12,22,23,69,25,23,4,17,30,69,12,24,0,88,3,4,21,21,69,11,4,0,8,3,69,26,9,69,15,24,12,27,24,69,49,80,13,25,20,69,25,2,23,17,6,0,28,80,4,12,80,17,16,25,22,88,3,16,21,92,69,49,80,13,25,6,0,88,20,12,11,19,10,14,21,23,29,20,69,12,24,4,12,80,17,16,21,69,11,5,8,88,31,3,88,4,13,29,80,22,29,2,12,29,3,69,73,80,78,88,65,74,73,70,69,83,80,84,87,72,84,88,91,69,73,95,87,77,70,69,83,80,84,87,70,87,77,80,78,88,21,17,27,94,69,25,28,22,23,80,1,29,0,0,22,20,22,88,31,11,88,4,13,29,80,20,13,17,1,10,17,17,13,2,0,88,31,3,88,4,13,29,80,6,17,2,6,20,21,75,88,62,4,21,21,9,1,92,69,12,24,0,88,3,16,21,80,10,30,80,17,16,25,22,88,29,16,20,4,12,8,28,12,29,20,69,26,9,69,65,64,69,31,25,19,29,3,69,12,24,0,88,18,12,9,5,4,28,2,4,12,21,69,80,22,10,13,2,17,16,80,21,23,7,0,10,89,69,23,22,69,12,24,0,88,19,12,10,19,16,21,22,0,10,21,11,27,21,69,23,22,69,12,24,0,88,0,0,10,25,8,29,4,0,10,80,10,30,80,4,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,86,80,36,22,20,69,26,9,69,11,25,8,17,28,4,10,80,23,29,17,22,23,30,12,22,23,69,49,80,13,25,6,0,88,28,12,19,21,18,17,3,0,88,18,0,29,30,69,25,18,9,29,80,17,23,80,1,29,4,0,10,29,12,22,21,69,12,24,0,88,3,16,21,3,69,23,22,69,12,24,0,88,3,16,26,3,0,9,5,0,22,4,69,11,21,23,17,21,22,88,25,11,88,7,13,17,19,13,88,4,13,29,80,0,0,0,10,22,21,11,12,3,69,25,2,0,88,21,19,29,30,69,22,5,8,26,21,23,11,94
#+end_src

#+begin_src odin :main no :comments link :tangle src/xor_decryption.odin
package xor_decryption

import "core:os"
import "core:fmt"
import "core:mem"
import "core:strings"
import "core:strconv"
import "vendor:raylib"

MENU_RECT :: raylib.Rectangle{250, 10, 240, 150}

Values :: struct {
	show_menu         : bool,
	width             : int,
	height            : int,
	abc               : int `3317`, // index into aaa-zzz
	abcs              : [3]u8 `exp`,
	percent_printable : f32 `.98`,
	accum_ascii       : uint,
}

set_abcs :: proc(values: ^Values) {
	tmp := values.abc
	// values.abc to base 26
	ch_arr := []rune{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}
	rem  : int
	quot : int = 1
	str := ""
	for ; quot != 0; {
		rem  = tmp % 26
		quot = tmp / 26
		tmp = quot
		str = fmt.tprintf("%s%c", str, ch_arr[rem])
	}
	for ; len(str) < 3; {
		str = fmt.tprintf("%s%c", str, 'a')
	}
	str2 := strings.reverse(str); defer delete(str2)
	values.abcs[0] = str2[0]
	values.abcs[1] = str2[1]
	values.abcs[2] = str2[2]
}

draw_menu :: proc(values: ^Values) {
  using raylib

  menu_rect := MENU_RECT
  menu_rect.x = f32(values.width) - menu_rect.x
  if !values.show_menu {
    values.show_menu = GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")
  } else {
    panel := GuiPanel(menu_rect, "")
    values.show_menu = !GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")

	  tmp_abc := f32(values.abc)
    GuiSlider(Rectangle{f32(values.width) - 185, 40, 160, 20}, "abc key", "", &tmp_abc, 0, 17575)
	  values.abc = int(tmp_abc)
    str := fmt.tprintf("%v", values.abc)
    cstr := strings.clone_to_cstring(str)
    GuiTextBox(Rectangle{f32(values.width) - 185, 40, 160, 20}, cstr, 10, false)
	  delete(cstr)

    GuiSlider(Rectangle{f32(values.width) - 185, 65, 160, 20}, "printable %", "", &values.percent_printable, 0, 1)
    str = fmt.tprintf("%v", values.percent_printable)
    cstr = strings.clone_to_cstring(str)
    GuiTextBox(Rectangle{f32(values.width) - 185, 65, 160, 20}, cstr, 10, false)
	  delete(cstr)
	  
	  set_abcs(values)
	  str2 := fmt.tprintf("%c%c%c", values.abcs[0], values.abcs[1], values.abcs[2])
    cstr = strings.clone_to_cstring(str2)
	  GuiLabel(Rectangle{f32(values.width) - 185, 90, 160, 20}, cstr)
	  delete(cstr)

	  str2 = fmt.tprintf("accum_ascii %v", values.accum_ascii)
    cstr = strings.clone_to_cstring(str2)
	  GuiLabel(Rectangle{f32(values.width) - 185, 115, 160, 20}, cstr)
	  delete(cstr)
  }
}

draw_cypher_text :: proc(values: ^Values, txt: []u8) {
	using raylib

	text_1 := make([]u8, len(txt)); defer delete(text_1)

	values.accum_ascii = 0
	for c,i in txt {
		text_1[i] = c ~ u8(values.abcs[i % 3])
		values.accum_ascii += uint(text_1[i])
	}
	
	text := strings.string_from_ptr(&text_1[0], len(text_1))
	lines, err := strings.split(text, "\n")
	y := 0
	text_2 : cstring
	for l in lines {
		ll := l
		tmp := int(values.width/10)
		for ; len(ll) > tmp; {
			lc := ll[0:tmp]
			ll = ll[tmp:]

			text_2 = strings.clone_to_cstring(lc)
			DrawTextEx(GetFontDefault(), text_2, Vector2{0,f32(y)}, 10, 1, BLACK)
			delete(text_2)
			y += 10
		}
		text_2 = strings.clone_to_cstring(ll)
		DrawTextEx(GetFontDefault(), text_2, Vector2{0,f32(y)}, 10, 1, BLACK)
		delete(text_2)
	}
	delete(lines)
}

find_probable_abc :: proc(values: ^Values, txt: []u8, up_down: int) {
	text_1 := make([]u8, len(txt)+1); defer delete(text_1)
	text_1[len(txt)] = 0

	cnt := 0
	cnt_tries := 0

	for ; values.percent_printable > (f32(cnt) / f32(len(txt))) && cnt_tries < 1000; {
		values.abc += up_down
		if values.abc < 0 do values.abc = 0
		set_abcs(values)
		cnt = 0
		
		for c,i in txt {
			text_1[i] = c ~ u8(values.abcs[i % 3])
			if text_1[i] == ' ' || text_1[i] == '.' ||
				text_1[i] == ',' || text_1[i] == '?' ||
				text_1[i] == '!' || text_1[i] == ';' ||
				text_1[i] == '-' || text_1[i] == '(' ||
				text_1[i] == ')' || text_1[i] == '\'' ||
				(text_1[i] >= '0' && text_1[i] <= '9') ||
				(text_1[i] >= 'a' && text_1[i] <= 'z') ||
				(text_1[i] >= 'A' && text_1[i] <= 'Z') {
				cnt += 1
			}
		}
		cnt_tries += 1
		fmt.println(f32(cnt) / f32(len(txt)))
	}
}

main :: proc() {
	using raylib

	ta := mem.Tracking_Allocator{};
	mem.tracking_allocator_init(&ta, context.allocator);
	context.allocator = mem.tracking_allocator(&ta);

	{
		values : Values
		values.width = 500
		values.height = 500
		values.abc = 3317
		values.percent_printable = 0.98
		set_abcs(&values)

		cypher_text_csv, ok := os.read_entire_file("0059_ciper.txt"); defer delete(cypher_text_csv)
		if !ok {
			fmt.println("no 0059_ciper.txt file!")
			return
		}
		// convert cvs into into string
		clines, err := strings.split(string(cypher_text_csv), ",")
		cypher_text := make([]u8, len(clines)); defer delete(cypher_text)

		for cl,idx in clines {
			c, ok := strconv.parse_int(cl)
			cypher_text[idx] = u8(c)
		}
		delete(clines)		

		SetWindowState(ConfigFlags{ConfigFlag.WINDOW_RESIZABLE})
		InitWindow(i32(values.width), i32(values.height), "Window_Title")
		SetTargetFPS(60)

		for !WindowShouldClose() {
			// Update ------------------------------
			values.width = int(GetScreenWidth())
			values.height = int(GetScreenHeight())

			if IsKeyPressed(KeyboardKey.LEFT) {
				find_probable_abc(&values, cypher_text, -1)
			} else if IsKeyPressed(KeyboardKey.RIGHT) {
				find_probable_abc(&values, cypher_text, 1)
			}

			// Draw   ------------------------------
			BeginDrawing()
			ClearBackground(BLUE)
			
			draw_cypher_text(&values, cypher_text)
			
			draw_menu(&values)
			EndDrawing()
		}
		CloseWindow()
	}

	if len(ta.allocation_map) > 0 {
		for _, v in ta.allocation_map {
			fmt.printf("Leaked %v bytes @ %v\n", v.size, v.location);
		}
	}
	if len(ta.bad_free_array) > 0 {
		fmt.println("Bad frees:");
		for v in ta.bad_free_array {
			fmt.println(v);
		}
	}
}
#+end_src

* Prob 060 - Prime Pair Sets
The primes $3$, $7$, $109$, and $673$, are quite remarkable. By taking any two
primes and concatenating them in any order the result will always be prime. For
example, taking $7$ and $109$, both $7109$ and $1097$ are prime. The sum of
these four primes, $792$, represents the lowest sum for a set of four primes
with this property.

Find the lowest sum for a set of five primes for which any two primes
concatenate to produce another prime.

#+begin_src odin :main no :comments link :tangle src/prime_pair_sets.odin
package prime_pair_sets

import "core:fmt"
import "core:strconv"
import "../util"

get_new_choose_four :: proc(new_prime: int) -> [dynamic][4]int {
	CN :: struct {
		one  : [dynamic][1]int,
		two  : [dynamic][2]int,
		thr  : [dynamic][3]int,
	}
	@static last_choose_n  : CN
	@static new_ones_added : [dynamic][4]int

	if len(last_choose_n.one) == 0 {
		append(&last_choose_n.one, [1]int{2}) // setup initial prime lists
		append(&last_choose_n.one, [1]int{3})
		append(&last_choose_n.one, [1]int{5})
		
		append(&last_choose_n.two, [2]int{2,3})
		append(&last_choose_n.two, [2]int{2,5})
		append(&last_choose_n.two, [2]int{3,5})
		
		append(&last_choose_n.thr, [3]int{2,3,5})
	}

	clear(&new_ones_added)
	for i,ii in last_choose_n.thr {
		tmp := new([4]int)
		for _,j in i {
			tmp^[j] = last_choose_n.thr[ii][j]
		}
		tmp[3] = new_prime
		append(&new_ones_added, tmp^)
	}

	// update last_choose_n lists
	for i,ii in last_choose_n.two {
		tmp := new([3]int)
		for _,j in i {
			tmp^[j] = last_choose_n.two[ii][j]
		}
		tmp[2] = new_prime
		// here the magic sauce, if some primes don't work ex: [2,3] which makes 32, don't keep them around they'll never work
		if any_two_concat_primes_is_prime(tmp[:]) {
			append(&last_choose_n.thr, tmp^)
		}
	}
	for i,ii in last_choose_n.one {
		tmp := new([2]int)
		for _,j in i {
			tmp^[j] = last_choose_n.one[ii][j]
		}
		tmp[1] = new_prime
		if any_two_concat_primes_is_prime(tmp[:]) {
			append(&last_choose_n.two, tmp^)
		}
	}
	append(&last_choose_n.one, [1]int{new_prime})
	
	return new_ones_added
}

get_new_choose_five :: proc(new_prime: int) -> [dynamic][5]int {
	CN :: struct {
		one  : [dynamic][1]int,
		two  : [dynamic][2]int,
		thr  : [dynamic][3]int,
		four : [dynamic][4]int,
	}
	@static last_choose_n  : CN
	@static new_ones_added : [dynamic][5]int

	//| n4 | [1],[2],[3],[4]     | [1,2],[1,3],[1,4],[2,3],[2,4],[3,4]                           | [1,2,3],[1,2,4],[1,3,4],[2,3,4]                                                   | [1,2,3,4]
	if len(last_choose_n.one) == 0 {
		append(&last_choose_n.one, [1]int{2}) // setup initial prime lists
		append(&last_choose_n.one, [1]int{3})
		append(&last_choose_n.one, [1]int{5})
		append(&last_choose_n.one, [1]int{7})
		
		append(&last_choose_n.two, [2]int{2,3})
		append(&last_choose_n.two, [2]int{2,5})
		append(&last_choose_n.two, [2]int{2,7})
		append(&last_choose_n.two, [2]int{3,5})
		append(&last_choose_n.two, [2]int{3,7})
		append(&last_choose_n.two, [2]int{5,7})
		
		append(&last_choose_n.thr, [3]int{2,3,5})
		append(&last_choose_n.thr, [3]int{2,3,7})
		append(&last_choose_n.thr, [3]int{2,5,7})
		append(&last_choose_n.thr, [3]int{3,5,7})

		append(&last_choose_n.four, [4]int{2,3,5,7})
	}

	clear(&new_ones_added)
	for i,ii in last_choose_n.four {
		tmp := new([5]int)
		for _,j in i {
			tmp^[j] = last_choose_n.four[ii][j]
		}
		tmp[4] = new_prime
		append(&new_ones_added, tmp^)
	}

	// update last_choose_n lists
	for i,ii in last_choose_n.thr {
		tmp := new([4]int)
		for _,j in i {
			tmp^[j] = last_choose_n.thr[ii][j]
		}
		tmp[3] = new_prime
		if any_two_concat_primes_is_prime(tmp[:]) {
			append(&last_choose_n.four, tmp^)
		}
	}
	for i,ii in last_choose_n.two {
		tmp := new([3]int)
		for _,j in i {
			tmp^[j] = last_choose_n.two[ii][j]
		}
		tmp[2] = new_prime
		if any_two_concat_primes_is_prime(tmp[:]) {		
			append(&last_choose_n.thr, tmp^)
		}
	}
	for i,ii in last_choose_n.one {
		tmp := new([2]int)
		for _,j in i {
			tmp^[j] = last_choose_n.one[ii][j]
		}
		tmp[1] = new_prime
		if any_two_concat_primes_is_prime(tmp[:]) {
			append(&last_choose_n.two, tmp^)
		}
	}
	append(&last_choose_n.one, [1]int{new_prime})
	
	// [1,2,3,4]                                           |             |
	// [1,2,3,4] + [1,2,3,5],[1,2,4,5],[1,3,4,5],[2,3,4,5] | [1,2,3,4,5] |
	
	return new_ones_added
}

any_two_concat_primes_is_prime :: proc(primes: []int) -> bool {
	combos : [dynamic][]int; defer delete(combos)
	util.get_combinations(primes, 2, &combos)
	for i in combos {
		pstr := fmt.tprintf("%v%v", i[0], i[1])
		p,_ := strconv.parse_int(pstr)
		if !util.is_prime(p) {
			return false
		}
		pstr = fmt.tprintf("%v%v", i[1], i[0])
		p,_ = strconv.parse_int(pstr)
		if !util.is_prime(p) {
			return false
		}
	}

	return true
}

main :: proc() {
	//mprimes := []int{3,7,109,673}
	//fmt.println("derp", any_two_concat_primes_is_prime(mprimes))

	// UGGG.. this is soooo slow, but will eventually find the 5 primes in question.. last one is 8389
	// maybe convert primes to strings before hand... TODO
	BELOW :: 10000
	for i in 9..<BELOW {
		if util.is_prime(i) {
			tmp := get_new_choose_five(i)
			for &j in tmp {
				if any_two_concat_primes_is_prime(j[:]) {
					fmt.println(j)
				}
			}
		}
	}
}
#+end_src

* Prob 061 - Cyclical Figurate Numbers
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

| Triangle   | $1, 3, 6, 10, 15, \dots$  | $P_{3,n}=n(n+1)/2$  |
| Square     | $1, 4, 9, 16, 25, \dots$  | $P_{4,n}=n^2$       |
| Pentagonal | $1, 5, 12, 22, 35, \dots$ | $P_{5,n}=n(3n-1)/2$ |
| Hexagonal  | $1, 6, 15, 28, 45, \dots$ | $P_{6,n}=n(2n-1)$   |
| Heptagonal | $1, 7, 18, 34, 55, \dots$ | $P_{7,n}=n(5n-3)/2$ |
| Octagonal  | $1, 8, 21, 40, 65, \dots$ | $P_{8,n}=n(3n-2)$   |

The ordered set of three *4*-digit numbers: $8128$, $2882$, $8281$, has three
interesting properties.

1) The set is cyclic, in that the last two digits of each number is the first
   two digits of the next number (including the last number with the first).
2) Each polygonal type: triangle ($P_{3,127}=8128$), square ($P_{4,91}=8281$), and
   pentagonal ($P_{5,44}=2882$), is represented by a different number in the set.
3) This is the only set of *4*-digit numbers with this property.

Find the sum of the only ordered set of six cyclic *4*-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.

#+begin_src odin :main no :comments link :tangle src/cyclical_figurate_numbers.odin
package cyclical_figurate_numbers

import "core:fmt"
import "core:mem"
import "core:strings"
import "core:strconv"
import "core:reflect"
import "core:math/big"
import "../util"

IntString :: struct {
	num : int,    // some num xxyy
	xx  : string, // first 2 chars
	yy  : string, // second 2
}
PolygonNumbers :: struct {
	tri: map[string][dynamic]IntString, // triangle (map "xx" -> list of nums)
	squ: map[string][dynamic]IntString, // square
	pen: map[string][dynamic]IntString, // pentagon
	hex: map[string][dynamic]IntString, // hexagon
	hep: map[string][dynamic]IntString, // heptagon
	oct: map[string][dynamic]IntString, // octagon
}

// one way to make the 6 lists of polygon numbers is to note that
// triangle numbers can start the list n(n+1)/2:
//1, 2,  3,  4,  5,  6
//1, 3,  6, 10, 15, 21
//1, 4,  9, 16, 25, 36
//1, 5, 12, 22, 35, 51
//1, 6, 15, 28, 45, 66
//1, 7, 18, 34, 55, 81
//1, 8, 21, 40, 65, 96
// but then it's +0 +3 +6 +10 +15 etc... down the line/columns (which is the triangle numbers!)
make_numbers :: proc(pn: ^PolygonNumbers) {
	// numbers should be between 1000 & 9999
	// so n(n+1)/2 ~= 1000  n(n+1) ~= 2000... sqrt(2000)?
	// but oct should have smaller tri's to start it off?.. so, not 44ish
	START :: 19
	END :: 140
	//START :: 1
	//END :: 6
	prev_tri : int = (START-1)*(START)/2

	names := reflect.struct_field_names(PolygonNumbers)
	for i in START..=END {
		tri := IntString{i*(i+1)/2, "", ""}
		tmp := tri.num
		for idx:=0; idx<len(names); idx+=1 {
			sf := reflect.struct_field_at(PolygonNumbers, idx)
			if idx != 0 {
				tri.num += prev_tri
			}
			tstr := fmt.tprintf("%04d", tri.num)
			tri.xx = tstr[0:2]
			tri.yy = tstr[2:4]
			if tri.num > 1_000 && tri.num < 10_000 {
			//if tri.num > 0 && tri.num < 10_000 {
				ptr := rawptr(uintptr(pn) + sf.offset)
				poly_map := cast(^map[string][dynamic]IntString)ptr
				if !(tri.xx in poly_map) {
					poly_map[tri.xx] = nil // create map for this xx
				}
				//fmt.println("adding", tri.num, "to", sf.name, i)
				append(&poly_map[tri.xx], tri)
			}
		}
		prev_tri = tmp
	}
}

main :: proc() {

	pn : PolygonNumbers
	make_numbers(&pn)
	
	// pattern will look like: xxyy yyzz zzxx
	// and one tri, squ and pentagon.. no dups

	names := reflect.struct_field_names(PolygonNumbers)
	//for idx:=0; idx<len(names); idx+=1 {
	//	sf := reflect.struct_field_at(PolygonNumbers, idx)
	//	ptr := rawptr((uintptr(&pn) + sf.offset))
	//	fmt.println(sf.name, cast(^map[string][dynamic]IntString)ptr)
	//}

	// find in certain order::  tri, squ, pen... or tri, pen, squ
	find_in_order :: proc(tr: IntString, squ, pen, hex, hep, oct: map[string][dynamic]IntString) -> bool {
		// squ, pen, hex, hep, oct
		if tr.yy in squ { // tri, squ, pen
			for sq in squ[tr.yy] {
				if sq.num == tr.num do continue
				if sq.yy in pen {
					for pe in pen[sq.yy] {
						if pe.num == sq.num do continue
						if hex == nil {
							if pe.yy == tr.xx {
								fmt.println("found", tr.num, sq.num, pe.num)
								return true
							}
						}
						if pe.yy in hex {
							for hexx in hex[pe.yy] {
								if hexx.num == pe.num do continue
								if hexx.yy in hep {
									for he in hep[hexx.yy] {
										if pe.num == he.num do continue
										if he.yy in oct {
											for oc in oct[he.yy] {
												if oc.num == he.num do continue
												if oc.yy == tr.xx {
													fmt.println("found", tr.num, sq.num, pe.num, hexx.num, he.num, oc.num)
													return true
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return false
	}

	CONSIDER :: 5
	ret := new([dynamic]string)
	if CONSIDER == 5 {
		util.permute(strings.clone("12345"), 0,4, ret)
	} else {
		util.permute(strings.clone("12"), 0,1, ret)
	}
	
	for order in ret {
		onums : [CONSIDER]int
		for i in 0..<CONSIDER {
			onums[i],_ = strconv.parse_int(order[i+0:i+1])
		}
		// squ, pen, hex, hep, oct
		sf_at : [CONSIDER]reflect.Struct_Field
		pn_order : [CONSIDER]^map[string][dynamic]IntString
		for i in 0..<CONSIDER {
			sf_at[i] = reflect.struct_field_at(PolygonNumbers, onums[i])
			ptr := rawptr(uintptr(&pn) + sf_at[i].offset)
			pn_order[i] = cast(^map[string][dynamic]IntString)ptr
		}
		
		for trik, triv in pn.tri {
			for tr in triv {
				
				//if find_in_order(tr, pn_order[0]^, pn_order[1]^, nil, nil, nil) {	return }
				if find_in_order(tr, pn_order[0]^, pn_order[1]^, pn_order[2]^, pn_order[3]^, pn_order[4]^) do return
				
			}
		}
	}
}
#+end_src

* Prob 062 - Cubic Permutations
The cube, $41063625$ ($345^3$), can be permuted to produce two other cubes:
$56623104$ ($384^3$) and $66430125$ ($405^3$). In fact, $41063625$ is the
smallest cube which has exactly three permutations of its digits which are also
cube.

Find the smallest cube for which exactly five permutations of its digits are
cube.

#+begin_src odin :main no :comments link :tangle src/cubic_permutations.odin
package cubic_permutations

import "core:fmt"
import "core:slice"
import "core:math/big"
import "../util"

SomeCubed :: struct {
	base: int,
	num: ^big.Int,
}

cubed :: proc(n: int, sc: ^SomeCubed) {
	if sc.num == nil {
		sc.num = new(big.Int)
	}
	sc.base = n
	big.int_pow_int(sc.num, n, 3)
}

main :: proc() {
	PERMUTATIONS :: 5
	START :: 345

	the_cubes : map[string][dynamic]SomeCubed

	for i:=START; ; i+=1 {
		tmp : SomeCubed
		cubed(i, &tmp)
		str, err := big.itoa(tmp.num)
		if err == .Okay {
			// sort digits
			str2 := make([]u8, len(str))
			copy(str2,str)
			slice.sort(str2)
			// put in map and test if some number is reached
			str3 := string(str2)
			if !(str3 in the_cubes) {
				the_cubes[str3] = nil
			}
			append(&the_cubes[str3], tmp)
			
			if len(the_cubes[str3]) >= PERMUTATIONS {
				fmt.println("found!")
				for j in 0..<PERMUTATIONS {
					tmp2 := the_cubes[str3]
					str,_ = big.itoa(tmp2[j].num)
					fmt.println(tmp2[j].base, str)
				}
				break
			}
		}
		
	}
}
#+end_src

* Prob 063 - Powerful Digit Counts
The *5*-digit number, $16807=7^5$, is also a fifth power. Similarly, the
*9*-digit number, $134217728=8^9$, is a ninth power.

How many *n*-digit positive integers exist which are also an *n* th power?

#+begin_src odin :main no :comments link :tangle src/powerful_digit_counts.odin
package powerful_digit_counts

import "core:fmt"
import "core:math"
import "core:math/big"

main :: proc() {

	cnt := 0
	for base := 1; base <= 9; base +=1 { // i didn't think 1 to 9 would work at first, but it kinda makes sense, got lucky here
		for exp := 0; exp <=29; exp += 1 { // this range i just guessed
			num := new(big.Int)
			big.int_pow_int(num, base, exp)
			str,_ := big.itoa(num)
			if len(str) == exp {
				fmt.println("found", base, exp, str)
				cnt += 1
			}
		}
	}
	fmt.println(cnt)
	
}
#+end_src

* Prob 064 - Odd Period Square Roots
All square roots are periodic when written as continued fractions and can be
written in the form:
$\displaystyle \quad \quad \sqrt{N}=a_0+\frac 1 {a_1+\frac 1 {a_2+ \frac 1 {a3+ \dots}}}$

For example, let us consider $\sqrt{23}:$  note: 23 > 4^2 = 16 and 23 is <
5^2=25.. so take the 4:

$\quad \quad \sqrt{23}=4+\sqrt{23}-4=4+\frac 1 {\frac 1 {\sqrt{23}-4}}=4+\frac 1
{1+\frac{\sqrt{23}-3}7}$


If we continue we would get the following expansion:
$\displaystyle \quad \quad \sqrt{23}=4+\frac 1 {1+\frac 1 {3+ \frac 1 {1+\frac 1 {8+ \dots}}}}$

The process can be summarised as follows:

- $\quad \quad a_0=4, \frac 1 {\sqrt{23}-4}=\frac {\sqrt{23}+4} 7=1+\frac {\sqrt{23}-3} 7$
- $\quad \quad a_1=1, \frac 7 {\sqrt{23}-3}=\frac {7(\sqrt{23}+3)} {14}=3+\frac {\sqrt{23}-3} 2$
- $\quad \quad a_2=3, \frac 2 {\sqrt{23}-3}=\frac {2(\sqrt{23}+3)} {14}=1+\frac {\sqrt{23}-4} 7$
- $\quad \quad a_3=1, \frac 7 {\sqrt{23}-4}=\frac {7(\sqrt{23}+4)} 7=8+\sqrt{23}-4$
- $\quad \quad a_4=8, \frac 1 {\sqrt{23}-4}=\frac {\sqrt{23}+4} 7=1+\frac {\sqrt{23}-3} 7$
- $\quad \quad a_5=1, \frac 7 {\sqrt{23}-3}=\frac {7 (\sqrt{23}+3)} {14}=3+\frac {\sqrt{23}-3} 2$
- $\quad \quad a_6=3, \frac 2 {\sqrt{23}-3}=\frac {2(\sqrt{23}+3)} {14}=1+\frac {\sqrt{23}-4} 7$
- $\quad \quad a_7=1, \frac 7 {\sqrt{23}-4}=\frac {7(\sqrt{23}+4)} {7}=8+\sqrt{23}-4$

It can be seen that the sequence is repeating. For conciseness, we use the
notation $\sqrt{23}=[4;(1,3,1,8)]$, to indicate that the block (1,3,1,8) repeats
indefinitely.

The first ten continued fraction representations of (irrational) square roots
are:
| $\quad \quad \sqrt{2}=[1;(2)]$ |  period=$1$          |
| $\quad \quad \sqrt{3}=[1;(1,2)]$ |  period=$2$        |
| $\quad \quad \sqrt{5}=[2;(4)]$ |  period=$1$          |
| $\quad \quad \sqrt{6}=[2;(2,4)]$ |  period=$2$        |
| $\quad \quad \sqrt{7}=[2;(1,1,1,4)]$ |  period=$4$    |
| $\quad \quad \sqrt{8}=[2;(1,4)]$  |  period=$2$        |
| $\quad \quad \sqrt{10}=[3;(6)]$ |  period=$1$         |
| $\quad\quad \sqrt{11}=[3;(3,6)]$  |  period=$2$       |
| $\quad\quad \sqrt{12}=[3;(2,6)]$ |  period=2         |
| $\quad\quad \sqrt{13}=[3;(1,1,1,1,6)]$ |  period=$5$ |

Exactly four continued fractions, for $N \le 13$, have an odd period.
How many continued fractions for $N \le 10\,000$ have an odd period?

see prob 57.. it's similar

#+begin_src odin :main no :comments link :tangle src/odd_period_square_roots.odin
package odd_period_square_roots

import "core:fmt"
import "core:math"
import "core:math/big"
import "../util"

get_sqrt_n_approx :: proc(n: int) -> (int, bool) {
	// ex: 23 is between 16 and 25 (4^2 and 5^2)
	MAXI :: 10_000
	for i:=0; ; i+=1 {
		if i == MAXI do return -1, false // error
		tmp := int(math.pow_f64(f64(i), 2))
		if tmp > n {
			return i-1, false
		} else if tmp == n {
			return i, true // is perfect square
		}
	}
}

// continued fractional representation
sqrt_n_cont_fractional :: proc(expansion_level: int, n: int, a: ^[dynamic]int) -> bool {
	el := expansion_level
	if el <= 0 do return false
	clear(a)
	sq, perfect := get_sqrt_n_approx(n)
	append(a, sq) // set. a[0]
	if perfect do return true

	nom : int = a[0] // expansion_level 0
	denom : int = 1
	for i in 1..=el {
		nom, denom = denom, nom // swap

		if i != el {
			sqr := int(math.pow_f64(f64(denom), 2))
			tmp := n - sqr
			assert(tmp!=0)

			tmp1 := nom * (a[0]+denom) / tmp // new a[x] calc
			if (i > 1 && tmp1 == a[i-1] && nom == 1 && denom == a[0]) {
				return false // ummmm... 2 and 5 ish numbers? this feels hacky
			}
			append(a, tmp1)

			prev_nom := nom
			nom = -((-a[i]*tmp) + (nom*denom))
			denom = tmp
			gcd := math.gcd(nom, denom)
			gcd = math.gcd(gcd, prev_nom)
			
			if gcd > 1 {
				nom /= gcd
				denom /= gcd

				if denom == 1 {
					return false
				}
			}
		}
	}
	return false
}

main :: proc() {
	a : [dynamic]int
	odd_periods := 0

	for j in 2..=10_000 {
		perfect := sqrt_n_cont_fractional(10000, j, &a)
    if false && !perfect {
			fmt.printf("%d = [%d;(", j, a[0])
			for i in 1..<len(a) {
				if i == 1 {
					fmt.printf("%d", a[i])
				} else {
					fmt.printf(",%d", a[i])
				}
			}
			fmt.printf(")] period=%d\n", len(a)-1)
		}
		if (len(a)-1) % 2 == 1 {
			odd_periods += 1
		}
	}
	fmt.println(odd_periods)
}
#+end_src

#+RESULTS:
: 1322

* Prob 065 - Convergents of e
** prob p65
The square root of $2$ can be written as an infinite continued fraction.
$\sqrt{2} = 1 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + ...}}}}$

The infinite continued fraction can be written, $\sqrt{2} = [1; (2)]$, $(2)$
indicates that $2$ repeats /ad infinitum/. In a similar way,
$\sqrt{23} = [4; (1, 3, 1, 8)]$.

It turns out that the sequence of partial values of continued fractions for
square roots provide the best rational approximations. Let us consider the
convergents for $\sqrt{2}$.

| $1 + \dfrac{1}{2} = \dfrac{3}{2}$                                                |
| $1 + \dfrac{1}{2 + \dfrac{1}{2}} = \dfrac{7}{5}$                                 |
| $1 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2}}} = \dfrac{17}{12}$                |
| $1 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2}}}} = \dfrac{41}{29}$ |

Hence the sequence of the first ten convergents for $\sqrt{2}$ are:
$$1, \dfrac{3}{2}, \dfrac{7}{5}, \dfrac{17}{12}, \dfrac{41}{29}, \dfrac{99}{70},
\dfrac{239}{169}, \dfrac{577}{408}, \dfrac{1393}{985}, \dfrac{3363}{2378}, ...$$

What is most surprising is that the important mathematical constant,

$e = [2;1, 2, 1, 1, 4, 1, 1, 6, 1, ... , 1, 2k, 1, ...]$.

The first ten terms in the sequence of convergents for $e$ are:
$$2, 3, \dfrac{8}{3}, \dfrac{11}{4}, \dfrac{19}{7}, \dfrac{87}{32}, \dfrac{106}{39}, \dfrac{193}{71}, \dfrac{1264}{465}, \dfrac{1457}{536}, ...$$

numerator here           ^ ... or the 1457... last numerator
how do you make convergents, giving a continued fraction?
and/or
is there a formula for the continued fraction of e?

The sum of digits in the numerator of the $10^{th}$ convergent is
$1 + 4 + 5 + 7 = 17$.

Find the sum of digits in the numerator of the $100^{th}$ convergent of the continued fraction for $e$.

so $$e^x = \dfrac{x^0}{0!} + \dfrac{x^1}{1!} + \dfrac{x^2}{2!}...$$
or $e^x = 1 + \dfrac{x}{1 - \dfrac{1x}{2 + x - \dfrac{2x}{3 + x - \dfrac{3x}{4 + x
-}}}}$
because of Euler's continued fraction formula that connects a series to a
continued fraction  (note: diagonal dots! (\ddots), i'm super fancy like that):
$$a_0 + a_0a_1 + a_0a_1a_2 + ... = \dfrac{a_0}{1 - \dfrac{a_1}{1 +
\dfrac{a_2}{1 + \dfrac{a3}{1 + \ddots}}}}$$

or super clean looking version, BUT is non-simple:
$$e = 2 + \dfrac{1}{1 + \dfrac{1}{2 + \dfrac{2}{3 + \dfrac{3}{\ddots}}}}$$

for a regular continued fraction:
$$x = b_0 + \dfrac{1}{b_1 + \dfrac{1}{b_2 + \dfrac{1}{\ddots}}}$$
$x = [b_0;b_1,b_2,...]$


$$2, 3, \dfrac{8}{3}, \dfrac{11}{4}, \dfrac{19}{7}, \dfrac{87}{32}, \dfrac{106}{39}, \dfrac{193}{71}, \dfrac{1264}{465}, \dfrac{1457}{536}, ...$$
$$[2;1, 2, 1, 1, 4, 1, 1, 6, 1, ... , 1, 2k, 1, ...]$$.

the convergent is given by the ratio of tridiagonal matrix determinants:
$$\dfrac{A_n}{B_n} = \dfrac{\begin{vmatrix}b_0&-1&0&...&0\\1&b_1&-1&...&0\\0&1&b_2&...&0\\0&0&1&...&-1\\0&0&0&...&b_n\end{vmatrix}}{\begin{vmatrix}b_1&-1&...&0\\1&b_2&...&0\\0&1&...&-1\\0&0&...&b_n\end{vmatrix}}$$

also:
$A_k = b_kA_{k-1 }+ A_{k-2}$
$B_k = b_kB_{k-1 }+ B_{k-2}$

notes:
0 2
1 3
2 8   = 2*3 + 2
3 11  = 1*8 + 3
4 19  = 1*11 + 8
5 87  = 4*19 + 11
6 106 = 1*87 + 19
...

** code p65
#+begin_src odin :main no :comments link :tangle src/convergents_of_e.odin
package convergents_of_e

import "core:fmt"
import "core:strconv"
import "core:math/big"

calc_nth_convergent_numerator_of_e :: proc(n: int) -> ^big.Int {
	A  := new(big.Int)
	big.set(A, 2)
	A1 := new(big.Int); defer free(A1)
	big.set(A1, 2)
	A2 := new(big.Int); defer free(A2)
	big.set(A2, 1)
	k := 1
	for i in 1..<n {
		switch(i % 3) {
		case 1:
			fallthrough
		case 0:
			big.add(A, A1, A2)
		case 2:
			tmp := new(big.Int); defer free(tmp)
			big.set(tmp, (2*k))
			big.mul(A, A1, tmp)
			big.add(A, A, A2)
			k += 1
		}
		big.set(A2, A1)
		big.set(A1, A)
	}
	return A
}

main :: proc() {
	bigNum := calc_nth_convergent_numerator_of_e(100)
	bigNumStr,_ := big.itoa(bigNum) 
	fmt.println(bigNumStr)
	acc := 0
	for c in bigNumStr {
		acc += strconv._digit_value(c)
	}
	fmt.println(acc)
	free(bigNum)
}
#+end_src

* Prob 066 - Diophantine Equation
** prob p66
Consider quadratic Diophantine equations of the form:
$$x^2 - Dy^2 = 1$$

For example, when $D=13$, the minimal solution in $x$ is
$$649^2 - 13 \times 180^2 = 1$$.

It can be assumed that there are no solutions in positive integers when $D$ is
square.

By finding minimal solutions in $x$ for $D = \{2, 3, 5, 6, 7\}$, we obtain the
following:

$$\begin{align}\\
3^2 - 2 \times 2^2 &= 1\\
2^2 - 3 \times 1^2 &= 1\\
{\color{red}{\mathbf 9}}^2 - 5 \times 4^2 &= 1\\
5^2 - 6 \times 2^2 &= 1\\
8^2 - 7 \times 3^2 &= 1
\end{align}$$

Hence, by considering minimal solutions in $x$ for $D \le 7$, the largest $x$ is
obtained when $D=5$.

Find the value of $D \le 1000$ in minimal solutions of $x$ for which the largest
value of $x$ is obtained.

** code p66
#+begin_src odin :main no :comments link :tangle src/diophantine_equation.odin
package diophantine_equation

import "core:fmt"
import "core:math"
import "core:math/big"
import "../util"

calc_nth_convergent :: proc(n: int, a: [dynamic]int) -> (A: ^big.Int) {
	A   = new(big.Int)
	big.set(A, a[0])
	A1 := new(big.Int); defer free(A1)
	big.set(A1, a[0])
	A2 := new(big.Int); defer free(A2)
	big.set(A2, 1)

	for i in 1..<(len(a)-1) {
		tmp := new(big.Int); defer free(tmp)
		big.set(tmp, a[i])

		// A_k = a_i * A_{k-1} + A_{k-2}
		big.mul(A, A1, tmp)
		big.add(A, A, A2)

		big.set(A2, A1)
		big.set(A1, A)
	}
	return
}

get_sqrt_n_approx :: proc(n: int) -> (int, bool) {
	// ex: 23 is between 16 and 25 (4^2 and 5^2)
	MAXI :: 10_000
	for i:=0; ; i+=1 {
		if i == MAXI do return -1, false // error
		tmp := int(math.pow_f64(f64(i), 2))
		if tmp > n {
			return i-1, false
		} else if tmp == n {
			return i, true // is perfect square
		}
	}
}

// continued fractional representation
sqrt_n_cont_fractional :: proc(expansion_level: int, n: int, a: ^[dynamic]int) -> bool {
	el := expansion_level
	if el <= 0 do return false
	clear(a)
	sq, perfect := get_sqrt_n_approx(n)
	append(a, sq) // set. a[0]
	if perfect do return true

	nom : int = a[0] // expansion_level 0
	denom : int = 1
	for i in 1..=el {
		nom, denom = denom, nom // swap

		if i != el {
			sqr := int(math.pow_f64(f64(denom), 2))
			tmp := n - sqr
			assert(tmp!=0)

			tmp1 := nom * (a[0]+denom) / tmp // new a[x] calc
			if (i > 1 && tmp1 == a[i-1] && nom == 1 && denom == a[0]) {
				return false // ummmm... 2 and 5 ish numbers? this feels hacky
			}
			append(a, tmp1)

			prev_nom := nom
			nom = -((-a[i]*tmp) + (nom*denom))
			denom = tmp
			gcd := math.gcd(nom, denom)
			gcd = math.gcd(gcd, prev_nom)
			
			if gcd > 1 {
				nom /= gcd
				denom /= gcd

				if denom == 1 {
					return false
				}
			}
		}
	}
	return false
}

main :: proc() {

	biggest := new(big.Int)
	biggest_n := 0
	
	for num in 2..=1000 {
		
		a : [dynamic]int
		perfect := sqrt_n_cont_fractional(300, num, &a)

		if false {
			fmt.printf("%d = [%d;(", num, a[0])	
			for i in 1..<len(a) {
				if i == 1 {
					fmt.printf("%d", a[i])
				} else {
					fmt.printf(",%d", a[i])
				}
			}
			fmt.printf(")] period=%d\n", len(a)-1)
		}

		if (len(a)-1) % 2 == 0 { // even
			A := calc_nth_convergent(num, a)
			cond, err := big.gt(A, biggest)
			if cond {
				big.set(biggest, A)
				biggest_n = num
			}
		} else {                 // odd
			// repeat a into a
			tmp := len(a)
			for j in 1..<tmp {
				append(&a, a[j])
			}
			A := calc_nth_convergent(num, a)
			cond, err := big.gt(A, biggest)
			if cond {
				big.set(biggest, A)
				biggest_n = num
			}
		}
	}

	biggest_str,_ := big.itoa(biggest)
	fmt.println(biggest_str)
	fmt.println(biggest_n)
}
#+end_src

* Prob 067 - Maximum Path Sum II
** prob p67
By starting at the top of the triangle below and moving to adjacent numbers on
the row below, the maximum total from top to bottom is 23.

$$\begin{matrix}\\
{\color{red}{3}}\\
{\color{red}{7}} \qquad 4\\
2 \qquad {\color{red}{4}} \qquad 6\\
8 \qquad 5 \qquad {\color{red}{9}} \qquad 3\\
\end{matrix}$$

That is, 3 + 7 + 4 + 9 = 23.

Find the maximum total from top to bottom in triangle.txt, a 15K text file
containing a triangle with one-hundred rows.

*NOTE*: This is a much more difficult version of Problem 18. It is not possible to
try every route to solve this problem, as there are 2^{99} altogether!
If you could check one trillion (10^{12}) routes every second it would
take over twenty billion years to check them all. There is an efficient
algorithm to solve it. ;o)

note2: not much changes from Problem 18, just loads triangle from file, instead
of having it hard coded

** triangle.txt
#+begin_verse
change below to begin_src/end_src to tangle poker.txt file
this is here to hide below block in github
#+end_verse
#+begin_verse text :tangle src/triangle.txt
59
73 41
52 40 09
26 53 06 34
10 51 87 86 81
61 95 66 57 25 68
90 81 80 38 92 67 73
30 28 51 76 81 18 75 44
84 14 95 87 62 81 17 78 58
21 46 71 58 02 79 62 39 31 09
56 34 35 53 78 31 81 18 90 93 15
78 53 04 21 84 93 32 13 97 11 37 51
45 03 81 79 05 18 78 86 13 30 63 99 95
39 87 96 28 03 38 42 17 82 87 58 07 22 57
06 17 51 17 07 93 09 07 75 97 95 78 87 08 53
67 66 59 60 88 99 94 65 55 77 55 34 27 53 78 28
76 40 41 04 87 16 09 42 75 69 23 97 30 60 10 79 87
12 10 44 26 21 36 32 84 98 60 13 12 36 16 63 31 91 35
70 39 06 05 55 27 38 48 28 22 34 35 62 62 15 14 94 89 86
66 56 68 84 96 21 34 34 34 81 62 40 65 54 62 05 98 03 02 60
38 89 46 37 99 54 34 53 36 14 70 26 02 90 45 13 31 61 83 73 47
36 10 63 96 60 49 41 05 37 42 14 58 84 93 96 17 09 43 05 43 06 59
66 57 87 57 61 28 37 51 84 73 79 15 39 95 88 87 43 39 11 86 77 74 18
54 42 05 79 30 49 99 73 46 37 50 02 45 09 54 52 27 95 27 65 19 45 26 45
71 39 17 78 76 29 52 90 18 99 78 19 35 62 71 19 23 65 93 85 49 33 75 09 02
33 24 47 61 60 55 32 88 57 55 91 54 46 57 07 77 98 52 80 99 24 25 46 78 79 05
92 09 13 55 10 67 26 78 76 82 63 49 51 31 24 68 05 57 07 54 69 21 67 43 17 63 12
24 59 06 08 98 74 66 26 61 60 13 03 09 09 24 30 71 08 88 70 72 70 29 90 11 82 41 34
66 82 67 04 36 60 92 77 91 85 62 49 59 61 30 90 29 94 26 41 89 04 53 22 83 41 09 74 90
48 28 26 37 28 52 77 26 51 32 18 98 79 36 62 13 17 08 19 54 89 29 73 68 42 14 08 16 70 37
37 60 69 70 72 71 09 59 13 60 38 13 57 36 09 30 43 89 30 39 15 02 44 73 05 73 26 63 56 86 12
55 55 85 50 62 99 84 77 28 85 03 21 27 22 19 26 82 69 54 04 13 07 85 14 01 15 70 59 89 95 10 19
04 09 31 92 91 38 92 86 98 75 21 05 64 42 62 84 36 20 73 42 21 23 22 51 51 79 25 45 85 53 03 43 22
75 63 02 49 14 12 89 14 60 78 92 16 44 82 38 30 72 11 46 52 90 27 08 65 78 03 85 41 57 79 39 52 33 48
78 27 56 56 39 13 19 43 86 72 58 95 39 07 04 34 21 98 39 15 39 84 89 69 84 46 37 57 59 35 59 50 26 15 93
42 89 36 27 78 91 24 11 17 41 05 94 07 69 51 96 03 96 47 90 90 45 91 20 50 56 10 32 36 49 04 53 85 92 25 65
52 09 61 30 61 97 66 21 96 92 98 90 06 34 96 60 32 69 68 33 75 84 18 31 71 50 84 63 03 03 19 11 28 42 75 45 45
61 31 61 68 96 34 49 39 05 71 76 59 62 67 06 47 96 99 34 21 32 47 52 07 71 60 42 72 94 56 82 83 84 40 94 87 82 46
01 20 60 14 17 38 26 78 66 81 45 95 18 51 98 81 48 16 53 88 37 52 69 95 72 93 22 34 98 20 54 27 73 61 56 63 60 34 63
93 42 94 83 47 61 27 51 79 79 45 01 44 73 31 70 83 42 88 25 53 51 30 15 65 94 80 44 61 84 12 77 02 62 02 65 94 42 14 94
32 73 09 67 68 29 74 98 10 19 85 48 38 31 85 67 53 93 93 77 47 67 39 72 94 53 18 43 77 40 78 32 29 59 24 06 02 83 50 60 66
32 01 44 30 16 51 15 81 98 15 10 62 86 79 50 62 45 60 70 38 31 85 65 61 64 06 69 84 14 22 56 43 09 48 66 69 83 91 60 40 36 61
92 48 22 99 15 95 64 43 01 16 94 02 99 19 17 69 11 58 97 56 89 31 77 45 67 96 12 73 08 20 36 47 81 44 50 64 68 85 40 81 85 52 09
91 35 92 45 32 84 62 15 19 64 21 66 06 01 52 80 62 59 12 25 88 28 91 50 40 16 22 99 92 79 87 51 21 77 74 77 07 42 38 42 74 83 02 05
46 19 77 66 24 18 05 32 02 84 31 99 92 58 96 72 91 36 62 99 55 29 53 42 12 37 26 58 89 50 66 19 82 75 12 48 24 87 91 85 02 07 03 76 86
99 98 84 93 07 17 33 61 92 20 66 60 24 66 40 30 67 05 37 29 24 96 03 27 70 62 13 04 45 47 59 88 43 20 66 15 46 92 30 04 71 66 78 70 53 99
67 60 38 06 88 04 17 72 10 99 71 07 42 25 54 05 26 64 91 50 45 71 06 30 67 48 69 82 08 56 80 67 18 46 66 63 01 20 08 80 47 07 91 16 03 79 87
18 54 78 49 80 48 77 40 68 23 60 88 58 80 33 57 11 69 55 53 64 02 94 49 60 92 16 35 81 21 82 96 25 24 96 18 02 05 49 03 50 77 06 32 84 27 18 38
68 01 50 04 03 21 42 94 53 24 89 05 92 26 52 36 68 11 85 01 04 42 02 45 15 06 50 04 53 73 25 74 81 88 98 21 67 84 79 97 99 20 95 04 40 46 02 58 87
94 10 02 78 88 52 21 03 88 60 06 53 49 71 20 91 12 65 07 49 21 22 11 41 58 99 36 16 09 48 17 24 52 36 23 15 72 16 84 56 02 99 43 76 81 71 29 39 49 17
64 39 59 84 86 16 17 66 03 09 43 06 64 18 63 29 68 06 23 07 87 14 26 35 17 12 98 41 53 64 78 18 98 27 28 84 80 67 75 62 10 11 76 90 54 10 05 54 41 39 66
43 83 18 37 32 31 52 29 95 47 08 76 35 11 04 53 35 43 34 10 52 57 12 36 20 39 40 55 78 44 07 31 38 26 08 15 56 88 86 01 52 62 10 24 32 05 60 65 53 28 57 99
03 50 03 52 07 73 49 92 66 80 01 46 08 67 25 36 73 93 07 42 25 53 13 96 76 83 87 90 54 89 78 22 78 91 73 51 69 09 79 94 83 53 09 40 69 62 10 79 49 47 03 81 30
71 54 73 33 51 76 59 54 79 37 56 45 84 17 62 21 98 69 41 95 65 24 39 37 62 03 24 48 54 64 46 82 71 78 33 67 09 16 96 68 52 74 79 68 32 21 13 78 96 60 09 69 20 36
73 26 21 44 46 38 17 83 65 98 07 23 52 46 61 97 33 13 60 31 70 15 36 77 31 58 56 93 75 68 21 36 69 53 90 75 25 82 39 50 65 94 29 30 11 33 11 13 96 02 56 47 07 49 02
76 46 73 30 10 20 60 70 14 56 34 26 37 39 48 24 55 76 84 91 39 86 95 61 50 14 53 93 64 67 37 31 10 84 42 70 48 20 10 72 60 61 84 79 69 65 99 73 89 25 85 48 92 56 97 16
03 14 80 27 22 30 44 27 67 75 79 32 51 54 81 29 65 14 19 04 13 82 04 91 43 40 12 52 29 99 07 76 60 25 01 07 61 71 37 92 40 47 99 66 57 01 43 44 22 40 53 53 09 69 26 81 07
49 80 56 90 93 87 47 13 75 28 87 23 72 79 32 18 27 20 28 10 37 59 21 18 70 04 79 96 03 31 45 71 81 06 14 18 17 05 31 50 92 79 23 47 09 39 47 91 43 54 69 47 42 95 62 46 32 85
37 18 62 85 87 28 64 05 77 51 47 26 30 65 05 70 65 75 59 80 42 52 25 20 44 10 92 17 71 95 52 14 77 13 24 55 11 65 26 91 01 30 63 15 49 48 41 17 67 47 03 68 20 90 98 32 04 40 68
90 51 58 60 06 55 23 68 05 19 76 94 82 36 96 43 38 90 87 28 33 83 05 17 70 83 96 93 06 04 78 47 80 06 23 84 75 23 87 72 99 14 50 98 92 38 90 64 61 58 76 94 36 66 87 80 51 35 61 38
57 95 64 06 53 36 82 51 40 33 47 14 07 98 78 65 39 58 53 06 50 53 04 69 40 68 36 69 75 78 75 60 03 32 39 24 74 47 26 90 13 40 44 71 90 76 51 24 36 50 25 45 70 80 61 80 61 43 90 64 11
18 29 86 56 68 42 79 10 42 44 30 12 96 18 23 18 52 59 02 99 67 46 60 86 43 38 55 17 44 93 42 21 55 14 47 34 55 16 49 24 23 29 96 51 55 10 46 53 27 92 27 46 63 57 30 65 43 27 21 20 24 83
81 72 93 19 69 52 48 01 13 83 92 69 20 48 69 59 20 62 05 42 28 89 90 99 32 72 84 17 08 87 36 03 60 31 36 36 81 26 97 36 48 54 56 56 27 16 91 08 23 11 87 99 33 47 02 14 44 73 70 99 43 35 33
90 56 61 86 56 12 70 59 63 32 01 15 81 47 71 76 95 32 65 80 54 70 34 51 40 45 33 04 64 55 78 68 88 47 31 47 68 87 03 84 23 44 89 72 35 08 31 76 63 26 90 85 96 67 65 91 19 14 17 86 04 71 32 95
37 13 04 22 64 37 37 28 56 62 86 33 07 37 10 44 52 82 52 06 19 52 57 75 90 26 91 24 06 21 14 67 76 30 46 14 35 89 89 41 03 64 56 97 87 63 22 34 03 79 17 45 11 53 25 56 96 61 23 18 63 31 37 37 47
77 23 26 70 72 76 77 04 28 64 71 69 14 85 96 54 95 48 06 62 99 83 86 77 97 75 71 66 30 19 57 90 33 01 60 61 14 12 90 99 32 77 56 41 18 14 87 49 10 14 90 64 18 50 21 74 14 16 88 05 45 73 82 47 74 44
22 97 41 13 34 31 54 61 56 94 03 24 59 27 98 77 04 09 37 40 12 26 87 09 71 70 07 18 64 57 80 21 12 71 83 94 60 39 73 79 73 19 97 32 64 29 41 07 48 84 85 67 12 74 95 20 24 52 41 67 56 61 29 93 35 72 69
72 23 63 66 01 11 07 30 52 56 95 16 65 26 83 90 50 74 60 18 16 48 43 77 37 11 99 98 30 94 91 26 62 73 45 12 87 73 47 27 01 88 66 99 21 41 95 80 02 53 23 32 61 48 32 43 43 83 14 66 95 91 19 81 80 67 25 88
08 62 32 18 92 14 83 71 37 96 11 83 39 99 05 16 23 27 10 67 02 25 44 11 55 31 46 64 41 56 44 74 26 81 51 31 45 85 87 09 81 95 22 28 76 69 46 48 64 87 67 76 27 89 31 11 74 16 62 03 60 94 42 47 09 34 94 93 72
56 18 90 18 42 17 42 32 14 86 06 53 33 95 99 35 29 15 44 20 49 59 25 54 34 59 84 21 23 54 35 90 78 16 93 13 37 88 54 19 86 67 68 55 66 84 65 42 98 37 87 56 33 28 58 38 28 38 66 27 52 21 81 15 08 22 97 32 85 27
91 53 40 28 13 34 91 25 01 63 50 37 22 49 71 58 32 28 30 18 68 94 23 83 63 62 94 76 80 41 90 22 82 52 29 12 18 56 10 08 35 14 37 57 23 65 67 40 72 39 93 39 70 89 40 34 07 46 94 22 20 05 53 64 56 30 05 56 61 88 27
23 95 11 12 37 69 68 24 66 10 87 70 43 50 75 07 62 41 83 58 95 93 89 79 45 39 02 22 05 22 95 43 62 11 68 29 17 40 26 44 25 71 87 16 70 85 19 25 59 94 90 41 41 80 61 70 55 60 84 33 95 76 42 63 15 09 03 40 38 12 03 32
09 84 56 80 61 55 85 97 16 94 82 94 98 57 84 30 84 48 93 90 71 05 95 90 73 17 30 98 40 64 65 89 07 79 09 19 56 36 42 30 23 69 73 72 07 05 27 61 24 31 43 48 71 84 21 28 26 65 65 59 65 74 77 20 10 81 61 84 95 08 52 23 70
47 81 28 09 98 51 67 64 35 51 59 36 92 82 77 65 80 24 72 53 22 07 27 10 21 28 30 22 48 82 80 48 56 20 14 43 18 25 50 95 90 31 77 08 09 48 44 80 90 22 93 45 82 17 13 96 25 26 08 73 34 99 06 49 24 06 83 51 40 14 15 10 25 01
54 25 10 81 30 64 24 74 75 80 36 75 82 60 22 69 72 91 45 67 03 62 79 54 89 74 44 83 64 96 66 73 44 30 74 50 37 05 09 97 70 01 60 46 37 91 39 75 75 18 58 52 72 78 51 81 86 52 08 97 01 46 43 66 98 62 81 18 70 93 73 08 32 46 34
96 80 82 07 59 71 92 53 19 20 88 66 03 26 26 10 24 27 50 82 94 73 63 08 51 33 22 45 19 13 58 33 90 15 22 50 36 13 55 06 35 47 82 52 33 61 36 27 28 46 98 14 73 20 73 32 16 26 80 53 47 66 76 38 94 45 02 01 22 52 47 96 64 58 52 39
88 46 23 39 74 63 81 64 20 90 33 33 76 55 58 26 10 46 42 26 74 74 12 83 32 43 09 02 73 55 86 54 85 34 28 23 29 79 91 62 47 41 82 87 99 22 48 90 20 05 96 75 95 04 43 28 81 39 81 01 28 42 78 25 39 77 90 57 58 98 17 36 73 22 63 74 51
29 39 74 94 95 78 64 24 38 86 63 87 93 06 70 92 22 16 80 64 29 52 20 27 23 50 14 13 87 15 72 96 81 22 08 49 72 30 70 24 79 31 16 64 59 21 89 34 96 91 48 76 43 53 88 01 57 80 23 81 90 79 58 01 80 87 17 99 86 90 72 63 32 69 14 28 88 69
37 17 71 95 56 93 71 35 43 45 04 98 92 94 84 96 11 30 31 27 31 60 92 03 48 05 98 91 86 94 35 90 90 08 48 19 33 28 68 37 59 26 65 96 50 68 22 07 09 49 34 31 77 49 43 06 75 17 81 87 61 79 52 26 27 72 29 50 07 98 86 01 17 10 46 64 24 18 56
51 30 25 94 88 85 79 91 40 33 63 84 49 67 98 92 15 26 75 19 82 05 18 78 65 93 61 48 91 43 59 41 70 51 22 15 92 81 67 91 46 98 11 11 65 31 66 10 98 65 83 21 05 56 05 98 73 67 46 74 69 34 08 30 05 52 07 98 32 95 30 94 65 50 24 63 28 81 99 57
19 23 61 36 09 89 71 98 65 17 30 29 89 26 79 74 94 11 44 48 97 54 81 55 39 66 69 45 28 47 13 86 15 76 74 70 84 32 36 33 79 20 78 14 41 47 89 28 81 05 99 66 81 86 38 26 06 25 13 60 54 55 23 53 27 05 89 25 23 11 13 54 59 54 56 34 16 24 53 44 06
13 40 57 72 21 15 60 08 04 19 11 98 34 45 09 97 86 71 03 15 56 19 15 44 97 31 90 04 87 87 76 08 12 30 24 62 84 28 12 85 82 53 99 52 13 94 06 65 97 86 09 50 94 68 69 74 30 67 87 94 63 07 78 27 80 36 69 41 06 92 32 78 37 82 30 05 18 87 99 72 19 99
44 20 55 77 69 91 27 31 28 81 80 27 02 07 97 23 95 98 12 25 75 29 47 71 07 47 78 39 41 59 27 76 13 15 66 61 68 35 69 86 16 53 67 63 99 85 41 56 08 28 33 40 94 76 90 85 31 70 24 65 84 65 99 82 19 25 54 37 21 46 33 02 52 99 51 33 26 04 87 02 08 18 96
54 42 61 45 91 06 64 79 80 82 32 16 83 63 42 49 19 78 65 97 40 42 14 61 49 34 04 18 25 98 59 30 82 72 26 88 54 36 21 75 03 88 99 53 46 51 55 78 22 94 34 40 68 87 84 25 30 76 25 08 92 84 42 61 40 38 09 99 40 23 29 39 46 55 10 90 35 84 56 70 63 23 91 39
52 92 03 71 89 07 09 37 68 66 58 20 44 92 51 56 13 71 79 99 26 37 02 06 16 67 36 52 58 16 79 73 56 60 59 27 44 77 94 82 20 50 98 33 09 87 94 37 40 83 64 83 58 85 17 76 53 02 83 52 22 27 39 20 48 92 45 21 09 42 24 23 12 37 52 28 50 78 79 20 86 62 73 20 59
54 96 80 15 91 90 99 70 10 09 58 90 93 50 81 99 54 38 36 10 30 11 35 84 16 45 82 18 11 97 36 43 96 79 97 65 40 48 23 19 17 31 64 52 65 65 37 32 65 76 99 79 34 65 79 27 55 33 03 01 33 27 61 28 66 08 04 70 49 46 48 83 01 45 19 96 13 81 14 21 31 79 93 85 50 05
92 92 48 84 59 98 31 53 23 27 15 22 79 95 24 76 05 79 16 93 97 89 38 89 42 83 02 88 94 95 82 21 01 97 48 39 31 78 09 65 50 56 97 61 01 07 65 27 21 23 14 15 80 97 44 78 49 35 33 45 81 74 34 05 31 57 09 38 94 07 69 54 69 32 65 68 46 68 78 90 24 28 49 51 45 86 35
41 63 89 76 87 31 86 09 46 14 87 82 22 29 47 16 13 10 70 72 82 95 48 64 58 43 13 75 42 69 21 12 67 13 64 85 58 23 98 09 37 76 05 22 31 12 66 50 29 99 86 72 45 25 10 28 19 06 90 43 29 31 67 79 46 25 74 14 97 35 76 37 65 46 23 82 06 22 30 76 93 66 94 17 96 13 20 72
63 40 78 08 52 09 90 41 70 28 36 14 46 44 85 96 24 52 58 15 87 37 05 98 99 39 13 61 76 38 44 99 83 74 90 22 53 80 56 98 30 51 63 39 44 30 91 91 04 22 27 73 17 35 53 18 35 45 54 56 27 78 48 13 69 36 44 38 71 25 30 56 15 22 73 43 32 69 59 25 93 83 45 11 34 94 44 39 92
12 36 56 88 13 96 16 12 55 54 11 47 19 78 17 17 68 81 77 51 42 55 99 85 66 27 81 79 93 42 65 61 69 74 14 01 18 56 12 01 58 37 91 22 42 66 83 25 19 04 96 41 25 45 18 69 96 88 36 93 10 12 98 32 44 83 83 04 72 91 04 27 73 07 34 37 71 60 59 31 01 54 54 44 96 93 83 36 04 45
30 18 22 20 42 96 65 79 17 41 55 69 94 81 29 80 91 31 85 25 47 26 43 49 02 99 34 67 99 76 16 14 15 93 08 32 99 44 61 77 67 50 43 55 87 55 53 72 17 46 62 25 50 99 73 05 93 48 17 31 70 80 59 09 44 59 45 13 74 66 58 94 87 73 16 14 85 38 74 99 64 23 79 28 71 42 20 37 82 31 23
51 96 39 65 46 71 56 13 29 68 53 86 45 33 51 49 12 91 21 21 76 85 02 17 98 15 46 12 60 21 88 30 92 83 44 59 42 50 27 88 46 86 94 73 45 54 23 24 14 10 94 21 20 34 23 51 04 83 99 75 90 63 60 16 22 33 83 70 11 32 10 50 29 30 83 46 11 05 31 17 86 42 49 01 44 63 28 60 07 78 95 40
44 61 89 59 04 49 51 27 69 71 46 76 44 04 09 34 56 39 15 06 94 91 75 90 65 27 56 23 74 06 23 33 36 69 14 39 05 34 35 57 33 22 76 46 56 10 61 65 98 09 16 69 04 62 65 18 99 76 49 18 72 66 73 83 82 40 76 31 89 91 27 88 17 35 41 35 32 51 32 67 52 68 74 85 80 57 07 11 62 66 47 22 67
65 37 19 97 26 17 16 24 24 17 50 37 64 82 24 36 32 11 68 34 69 31 32 89 79 93 96 68 49 90 14 23 04 04 67 99 81 74 70 74 36 96 68 09 64 39 88 35 54 89 96 58 66 27 88 97 32 14 06 35 78 20 71 06 85 66 57 02 58 91 72 05 29 56 73 48 86 52 09 93 22 57 79 42 12 01 31 68 17 59 63 76 07 77
73 81 14 13 17 20 11 09 01 83 08 85 91 70 84 63 62 77 37 07 47 01 59 95 39 69 39 21 99 09 87 02 97 16 92 36 74 71 90 66 33 73 73 75 52 91 11 12 26 53 05 26 26 48 61 50 90 65 01 87 42 47 74 35 22 73 24 26 56 70 52 05 48 41 31 18 83 27 21 39 80 85 26 08 44 02 71 07 63 22 05 52 19 08 20
17 25 21 11 72 93 33 49 64 23 53 82 03 13 91 65 85 02 40 05 42 31 77 42 05 36 06 54 04 58 07 76 87 83 25 57 66 12 74 33 85 37 74 32 20 69 03 97 91 68 82 44 19 14 89 28 85 85 80 53 34 87 58 98 88 78 48 65 98 40 11 57 10 67 70 81 60 79 74 72 97 59 79 47 30 20 54 80 89 91 14 05 33 36 79 39
60 85 59 39 60 07 57 76 77 92 06 35 15 72 23 41 45 52 95 18 64 79 86 53 56 31 69 11 91 31 84 50 44 82 22 81 41 40 30 42 30 91 48 94 74 76 64 58 74 25 96 57 14 19 03 99 28 83 15 75 99 01 89 85 79 50 03 95 32 67 44 08 07 41 62 64 29 20 14 76 26 55 48 71 69 66 19 72 44 25 14 01 48 74 12 98 07
64 66 84 24 18 16 27 48 20 14 47 69 30 86 48 40 23 16 61 21 51 50 26 47 35 33 91 28 78 64 43 68 04 79 51 08 19 60 52 95 06 68 46 86 35 97 27 58 04 65 30 58 99 12 12 75 91 39 50 31 42 64 70 04 46 07 98 73 98 93 37 89 77 91 64 71 64 65 66 21 78 62 81 74 42 20 83 70 73 95 78 45 92 27 34 53 71 15
30 11 85 31 34 71 13 48 05 14 44 03 19 67 23 73 19 57 06 90 94 72 57 69 81 62 59 68 88 57 55 69 49 13 07 87 97 80 89 05 71 05 05 26 38 40 16 62 45 99 18 38 98 24 21 26 62 74 69 04 85 57 77 35 58 67 91 79 79 57 86 28 66 34 72 51 76 78 36 95 63 90 08 78 47 63 45 31 22 70 52 48 79 94 15 77 61 67 68
23 33 44 81 80 92 93 75 94 88 23 61 39 76 22 03 28 94 32 06 49 65 41 34 18 23 08 47 62 60 03 63 33 13 80 52 31 54 73 43 70 26 16 69 57 87 83 31 03 93 70 81 47 95 77 44 29 68 39 51 56 59 63 07 25 70 07 77 43 53 64 03 94 42 95 39 18 01 66 21 16 97 20 50 90 16 70 10 95 69 29 06 25 61 41 26 15 59 63 35
#+end_verse
** code p67
#+begin_src odin :main no :comments link :tangle src/maximum_path_sum_ii.odin
package maximum_path_sum_ii

import "core:os"
import "core:fmt"
import "core:strconv"

connects_to :: proc(idx : int, triangle : []int) -> [2]int {
	// every triangle node connects to the two below, find longest path down
	ridx := 0
	prev_ridx := 0
	to_n1 := 0
	to_n2 := 1
	line := 1
	for ; ridx <= idx; ridx+=1 {
		if (ridx == prev_ridx+line) {
			line += 1
			prev_ridx = ridx
		}

		if ridx == idx {
			to_n1 += line
			to_n2 += line
		} else {
			to_n1 += 1
			to_n2 += 1
		}
	}
	if (to_n1 > len(triangle)-1 || to_n2 > len(triangle)-1) {
		to_n1 = -1
		to_n2 = -1
	}

	return {to_n1, to_n2}
}

Nodes :: struct {
	n : int,
	largest_sum  : int,
	connect_prev : int,
}

main :: proc() {

	tdata, err := os.read_entire_file("triangle.txt")
	triangle : [dynamic]int
	// every byte in tdata is a digit from a 2 digit number or a space or newline(0x0d 0x0a)
	prev_digit : u8 = u8(0)
	for c in tdata {
		if c == 0x20 || c == 0x0d || c == 0x0a {
			continue
		}
		if prev_digit != 0 {
			str := fmt.tprintf("%c%c", prev_digit, c)
			num,_ := strconv.parse_int(str)
			append(&triangle, num)
			prev_digit = 0
		} else {
			prev_digit = c
		}
	}

	
	tree := make([]Nodes, len(triangle))

	for i:=0; i<len(triangle)-1; i+=1 {
		tree[i] = ({ triangle[i], triangle[i], -1 })
	}
	for i:=0; i<len(triangle)-1; i+=1 {
		tmp := connects_to(i, triangle[:])
		if tmp[0] > 0 && tmp[1] > 0 {
			if tree[tmp[0]].n + tree[i].largest_sum > tree[tmp[0]].largest_sum {
				tree[tmp[0]].largest_sum = tree[tmp[0]].n + tree[i].largest_sum
				tree[tmp[0]].connect_prev = i
			}
			if tree[tmp[1]].n + tree[i].largest_sum > tree[tmp[1]].largest_sum {
				tree[tmp[1]].largest_sum = tree[tmp[1]].n + tree[i].largest_sum
				tree[tmp[1]].connect_prev = i
			}
		}
	}

	// for all bottom nodes at the end -- note: 100 is height/width of triangle
	largest := 0
	size := len(tree)-1
	for i:=0; i<100; i+=1 {
		if tree[size-i].largest_sum > largest {
			largest = tree[size-i].largest_sum
		}
	}
	fmt.println(largest)
	
}
#+end_src

#+RESULTS:

* Prob 068 - Magic 5-gon Ring
** prob p68
Consider the following "magic" 3-gon ring, filled with the numbers 1 to 6, and each line adding to nine.

[[file:src/magic_3_gon.png]]

Working *clockwise*, and starting from the group of three with the numerically
lowest external node (4,3,2 in this example), each solution can be described
uniquely. For example, the above solution can be described by the set: 4,3,2;
6,2,1; 5,1,3.

It is possible to complete the ring with four different totals: 9, 10, 11,
and 12. There are eight solutions in total.

| Total | Solution Set        |
|     9 | 4,2,3; 5,3,1; 6,1,2 |
|     9 | 4,3,2; 6,2,1; 5,1,3 |
|    10 | 2,3,5; 4,5,1; 6,1,3 |
|    10 | 2,5,3; 6,3,1; 4,1,5 |
|    11 | 1,4,6; 3,6,2; 5,2,4 |
|    11 | 1,6,4; 5,4,2; 3,2,6 |
|    12 | 1,5,6; 2,6,4; 3,4,5 |
|    12 | 1,6,5; 3,5,4; 2,4,6 |

By concatenating each group it is possible to form 9-digit strings; the maximum
string for a 3-gon ring is 432621513.

Using the numbers 1 to 10, and depending on arrangements, it is possible to form
16- and 17-digit strings. What is the maximum *16-digit* string for a
"magic" 5-gon ring?

[[file:src/magic_5_gon.png]]

** code p68
#+begin_src odin :main no :comments link :tangle src/magic_5_gon_ring.odin
package magic_5_gon_ring

import "core:fmt"
import "core:mem"
import "core:math"
import "core:slice"
import "core:strings"
import "core:math/linalg"
import "vendor:raylib"
import "../util"

MENU_RECT :: raylib.Rectangle{250, 10, 240, 390}

Values :: struct {
	show_menu  : bool,
	width      : int,
	height     : int,
	scroll     : int,
}

NgonType :: enum {
	THREEGON,
	FIVEGON,
}

SolutionSet :: struct {
	solutions         : [dynamic][]int,
	type              : NgonType,
	nums              : [dynamic]int,
	lines             : [dynamic][3]rawptr, // 3 ptrs into nums
	lines_acc         : [dynamic]int,       // accumulated line totals
	smap              : map[string][]int,
	smap_order        : [dynamic]string,
	solution_selected : int,
}

draw_menu :: proc(values: ^Values, ss: ^SolutionSet) {
  using raylib

  menu_rect := MENU_RECT
  menu_rect.x = f32(values.width) - menu_rect.x
  if !values.show_menu {
    values.show_menu = GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")
  } else {
    panel := GuiPanel(menu_rect, "")
	  values.show_menu = !GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")

	  ngon_text := cstring("THREEGON\nFIVEGON")
	  ngscroll_idx := i32(0)
	  ngactive := i32(ss.type == .THREEGON ? 0 : 1)
	  raylib.GuiListView(Rectangle{f32(values.width) - 245, 40, 230, 65}, ngon_text, &ngscroll_idx, &ngactive)
	  if ngactive == 0 {
		  ss.type = .THREEGON
	  } else {
		  ss.type = .FIVEGON
	  }

	  if len(ss.smap) > 0 {
		  text := make([^]cstring, len(ss.smap))
		  text_cnt := i32(len(ss.smap))
		  scroll_idx := i32(values.scroll)
		  active := i32(ss.solution_selected)
		  focus := i32(ss.solution_selected)
		  idx := 0
		  for k in ss.smap_order {
			  text[idx] = strings.unsafe_string_to_cstring(k)
			  idx += 1
		  }
		  GuiListViewEx(Rectangle{f32(values.width) - 245, 145, 230, 230}, text, text_cnt, &scroll_idx, &active, &focus)
		  free(text)
		  if active >= 0 {
			  ss.solution_selected = int(active)
		  }
		  values.scroll = int(scroll_idx)
	  }
  }
}

// returns true if all lines add to the same value
test_set_nums :: proc(ss: ^SolutionSet) -> bool {
	tot := 0
	acc := 0
	for l,idx in ss.lines {
		if idx == 0 {
			for p in l {
				tot += (cast(^int)p)^
			}
		} else {
			acc = 0
			for p in l {
				acc += (cast(^int)p)^
			}
			if acc != tot {
				return false
			}
		}
	}
	return true
}

// print solution set (*working* from smallest external node and going clockwise)
set_nums_as_string :: proc(ss: ^SolutionSet) -> string {
	tot := 0
	str := ""
	for p in ss.lines[0] {
		tot += (cast(^int)p)^
	}
	if ss.type == .THREEGON {
		//  4
		//   3
		//  0 1 2
		// 5
		str = fmt.tprintf("%02d ", tot)
		// find smallest external node
		smallest_node := 4
		if ss.nums[2] < ss.nums[4] && ss.nums[2] < ss.nums[5] {
			smallest_node = 2
		} else if ss.nums[5] < ss.nums[4] && ss.nums[5] < ss.nums[2] {
			smallest_node = 5
		}
		for i in 0..<3 {
			if smallest_node == 4 {
				str = fmt.tprintf("%s%d,%d,%d", str, ss.nums[4], ss.nums[3], ss.nums[1])
				smallest_node = 2
			} else if smallest_node == 2 {
				str = fmt.tprintf("%s%d,%d,%d", str, ss.nums[2], ss.nums[1], ss.nums[0])
				smallest_node = 5
			} else if smallest_node == 5 {
				str = fmt.tprintf("%s%d,%d,%d", str, ss.nums[5], ss.nums[0], ss.nums[3])
				smallest_node = 4
			}
			if i != 2 do str = fmt.tprintf("%s; ", str)
		}
	} else {
		//  6
		//   5 4
		// 7  3
		//8 012
		//   9
		str = fmt.tprintf("%02d ", tot)
		// find smallest external node
		smallest_node := 6
		if ss.nums[4] < ss.nums[6] && ss.nums[4] < ss.nums[2] && ss.nums[4] < ss.nums[9] && ss.nums[4] < ss.nums[8] {
			smallest_node = 4
		} else if ss.nums[2] < ss.nums[6] && ss.nums[2] < ss.nums[4] && ss.nums[2] < ss.nums[9] && ss.nums[2] < ss.nums[8] {
			smallest_node = 2
		} else if ss.nums[9] < ss.nums[6] && ss.nums[9] < ss.nums[4] && ss.nums[9] < ss.nums[2] && ss.nums[9] < ss.nums[8] {
			smallest_node = 9
		} else if ss.nums[8] < ss.nums[6] && ss.nums[8] < ss.nums[4] && ss.nums[8] < ss.nums[2] && ss.nums[8] < ss.nums[9] {
			smallest_node = 8
		}
		for i in 0..<5 {
			if smallest_node == 6 {
				str = fmt.tprintf("%s%d,%d,%d", str, ss.nums[6], ss.nums[5], ss.nums[3])
				smallest_node = 4
			} else if smallest_node == 4 {
				str = fmt.tprintf("%s%d,%d,%d", str, ss.nums[4], ss.nums[3], ss.nums[1])
				smallest_node = 2
			} else if smallest_node == 2 {
				str = fmt.tprintf("%s%d,%d,%d", str, ss.nums[2], ss.nums[1], ss.nums[0])
				smallest_node = 9
			} else if smallest_node == 9 {
				str = fmt.tprintf("%s%d,%d,%d", str, ss.nums[9], ss.nums[0], ss.nums[7])
				smallest_node = 8
			} else if smallest_node == 8 {
				str = fmt.tprintf("%s%d,%d,%d", str, ss.nums[8], ss.nums[7], ss.nums[5])
				smallest_node = 6
			}
			if i != 4 do str = fmt.tprintf("%s; ", str)
		}
	}
	return str
}

get_solution_sets :: proc(ss: ^SolutionSet) {
	for k,v in ss.smap {
		delete(v)
	}
	clear(&ss.smap)
	clear(&ss.smap_order)
	clear(&ss.nums)
	clear(&ss.lines)
	clear(&ss.lines_acc)
	
	if ss.type == .THREEGON {
		for i in 1..=6 {
			append(&ss.nums, i)
		}
		append(&ss.lines, [3]rawptr{&ss.nums[4], &ss.nums[3], &ss.nums[1]})
		append(&ss.lines_acc, 0)
		append(&ss.lines, [3]rawptr{&ss.nums[2], &ss.nums[1], &ss.nums[0]})
		append(&ss.lines_acc, 0)
		append(&ss.lines, [3]rawptr{&ss.nums[5], &ss.nums[0], &ss.nums[3]})
		append(&ss.lines_acc, 0)
	} else {
		for i in 1..=10 {
			append(&ss.nums, i)
		}
		append(&ss.lines, [3]rawptr{&ss.nums[6], &ss.nums[5], &ss.nums[3]})
		append(&ss.lines_acc, 0)
		append(&ss.lines, [3]rawptr{&ss.nums[4], &ss.nums[3], &ss.nums[1]})
		append(&ss.lines_acc, 0)
		append(&ss.lines, [3]rawptr{&ss.nums[2], &ss.nums[1], &ss.nums[0]})
		append(&ss.lines_acc, 0)
		append(&ss.lines, [3]rawptr{&ss.nums[9], &ss.nums[0], &ss.nums[7]})
		append(&ss.lines_acc, 0)
		append(&ss.lines, [3]rawptr{&ss.nums[8], &ss.nums[7], &ss.nums[5]})
		append(&ss.lines_acc, 0)
	}

	// Since the shape is symmetric we can skip a large number
	// of the permutations
	// ie:
	//  0                         3                5
	//   1       is the same as    2      and as    4
	//  4 2 3                     1 4 5            2 1 0
	// 5                         0                3
	// This means if we rotate to keep place 0 the smallest num
	// that it can't be the numbers 4 or 5 (or 5/6 if one based)
	// also place 3 and 5 can't be 0 (since that would rotate up)
	I := new([]util.MobileInt)
	defer {
		delete(I^)
		free(I)
	}
	
	{
		for ;; {
			if !(ss.nums[0] == 5 || ss.nums[0] == 6) &&
				!(ss.nums[3] == 1 || ss.nums[5] == 1) {
					if test_set_nums(ss) {
						str := set_nums_as_string(ss)
						if !(str in ss.smap) { // no need to add dups
							ss.smap[str] = make([]int, len(ss.nums))
							for i in 0..<len(ss.nums) {
								ss.smap[str][i] = ss.nums[i]
							}
							append(&ss.smap_order, str)
						}
					}
				}
			if !util.gen_permute(ss.nums[:], I) {
				//fmt.println("done")
				break
			}
		}
		// end for loop.. order .smap
		slice.sort(ss.smap_order[:])
	}
	return
}
	
// returns the Vector2 points that numbers would go (1-6 in example)
draw_three_gon :: proc(#any_int x, y: int, radius: f32, rot: f32, color: raylib.Color) -> [6]linalg.Vector2f32 {
	using raylib

	ret : [6]linalg.Vector2f32
	r := radius
	xx := f32(x)
	yy := f32(y)
	c2 := linalg.Vector2f32{3.5*r, 0} // circles centers
	c3 := linalg.Vector2f32{7*r, 0}
	ls := [?]linalg.Vector2f32{ // line end points
		linalg.Vector2f32{1*r, 0},
		linalg.Vector2f32{2.5*r, 0},
		linalg.Vector2f32{4.5*r, 0},
		linalg.Vector2f32{6*r, 0}}
	
	c2 = Vector2Rotate(c2, rot)
	c3 = Vector2Rotate(c3, rot)
	for &l in ls {
		l = Vector2Rotate(l, rot)
	}

	ret[0] = linalg.Vector2f32{xx, yy}
	ret[1] = linalg.Vector2f32{xx+c2.x, yy+c2.y}
	ret[2] = linalg.Vector2f32{xx+c3.x, yy+c3.y}
	DrawCircle(i32(xx), i32(yy), radius, WHITE) // TODO: background color
	DrawCircle(i32(xx+c2.x), i32(yy+c2.y), radius, WHITE)
	DrawCircle(i32(xx+c3.x), i32(yy+c3.y), radius, WHITE)
	DrawCircleLines(i32(xx), i32(yy), radius, color)
	DrawCircleLines(i32(xx+c2.x), i32(yy+c2.y), radius, color)
	DrawCircleLines(i32(xx+c3.x), i32(yy+c3.y), radius, color)
	DrawLine(i32(xx+ls[0].x), i32(yy+ls[0].y), i32(xx+ls[1].x), i32(yy+ls[1].y), color)
	DrawLine(i32(xx+ls[2].x), i32(yy+ls[2].y), i32(xx+ls[3].x), i32(yy+ls[3].y), color)

	angle := f32(-60)
	c2 = Vector2Rotate(c2, angle*math.PI/180)
	c3 = Vector2Rotate(c3, angle*math.PI/180)
	for &l in ls {
		l = Vector2Rotate(l, angle*math.PI/180)
	}
	xx -= 3.5*r
	yy += 6*r
	ret[5] = linalg.Vector2f32{xx+c2.x, yy+c2.y}
	DrawCircle(i32(xx+c2.x), i32(yy+c2.y), radius, WHITE)
	DrawCircleLines(i32(xx+c2.x), i32(yy+c2.y), radius, color)
	DrawLine(i32(xx+ls[2].x), i32(yy+ls[2].y), i32(xx+ls[3].x), i32(yy+ls[3].y), color)
	xx += 3.5*r
	yy -= 6*r
	DrawLine(i32(xx+ls[0].x), i32(yy+ls[0].y), i32(xx+ls[1].x), i32(yy+ls[1].y), color)

	angle = f32(120)
	c2 = Vector2Rotate(c2, angle*math.PI/180)
	c3 = Vector2Rotate(c3, angle*math.PI/180)
	for &l in ls {
		l = Vector2Rotate(l, angle*math.PI/180)
	}
	yy -= 6*r
	ret[4] = linalg.Vector2f32{xx, yy}
	ret[3] = linalg.Vector2f32{xx+c2.x, yy+c2.y}
	DrawCircle(i32(xx), i32(yy), radius, WHITE)
	DrawCircle(i32(xx+c2.x), i32(yy+c2.y), radius, WHITE)
	DrawCircleLines(i32(xx), i32(yy), radius, color)
	DrawCircleLines(i32(xx+c2.x), i32(yy+c2.y), radius, color)
	DrawLine(i32(xx+ls[0].x), i32(yy+ls[0].y), i32(xx+ls[1].x), i32(yy+ls[1].y), color)
	DrawLine(i32(xx+ls[2].x), i32(yy+ls[2].y), i32(xx+ls[3].x), i32(yy+ls[3].y), color)
	return ret
}

// returns the Vector2 points that numbers would go
draw_five_gon :: proc(#any_int x, y: int, radius: f32, rot: f32, color: raylib.Color) -> [10]linalg.Vector2f32 {
	using raylib

	ret : [10]linalg.Vector2f32
	r := radius
	xx := f32(x)
	yy := f32(y)
	c2 := linalg.Vector2f32{3.5*r, 0} // circles centers
	c3 := linalg.Vector2f32{7*r, 0}
	ls := [?]linalg.Vector2f32{ // line end points
		linalg.Vector2f32{1*r, 0},
		linalg.Vector2f32{2.5*r, 0},
		linalg.Vector2f32{4.5*r, 0},
		linalg.Vector2f32{6*r, 0}}
	
	c2 = Vector2Rotate(c2, rot)
	c3 = Vector2Rotate(c3, rot)
	for &l in ls {
		l = Vector2Rotate(l, rot)
	}

	ret[0] = linalg.Vector2f32{xx, yy}
	ret[1] = linalg.Vector2f32{xx+c2.x, yy+c2.y}
	ret[2] = linalg.Vector2f32{xx+c3.x, yy+c3.y}
	DrawCircle(i32(xx), i32(yy), radius, WHITE)
	DrawCircle(i32(xx+c2.x), i32(yy+c2.y), radius, WHITE)
	DrawCircle(i32(xx+c3.x), i32(yy+c3.y), radius, WHITE)
	DrawCircleLines(i32(xx), i32(yy), radius, color)
	DrawCircleLines(i32(xx+c2.x), i32(yy+c2.y), radius, color)
	DrawCircleLines(i32(xx+c3.x), i32(yy+c3.y), radius, color)
	DrawLine(i32(xx+ls[0].x), i32(yy+ls[0].y), i32(xx+ls[1].x), i32(yy+ls[1].y), color)
	DrawLine(i32(xx+ls[2].x), i32(yy+ls[2].y), i32(xx+ls[3].x), i32(yy+ls[3].y), color)

	angle := f32(-72)
	c2 = Vector2Rotate(c2, angle*math.PI/180)
	c3 = Vector2Rotate(c3, angle*math.PI/180)
	for &l in ls {
		l = Vector2Rotate(l, angle*math.PI/180)
	}
	xx += 3.5*r
	yy += 0*r
	ret[3] = linalg.Vector2f32{xx+c2.x, yy+c2.y}
	ret[4] = linalg.Vector2f32{xx+c3.x, yy+c3.y}
	DrawCircle(i32(xx+c2.x), i32(yy+c2.y), radius, WHITE)
	DrawCircle(i32(xx+c3.x), i32(yy+c3.y), radius, WHITE)
	DrawCircleLines(i32(xx+c2.x), i32(yy+c2.y), radius, color)
	DrawCircleLines(i32(xx+c3.x), i32(yy+c3.y), radius, color)
	DrawLine(i32(xx+ls[0].x), i32(yy+ls[0].y), i32(xx+ls[1].x), i32(yy+ls[1].y), color)
	DrawLine(i32(xx+ls[2].x), i32(yy+ls[2].y), i32(xx+ls[3].x), i32(yy+ls[3].y), color)
	
	angle = f32(-72)
	c2 = Vector2Rotate(c2, angle*math.PI/180)
	c3 = Vector2Rotate(c3, angle*math.PI/180)
	for &l in ls {
		l = Vector2Rotate(l, angle*math.PI/180)
	}
	xx += 1.08*r
	yy += -3.33*r
	ret[5] = linalg.Vector2f32{xx+c2.x, yy+c2.y}
	ret[6] = linalg.Vector2f32{xx+c3.x, yy+c3.y}
	DrawCircle(i32(xx+c2.x), i32(yy+c2.y), radius, WHITE)
	DrawCircle(i32(xx+c3.x), i32(yy+c3.y), radius, WHITE)
	DrawCircleLines(i32(xx+c2.x), i32(yy+c2.y), radius, color)
	DrawCircleLines(i32(xx+c3.x), i32(yy+c3.y), radius, color)
	DrawLine(i32(xx+ls[0].x), i32(yy+ls[0].y), i32(xx+ls[1].x), i32(yy+ls[1].y), color)
	DrawLine(i32(xx+ls[2].x), i32(yy+ls[2].y), i32(xx+ls[3].x), i32(yy+ls[3].y), color)

	angle = f32(-72)
	c2 = Vector2Rotate(c2, angle*math.PI/180)
	c3 = Vector2Rotate(c3, angle*math.PI/180)
	for &l in ls {
		l = Vector2Rotate(l, angle*math.PI/180)
	}
	xx += -2.83*r
	yy += -2.06*r
	ret[7] = linalg.Vector2f32{xx+c2.x, yy+c2.y}
	ret[8] = linalg.Vector2f32{xx+c3.x, yy+c3.y}
	DrawCircle(i32(xx+c2.x), i32(yy+c2.y), radius, WHITE)
	DrawCircle(i32(xx+c3.x), i32(yy+c3.y), radius, WHITE)
	DrawCircleLines(i32(xx+c2.x), i32(yy+c2.y), radius, color)
	DrawCircleLines(i32(xx+c3.x), i32(yy+c3.y), radius, color)
	DrawLine(i32(xx+ls[0].x), i32(yy+ls[0].y), i32(xx+ls[1].x), i32(yy+ls[1].y), color)
	DrawLine(i32(xx+ls[2].x), i32(yy+ls[2].y), i32(xx+ls[3].x), i32(yy+ls[3].y), color)

	angle = f32(-72)
	c2 = Vector2Rotate(c2, angle*math.PI/180)
	c3 = Vector2Rotate(c3, angle*math.PI/180)
	for &l in ls {
		l = Vector2Rotate(l, angle*math.PI/180)
	}
	xx += -2.83*r
	yy += 2.07*r
	ret[9] = linalg.Vector2f32{xx+c3.x, yy+c3.y}
	DrawCircle(i32(xx+c3.x), i32(yy+c3.y), radius, WHITE)
	DrawCircleLines(i32(xx+c3.x), i32(yy+c3.y), radius, color)
	DrawLine(i32(xx+ls[0].x), i32(yy+ls[0].y), i32(xx+ls[1].x), i32(yy+ls[1].y), color)
	DrawLine(i32(xx+ls[2].x), i32(yy+ls[2].y), i32(xx+ls[3].x), i32(yy+ls[3].y), color)
	
	return ret
}

export_3gon_png :: proc() {
	using raylib
	W :: 300
	H :: 250
	target := LoadRenderTexture(W, H)
	
	BeginTextureMode(target)
	pts := draw_three_gon(100, 150, 20, 0, BLACK)
	arr := []int{1,2,6,3,4,5}
	for p,idx in pts {
		num := fmt.tprintf("%d", arr[idx])
		cnum := strings.clone_to_cstring(num); defer delete(cnum)
		DrawText(cnum, i32(p.x-4), i32(p.y-5), 10, BLACK)
	}
	EndTextureMode()
	
	img := LoadImageFromTexture(target.texture)
	ImageFlipVertical(&img)
	ExportImage(img, "magic_3_gon.png")
}

export_5gon_png :: proc() {
	using raylib
	W :: 300
	H :: 300
	target := LoadRenderTexture(W, H)
	
	BeginTextureMode(target)
	draw_five_gon(110, 190, 20, 0, BLACK)
	EndTextureMode()
	
	img := LoadImageFromTexture(target.texture)
	ImageFlipVertical(&img)
	ExportImage(img, "magic_5_gon.png")
}

main :: proc() {
	using raylib

	ta := mem.Tracking_Allocator{};
	mem.tracking_allocator_init(&ta, context.allocator);
	context.allocator = mem.tracking_allocator(&ta);
	defer {
		if len(ta.allocation_map) > 0 {
			for _, v in ta.allocation_map {
				fmt.printf("Leaked %v bytes @ %v\n", v.size, v.location);
			}
		}
		if len(ta.bad_free_array) > 0 {
			fmt.println("Bad frees:");
			for v in ta.bad_free_array {
				fmt.println(v);
			}
		}
	}
	// ------------------------------
	{
		values : Values
		values.show_menu = true
		values.width = 600
		values.height = 500

		ss : SolutionSet
		ss.type = .THREEGON
		get_solution_sets(&ss) // fill ss.smap
		last_ss := ss.solution_selected
		last_type := ss.type
		defer {
			delete(ss.nums)
			delete(ss.lines)
			delete(ss.lines_acc)
			for k,v in ss.smap {
				delete(v)
			}
			delete(ss.smap)
			delete(ss.smap_order)
		}

	
		InitWindow(i32(values.width), i32(values.height), "Window_Title")
		SetTargetFPS(60)

		export_3gon_png()
		export_5gon_png()
		
		for !WindowShouldClose() {
			// Update ------------------------------
			if ss.type != last_type {
				get_solution_sets(&ss)
				ss.solution_selected = 0
				last_type = ss.type
			}
			if ss.solution_selected != last_ss {
				clear(&ss.nums)
				for n in ss.smap[ss.smap_order[ss.solution_selected]] {
					append(&ss.nums, n)
				}
				last_ss = ss.solution_selected
			}
			
			// Draw   ------------------------------
			BeginDrawing()
			ClearBackground(WHITE)

			if ss.type == .THREEGON {
				pts := draw_three_gon(100, 140, 20, 0, BLACK)
				for p,idx in pts {
					num := fmt.tprintf("%d", ss.nums[idx])
					cnum := strings.clone_to_cstring(num); defer delete(cnum)
					DrawText(cnum, i32(p.x-4), i32(p.y-5), 10, BLACK)
				}
			} else {
				pts := draw_five_gon(110, 190, 20, 0, BLACK)
				for p,idx in pts {
					num := fmt.tprintf("%d", ss.nums[idx])
					cnum := strings.clone_to_cstring(num); defer delete(cnum)
					DrawText(cnum, i32(p.x-4), i32(p.y-5), 10, BLACK)
				}
			}

			draw_menu(&values, &ss)
			
			EndDrawing()
		}
		CloseWindow()
	}
}
#+end_src
* Prob 069 - Totient Maximum
** prob p69
Euler's totient function, $\phi(n)$ [sometimes called the phi function], is defined
as the number of positive integers not exceeding $n$ which are relatively prime
to $n$. For example, as $1$, $2$, $4$, $5$, $7$, and $8$, are all less than or
equal to nine and relatively prime to nine, $\phi(9)=6$.

| $n$ | Relatively Prime | $\phi(n)$ | $n/\phi(n)$ |
|   2 | 1                |      1 |        2 |
|   3 | 1,2              |      2 |      1.5 |
|   4 | 1,3              |      2 |        2 |
|   5 | 1,2,3,4          |      4 |     1.25 |
|   6 | 1,5              |      2 |        3 |
|   7 | 1,2,4,5,6        |      6 |   1.1666 |
|   8 | 1,3,5,7          |      4 |        2 |
|   9 | 1,2,4,5,7,8      |      6 |      1.5 |
|  10 | 1,3,7,9          |      4 |      2.5 |

It can be seen that $n = 6$ produces a maximum $n/\phi(n)$ for $n\leq 10$.

Find the value of $n\leq 1\,000\,000$ for which $n/\phi(n)$ is a maximum.
** code p69
#+begin_src odin :main no :comments link :tangle src/totient_maximum.odin
package totient_maximum

import "core:os"
import "core:fmt"
import "core:math"
import "core:strconv"
import "core:strings"
import "../util"

main :: proc() {
	MAX :: 1_000_000
	nn := 0
	largest : f64 = 0

	lines: [dynamic]string
	make_prime_factorizations(MAX, &lines)	
	
	if true {
		for n in 2..<MAX {
			// get prime factorization of n
			pf := get_prime_factorization(lines[n])
			
			// totient phi(n) = p^k-1(p-1) * next_p^next_k-1(next_p-1) ...
			my_phi := util.phi(n, pf)
			n_phi := f64(n) / my_phi
			if n_phi > largest {
				nn = n
				largest = n_phi
			}
			//fmt.println(n, my_phi, n_phi)
			//fmt.println(n)
		}
		fmt.println("n =", nn)
	}
}
#+end_src

* Prob 070 - Totient Permutation
** prob p70
Euler's totient function, $\phi(n)$ [sometimes called the phi function], is used to
determine the number of positive numbers less than or equal to $n$ which are
relatively prime to $n$. For example, as $1, 2, 4, 5, 7$, and $8$, are all less
than nine and relatively prime to nine, $\phi(9)=6$.
The number $1$ is considered to be relatively prime to every positive number, so
$\phi(1)=1$.

Interestingly, $\phi(87109)=79180$, and it can be seen that $87109$ is a
permutation of $79180$.

Find the value of $n$, 1 \lt n \lt 10^7, for which $\phi(n)$ is a permutation of $n$
and the ratio $n/\phi(n)$ produces a minimum.

** code p70
#+begin_src odin :main no :comments link :tangle src/totient_permutation.odin
package totient_permutation

import "core:os"
import "core:fmt"
import "core:math"
import "core:strconv"
import "core:strings"
import "../util"

// return true if some permutation of a == b
is_permutation :: proc(#any_int a, b: int) -> bool {
	bufa := make([]byte, 100); defer delete(bufa)
	bufb := make([]byte, 100); defer delete(bufb)
	saa := strconv.itoa(bufa, a)
	sbb := strconv.itoa(bufb, b)
	sa := len(saa)
	sb := len(sbb)
	if sa != sb {
		return false
	}

	str := make([]u8, sa); defer delete(str)
	copy(str, saa)
	I := new([]util.MobileInt)
	defer {
		delete(I^)
		free(I)
	}
	
	for ;; {
		if string(str) == sbb {
			return true
		}
		if util.gen_permute(str, I) == false {
			break
		}
	}
	return false
}

main :: proc() {
	MAX :: 10_000_000
	nn := 0

	lines: [dynamic]string
	util.make_prime_factorizations(MAX, &lines)	

	// to find minimal n/phi(n)
	minimal := f64(MAX)

	if true {
		for n in 2..<MAX {
			// get prime factorization of n
			pf := util.get_prime_factorization(lines[n])
			_ = pf
			
			// totient phi(n) = p^k-1(p-1) * next_p^next_k-1(next_p-1) ...
			my_phi := util.phi(n, pf)
			n_phi := f64(n) / my_phi
      
			if (n_phi < minimal) && is_permutation(n, my_phi) {
				nn = n
				minimal = n_phi
			}
		}
		fmt.println("n =", nn, minimal)
	}
}
#+end_src
* Prob 071 - Ordered Fractions
** prob p71
Consider the fraction, $\dfrac n d$, where $n$ and $d$ are positive integers. If
$n < d$ and $HCF(n,d)=1$, it is called a reduced proper fraction.

If we list the set of reduced proper fractions for $d \le 8$ in ascending order of
size, we get:

$$\frac 1 8, \frac 1 7, \frac 1 6, \frac 1 5, \frac 1 4, \frac 2 7, \frac 1 3,
\frac 3 8, \mathbf{\frac 2 5}, \frac 3 7, \frac 1 2, \frac 4 7, \frac 3 5, \frac
5 8, \frac 2 3, \frac 5 7, \frac 3 4, \frac 4 5, \frac 5 6, \frac 6 7, \frac 7
8$$

It can be seen that $\dfrac 2 5$ is the fraction immediately
to the left of $\dfrac 3 7$.

By listing the set of reduced proper fractions for $d \le 1\,000\,000$ in
ascending order of size, find the numerator of the fraction immediately to the
left of $\dfrac 3 7$.




  8,7,6,5,4,7,3,8,5,7 <-- first half denoms
- 7,6,5,4,3,5,2,5,3,4 <-- backwards last half numerators
= 1,1,1,1,1,2,1,3,2,3 <-- first half numerators
so, at most, only half the list need be "calculated" (up to 1/2)
but,
numbers like: 2/7 and 2/5 and 3/7
need to have their "place"/"order" found

actually, not adding to a list and only *checking* limited fractions in
a range that keeps updating is *WAY* faster than sorting a list

** code p71
#+begin_src odin :main no :comments link :tangle src/ordered_fractions.odin
package ordered_fractions

import "core:fmt"
import "core:math"
import "core:slice"

Fracs :: struct {
	n : int,
	d : int,
}

less :: proc(a, b: Fracs) -> bool {
	return (a.n * b.d) < (b.n * a.d)
}

main :: proc() {
	fracs : [dynamic]Fracs

	MAX := 1_000_000
	c := Fracs{2,5}

	// want to *check* the set of fractions that is greater than 2/5, but less than 3/7
	// so if the denom is 7, only *check* noms from 2*7/5= 2.xx  TO  3
	for denom in 3..=MAX {
		for i in c.n*denom/c.d..=3*denom/7 {
			if math.gcd(i,denom) == 1 {
				tmp := Fracs{i,denom}
				if less(tmp, Fracs{3,7}) && !less(tmp, c) {
					c = tmp
				}
			}
		}
	}
	fmt.println(c)
}
#+end_src

* Prob 072 - Counting Fractions
** prob p72
Consider the fraction, $\dfrac n d$, where n and d are positive integers. If
n \lt d and $HCF(n,d)=1$, it is called a reduced proper fraction.

If we list the set of reduced proper fractions for $d \le 8$ in ascending order of size, we get:

$$\frac 1 8, \frac 1 7, \frac 1 6, \frac 1 5, \frac 1 4, \frac 2 7, \frac 1 3,
\frac 3 8, \frac 2 5, \frac 3 7, \frac 1 2, \frac 4 7, \frac 3 5, \frac 5 8,
\frac 2 3, \frac 5 7, \frac 3 4, \frac 4 5, \frac 5 6, \frac 6 7, \frac 7 8$$

It can be seen that there are $21$ elements in this set.

How many elements would be contained in the set of reduced proper fractions for
d \le 1,000,000?

** code p72
#+begin_src odin :main no :comments link :tangle src/counting_fractions.odin
package counting_fractions

import "core:fmt"
import "core:math"
import "../util"

main :: proc() {
	//MAX := 8
	MAX := 1_000_000

	lines: [dynamic]string
	util.make_prime_factorizations(MAX, &lines)
	
	cnt : f64 = 0
	for n in 2..=MAX {
		pf := util.get_prime_factorization(lines[n])
		cnt += util.phi(n, pf)
	}
	fmt.println(MAX, "=", i64(cnt))
}
#+end_src

* Prob 073 - Counting Fractions in a Range
** prob p73
Consider the fraction, $\dfrac n d$, where $n$ and $d$ are positive integers. If
$n \lt d$ and $HCF(n, d)=1$, it is called a reduced proper
fraction.

If we list the set of reduced proper fractions for $d \le 8$ in ascending order of size, we get:
$$\frac 1 8, \frac 1 7, \frac 1 6, \frac 1 5, \frac 1 4, \frac 2 7, \frac 1 3,
\mathbf{\frac 3 8, \frac 2 5, \frac 3 7}, \frac 1 2, \frac 4 7, \frac 3 5, \frac
5 8, \frac 2 3, \frac 5 7, \frac 3 4, \frac 4 5, \frac 5 6, \frac 6 7, \frac 7
8$$

It can be seen that there are $3$ fractions between $\dfrac 1 3$ and $\dfrac 1
2$.

How many fractions lie between $\dfrac 1 3$ and $\dfrac 1 2$ in the sorted set
of reduced proper fractions for $d \le 12\,000$?

** code p73
#+begin_src odin :main no :comments link :tangle src/counting_fractions_in_range.odin
package counting_fractions_in_range

import "core:fmt"
import "core:math"
import "core:slice"

Fracs :: struct {
	n : int,
	d : int,
}

less :: proc(a, b: Fracs) -> bool {
	return (a.n * b.d) < (b.n * a.d)
}

main :: proc() {
	fracs : [dynamic]Fracs

	MAX := 12_000
	c := Fracs{1,3}
	cnt := 0

	for denom in 4..=MAX { // start at 4, so that 1/3 doesn't get added
		//fmt.println("at", denom)
		for i in c.n*denom/c.d..=1*denom/2 {
			if math.gcd(i,denom) == 1 {
				//fmt.println("considering", i, "/", denom)
				tmp := Fracs{i,denom}
				if less(tmp, Fracs{1,2}) && !less(tmp, c) {
					//fmt.println("adding", i, "/", denom)
					cnt += 1
				}
			}
		}
	}
	fmt.println(cnt)
}
#+end_src

* Prob 074 - Digit Factorial Chains
** prob p74
The number $145$ is well known for the property that the sum of the factorial of
its digits is equal to $145$: $$1! + 4! + 5! = 1 + 24 + 120 = 145.$$

Perhaps less well known is $169$, in that it produces the longest chain of
numbers that link back to $169$; it turns out that there are only three such
loops that exist:

$$\begin{aligned}
&169 \to 363601 \to 1454 \to 169 \\\\
&872 \to 45362 \to 872
\end{aligned}$$

It is not difficult to prove that EVERY starting number will eventually get
stuck in a loop. For example,

$$\begin{aligned}
&69 \to 363600 \to 1454 \to 169 \to 363601 (\to 1454) \\\\
&78 \to 45360 \to 871 \to 45361 (\to 871) \\\\
&540 \to 145 (\to 145)
\end{aligned}$$

Starting with $69$ produces a chain of five non-repeating terms, but the longest
non-repeating chain with a starting number below one million is sixty terms.

How many chains, with a starting number below one million, contain exactly sixty
non-repeating terms?

** code p74
#+begin_src odin :main no :comments link :tangle src/digit_factorial_chains.odin
package digit_factorial_chains

import "core:fmt"
import "core:math"
import "core:strconv"

make_new_n :: proc(n: int) -> int {
	@static buf : []u8
	if buf == nil {
		buf = make([]u8, 100)
	}
	
	// make new n by adding factorial of digits
	new_n : int = 0
	n_str := strconv.itoa(buf, n)
	for i in 0..<len(n_str) {
		tmp := math.factorial(strconv._digit_value(rune(n_str[i])))
		new_n += tmp
	}
	return new_n
}

main :: proc() {
	MAX := 999999
	chain : [dynamic]int
	in_chain :: proc(n: int, chain: [dynamic]int) -> bool {
		for i in chain {
			if n == i {
				return true
			}
		}
		return false
	}

	cnt := 0
	for nn in 1..=MAX {
		n := nn
		clear(&chain)
		append(&chain, n)
		for ;; {
			new_n := make_new_n(n)
			if !in_chain(new_n, chain) {
				append(&chain, new_n)
				n = new_n
			} else {
				break
			}
		}

		if len(chain) == 60 {
			cnt += 1
			fmt.println(len(chain), chain)
		}
	}
	fmt.println(cnt)
}
#+end_src
* Prob 075 - Singular Integer Right Triangles
** prob p75
It turns out that $\pu{12 cm}$ is the smallest length of wire that can be bent
to form an integer sided right angle triangle in exactly one way, but there are
many more examples.

- $\pu{\mathbf{12} \mathbf{cm}}$: $(3,4,5)$
- $\pu{\mathbf{24} \mathbf{cm}}$: $(6,8,10)$
- $\pu{\mathbf{30} \mathbf{cm}}$: $(5,12,13)$
- $\pu{\mathbf{36} \mathbf{cm}}$: $(9,12,15)$
- $\pu{\mathbf{40} \mathbf{cm}}$: $(8,15,17)$
- $\pu{\mathbf{48} \mathbf{cm}}$: $(12,16,20)$

In contrast, some lengths of wire, like $\pu{20 cm}$, cannot be bent to form an
integer sided right angle triangle, and other lengths allow more than one
solution to be found; for example, using $\pu{120 cm}$ it is possible to form
exactly three different integer sided right angle triangles.

- $\pu{\mathbf{120} \mathbf{cm}}$: $(30,40,50)$, $(20,48,52)$, $(24,45,51)$

Given that $L$ is the length of the wire, for how many values of $L \le
1\,500\,000$ can exactly one integer sided right angle triangle be formed?

** code p75
#+begin_src odin :main no :comments link :tangle src/singular_integer_right_triangles.odin
package singular_integer_right_triangles

import "core:fmt"
import "core:math"

is_primative_tri :: proc(a, b, c: int) -> bool {
	tmp := math.gcd(math.gcd(a, b), c)
	return tmp == 1
}

main :: proc() {
	c := 0
	has_exactly_one := 0
	L :: 1_500_000
	//L :: 48
	cnts := make([]u8, L+1); defer delete(cnts)

	// a = m^2 - n^2
	// b = 2mn
	// c = m^2 + n^2
	// a+b+c = 2m(m+n) <= L
	// 2mn <= L/2m^2
	// n <= 2mL/2m^2 <= L/2m ... best to just reference the wiki @ https://en.wikipedia.org/wiki/Pythagorean_triple
	for m in 2..=int(math.sqrt(f64(L/2))) {
		for n in 1..<m {
			if math.gcd(m, n) == 1 && (m%2 != n%2) {
				a := m*m - n*n
				b := 2*m*n
				c := m*m + n*n
				abc := a+b+c
				if abc <= L {
					//fmt.println("adding", a, b, c)
					cnts[abc] += 1
					if cnts[abc] >= 1 {
						for k := 2; abc*k <= L; k += 1 {
							cnts[abc*k] += 1
						}
					}
				}
			}
		}
	}
	
	for i in cnts {
		if i == 1 {
			has_exactly_one += 1
		}
	}
	fmt.println(has_exactly_one)
}
#+end_src
* Prob 076 - Counting Summations
** prob p76
It is possible to write five as a sum in exactly six different ways:

$$\begin{aligned}
&4 + 1 \\\\
&3 + 2 \\\\
&3 + 1 + 1 \\\\
&2 + 2 + 1 \\\\
&2 + 1 + 1 + 1 \\\\
&1 + 1 + 1 + 1 + 1
\end{aligned}$$

How many different ways can one hundred be written as a sum of at least two positive integers?
** code p76
#+begin_src odin :main no :comments link :tangle src/counting_summations.odin
package counting_summations

import "core:fmt"

// 2 is 1+1
// 3 is 1+1+1, 2+1
// 4 is 1+1+1(+1), 2+1(+1).. 2+2, 3+1
// 5 is 1+1+1+1(+1), 2+1+1(+1), 2+2(+1), 3+1(+1).. 3+2, 4+1

count_partitions :: proc(num: int, top: int) -> int {
	@static seen_before : map[string]int
	s := fmt.tprint("%v%v", num, top)
	if s in seen_before {
		return seen_before[s]
	}
	cnt := 0
	if num == 0 {
		cnt = 0
	} else if num == 1 {
		cnt = 1
	} else {
		for i in 1..=top {
			cnt += count_partitions(num - i, min(num - i, i))
		}
		if num <= top {
			cnt += 1
		}
	}
	seen_before[s] = cnt
	return cnt
}

main :: proc() {
  NUM :: 100
	fmt.println(count_partitions(NUM, NUM)-1)
}
#+end_src
* Prob 077 - Prime Summations
** prob p77
It is possible to write ten as the sum of primes in exactly five different ways:

$$\begin{aligned}
&7 + 3 \\\\
&5 + 5 \\\\
&5 + 3 + 2 \\\\
&3 + 3 + 2 + 2 \\\\
&2 + 2 + 2 + 2 + 2
\end{aligned}$$

What is the first value which can be written as the sum of primes in over five thousand different ways?

** code p77
#+begin_src odin :main no :comments link :tangle src/prime_summations.odin
package prime_summations

import "core:fmt"
import "core:strings"
import "core:strconv"
import "../util"

prime_sums :: proc() {
	make_add_string :: proc(num: int, s: string) -> string {
		// make a string, putting num at proper place into new "adding string"
		tmp := strings.split(s, "+"); defer delete(tmp)
		builder := strings.builder_make()

		writ := false
		for n,i in tmp {
			nn,_ := strconv.parse_int(n)
			end  := (i==len(tmp)-1) ? "" : "+"
			if !writ && num >= nn {
				strings.write_string(&builder, fmt.tprintf("%d+%s%s", num, n, end))
				writ = true
			} else {
				strings.write_string(&builder, fmt.tprintf("%s%s", n, end))
			}
		}
		if !writ {
			strings.write_string(&builder, fmt.tprintf("+%d", num))
		}
		return strings.to_string(builder)
	}
  contains :: proc(list: ^[dynamic]string, str: string) -> bool {
		for s in list {
			if str == s {
				return true
			}
		}
		return false
	}
	
	diff_ways := 5000 // find first value that can be written in this many different ways
	ways : map[int](^[dynamic]string)
	for i:=4; ; i+=1 {
		ways[i] = new([dynamic]string)
		if i == 4 {
			append(ways[i], "2+2")
		} else if i == 5 {
			append(ways[i], "3+2")
		} else {
			for tmp:=i-2; tmp>=(i/2); tmp-=1 {
				if util.is_prime(tmp) && util.is_prime(i-tmp) { // add new found prime pairs
					append(ways[i], fmt.tprintf("%v+%v", tmp, i-tmp))
				}
				if tmp >= 4 && util.is_prime(i-tmp) {
					for s in ways[tmp] {
						ss := make_add_string(i-tmp, s)
						if !contains(ways[i], ss) {
							append(ways[i], ss)
						}
					}
				}
			}
		}
		if len(ways[i]) >= diff_ways {
			fmt.println("FOUND @", i)
			break
		}
	}
}

main :: proc() {
	prime_sums()
}
#+end_src
* Prob 078 - Coin Partitions
** prob p78
Let $p(n)$ represent the number of different ways in which $n$ coins can be
separated into piles. For example, five coins can be separated into piles in
exactly seven different ways, so $p(5)=7$.

$$\begin{aligned}
&OOOOO~~~ \\\\
&OOOO~~~O \\
&OOO~~~OO \\
&OOO~~~O~~~O \\
&OO~~~OO~~~O \\
&OO~~~O~~~O~~~O \\
&O~~~O~~~O~~~O~~~O
\end{aligned}$$

Find the least value of $n$ for which $p(n)$ is divisible by one million.

*Euler's Pentagonal number theorem?:*

Relation with partitions. The identity implies a recurrence for calculating

$$p(n) = p(n-1) + p(n-2) - p(n-5) - p(n-7)...$$

or more formally,

$$p(n)=\sum_{k\neq0 }(-1)^{k-1 }p(n-g_{k })$$

with, $$g_k = k(3k - 1)/2 ~ for ~ k = 1, -1, 2, -2, 3, ...$$
also, $$g_k = g_{k-1 } + 3k-2 ~ for ~ k = 1,2,3,...$$
AND!, $$g_k = 2g_{k-1 } - g_{k-2 } + 3 ~ for ~ k = 1,2,3,...$$

note: last two recursive g_k forms won't work with negative k's

** code p78
#+begin_src odin :main no :comments link :tangle src/coin_partitions.odin
package coin_partitions

import "core:fmt"
import "core:math/big"

gen_pentagonal_number :: proc(n: int, gn1, gn2: int) -> (pos: int, neg: int) {
	pos = (gn1<<1) - gn2 + 3
	//neg = ((pos * 2) + 2*n)/2 // note: here all magic number 2's so we can shift
	neg = ((pos<<1) + (n<<1)) >> 1
	return
}

gen_pentagonal_number_list :: proc(size: int) -> []int {
	@static gplist : [dynamic]int
	if len(gplist) == 0 { // some setup
		append(&gplist, 1)
		append(&gplist, 2)
		append(&gplist, 5)
		append(&gplist, 7)
	}
	assert(len(gplist) % 2 == 0)
	if len(gplist) < size { // make list big 'enuf
		nth := len(gplist)
		for ; nth < size; nth+=2 {
			i := nth/2
			gn1 := gplist[nth-2]
			gn2 := gplist[nth-4]
			p, n := gen_pentagonal_number(i+1, gn1, gn2)

			append(&gplist, p)
			append(&gplist, n)
		}
	}
	return gplist[:]
}

coin_partitions :: proc() {
	// partitions:   p(n) = p(n-1) + p(n-2) - p(n-5) - p(n-7) + ...
	// the numbers above are from general pentagonal numbers with anything p(-X) being 0
	WITH_BIG_INT :: true
  MIL :: 1_000_000
	MAX :: 100_000
	int2 :: struct {
		i : int,
		big_i : big.Int,
	}
	p := make([]int2, MAX); defer delete(p)
	p[0].i = 1 // 1 way to stack 0 coins
	big.set(&p[0].big_i, 1)
	p[1].i = 1 // 1 way to stack 1 coin
	big.set(&p[1].big_i, 1)

	for n in 2..<MAX {
		for gk, idx in gen_pentagonal_number_list(MAX-1) {
			if (n-gk) < 0 {
				break
			}

			tmp := p[n-gk].i
			tmp_big : big.Int
			when WITH_BIG_INT {
				big.set(&tmp_big, &p[n-gk].big_i)
			}

			if (idx/2) % 2 == 0 {
				p[n].i += tmp
				when WITH_BIG_INT {
					big.add(&p[n].big_i, &p[n].big_i, &tmp_big)
				}
			} else {
				p[n].i -= tmp
				when WITH_BIG_INT {
					big.sub(&p[n].big_i, &p[n].big_i, &tmp_big)
				}
			}
		}

		p[n].i %= MIL
		if p[n].i == 0 {
			fmt.printf("FOUND %v\n", n)
			when WITH_BIG_INT {
				// this is a pretty big number here, "turn off" WITH_BIG_INT to speed things up
				num_str, err := big.itoa(&p[n].big_i)
				fmt.printf("%v\n", num_str)
			}
			break
		}
	}
}

main :: proc() {
	coin_partitions()
}
#+end_src
* Prob 079 - Passcode Derivation
** prob p79
A common security method used for online banking is to ask the user for three
random characters from a passcode. For example, if the passcode was 531278, they
may ask for the 2nd, 3rd, and 5th characters; the expected reply would be: 317.

The text file, keylog.txt,
contains fifty successful login attempts.

Given that the three characters are always asked for in order, analyse the file
so as to determine the shortest possible secret passcode of unknown length.

** code p79
#+begin_src text :tangle src/keylog.txt
319
680
180
690
129
620
762
689
762
318
368
710
720
710
629
168
160
689
716
731
736
729
316
729
729
710
769
290
719
680
318
389
162
289
162
718
729
319
790
680
890
362
319
760
316
729
380
319
728
716
#+end_src
#+begin_src odin :main no :comments link :tangle src/passcode_derivation.odin
package passcode_derivation

import "core:os"
import "core:fmt"
import "core:strings"

contains :: proc(list: ^[dynamic]u8, r: u8) -> bool {
	for i in list {
		if i == r {
			return true
		}
	}
	return false
}

main :: proc() {
	data, ok := os.read_entire_file("keylog.txt")
	symbols : [dynamic]u8
	lines : []string
	if ok {
		lines = strings.split(string(data), "\n")
		for l,idx in lines { // get all symbols
			for i in 0..<len(l) {
				if l[i] != 13 && l[i] != 10 { // no newlines or returns
					if !contains(&symbols, u8(l[i])) {
						append(&symbols, u8(l[i]))
					}
				}
			}
		}
	}

	order :: proc(l: string, symbols: ^[dynamic]u8) {
		// look for l[x] then l[y] and if the index of l[x] isn't < that of l[y]'s return false
		assert(len(l)>2)
		x := u8(l[0])
		for i in 1..<len(l) {
			if strings.is_space(rune(l[i])) {
				break
			}
			y := u8(l[i])
			xx := strings.index(string(symbols[:]), fmt.tprintf("%c", x))
			yy := strings.index(string(symbols[:]), fmt.tprintf("%c", y))
			if xx > yy {
				// move xx to be before yy
				tmp := symbols[yy]
				assign_at(symbols, yy, symbols[xx])
				ordered_remove(symbols, xx)
				inject_at(symbols, yy+1, tmp)
			}
			x = y
		}
	}
	
	if ok {
		for l,idx in lines { // re-order symbols
			if len(l)>2 {
				order(l, &symbols) // note: duplicate symbols in the actual passcode would derp this out
			}
		}
		fmt.println(string(symbols[:]))
	}
}
#+end_src
* Prob 080 - Square Root Digital Expansion
** prob p80
It is well known that if the square root of a natural number is not an integer,
then it is irrational. The decimal expansion of such square roots is infinite
without any repeating pattern at all.

The square root of two is $1.41421356237309504880\cdots$, and the digital sum of
the first one hundred decimal digits is $475$.

For the first one hundred natural numbers, find the total of the digital sums of
the first one hundred decimal digits for all the irrational square roots.

** code p80
#+begin_src odin :main no :comments link :tangle src/square_root_digital_expansion.odin

package square_root_digital_expansion

import "core:fmt"
import "core:math"
import "core:math/big"
import "core:strconv"

sum_digits :: proc(s: string) -> int {
	// sum of digits in a string s
	cnt := 0
	for i in s {
		cnt += strconv._digit_value(i)
	}
	return cnt
}

main :: proc() {
	// some setup
	bigbig : big.Int
	big.set(&bigbig, 10)
	big.exp(&bigbig, &bigbig, 99) // (10^100)
	big.exp(&bigbig, &bigbig, 2) // (10^100)^2... for 100 decimal places

	acc := 0
	for i in 2..=100 {
		ii : big.Int
		big.set(&ii, i) // set to 2
		big.mul(&ii, &ii, &bigbig) // give 2 100 "places"
	
		iisqrt : big.Int
		big.sqrt(&iisqrt, &ii)
		sqrt_str, err2 := big.itoa(&iisqrt)
		
		tmp := sum_digits(sqrt_str)
		irr : bool = tmp > 9
		//fmt.println(sqrt_str, tmp, irr)
		if irr {
			acc += tmp
		}
	}
	fmt.println(acc)
}
#+end_src

* Prob 081 - Path Sum: Two Ways
** prob p81
In the $5$ by $5$ matrix below, the minimal path sum from the top left to the
bottom right, by *only moving to the right and down*, is indicated in bold
red and is equal to $2427$.

$$\begin{pmatrix}
\color{red}{131} & 673 & 234 & 103 & 18 \\\\
\color{red}{201} & \color{red}{96} & \color{red}{342} & 965 & 150 \\
630 & 803 & \color{red}{746} & \color{red}{422} & 111 \\
537 & 699 & 497 & \color{red}{121} & 956 \\
805 & 732 & 524 & \color{red}{37} & \color{red}{331}
\end{pmatrix}$$

Find the minimal path sum from the top left to the bottom right by only moving
right and down -- matrix.txt.

** code p81
#+begin_src text :tangle src/matrix.txt
4445,2697,5115,718,2209,2212,654,4348,3079,6821,7668,3276,8874,4190,3785,2752,9473,7817,9137,496,7338,3434,7152,4355,4552,7917,7827,2460,2350,691,3514,5880,3145,7633,7199,3783,5066,7487,3285,1084,8985,760,872,8609,8051,1134,9536,5750,9716,9371,7619,5617,275,9721,2997,2698,1887,8825,6372,3014,2113,7122,7050,6775,5948,2758,1219,3539,348,7989,2735,9862,1263,8089,6401,9462,3168,2758,3748,5870
1096,20,1318,7586,5167,2642,1443,5741,7621,7030,5526,4244,2348,4641,9827,2448,6918,5883,3737,300,7116,6531,567,5997,3971,6623,820,6148,3287,1874,7981,8424,7672,7575,6797,6717,1078,5008,4051,8795,5820,346,1851,6463,2117,6058,3407,8211,117,4822,1317,4377,4434,5925,8341,4800,1175,4173,690,8978,7470,1295,3799,8724,3509,9849,618,3320,7068,9633,2384,7175,544,6583,1908,9983,481,4187,9353,9377
9607,7385,521,6084,1364,8983,7623,1585,6935,8551,2574,8267,4781,3834,2764,2084,2669,4656,9343,7709,2203,9328,8004,6192,5856,3555,2260,5118,6504,1839,9227,1259,9451,1388,7909,5733,6968,8519,9973,1663,5315,7571,3035,4325,4283,2304,6438,3815,9213,9806,9536,196,5542,6907,2475,1159,5820,9075,9470,2179,9248,1828,4592,9167,3713,4640,47,3637,309,7344,6955,346,378,9044,8635,7466,5036,9515,6385,9230
7206,3114,7760,1094,6150,5182,7358,7387,4497,955,101,1478,7777,6966,7010,8417,6453,4955,3496,107,449,8271,131,2948,6185,784,5937,8001,6104,8282,4165,3642,710,2390,575,715,3089,6964,4217,192,5949,7006,715,3328,1152,66,8044,4319,1735,146,4818,5456,6451,4113,1063,4781,6799,602,1504,6245,6550,1417,1343,2363,3785,5448,4545,9371,5420,5068,4613,4882,4241,5043,7873,8042,8434,3939,9256,2187
3620,8024,577,9997,7377,7682,1314,1158,6282,6310,1896,2509,5436,1732,9480,706,496,101,6232,7375,2207,2306,110,6772,3433,2878,8140,5933,8688,1399,2210,7332,6172,6403,7333,4044,2291,1790,2446,7390,8698,5723,3678,7104,1825,2040,140,3982,4905,4160,2200,5041,2512,1488,2268,1175,7588,8321,8078,7312,977,5257,8465,5068,3453,3096,1651,7906,253,9250,6021,8791,8109,6651,3412,345,4778,5152,4883,7505
1074,5438,9008,2679,5397,5429,2652,3403,770,9188,4248,2493,4361,8327,9587,707,9525,5913,93,1899,328,2876,3604,673,8576,6908,7659,2544,3359,3883,5273,6587,3065,1749,3223,604,9925,6941,2823,8767,7039,3290,3214,1787,7904,3421,7137,9560,8451,2669,9219,6332,1576,5477,6755,8348,4164,4307,2984,4012,6629,1044,2874,6541,4942,903,1404,9125,5160,8836,4345,2581,460,8438,1538,5507,668,3352,2678,6942
4295,1176,5596,1521,3061,9868,7037,7129,8933,6659,5947,5063,3653,9447,9245,2679,767,714,116,8558,163,3927,8779,158,5093,2447,5782,3967,1716,931,7772,8164,1117,9244,5783,7776,3846,8862,6014,2330,6947,1777,3112,6008,3491,1906,5952,314,4602,8994,5919,9214,3995,5026,7688,6809,5003,3128,2509,7477,110,8971,3982,8539,2980,4689,6343,5411,2992,5270,5247,9260,2269,7474,1042,7162,5206,1232,4556,4757
510,3556,5377,1406,5721,4946,2635,7847,4251,8293,8281,6351,4912,287,2870,3380,3948,5322,3840,4738,9563,1906,6298,3234,8959,1562,6297,8835,7861,239,6618,1322,2553,2213,5053,5446,4402,6500,5182,8585,6900,5756,9661,903,5186,7687,5998,7997,8081,8955,4835,6069,2621,1581,732,9564,1082,1853,5442,1342,520,1737,3703,5321,4793,2776,1508,1647,9101,2499,6891,4336,7012,3329,3212,1442,9993,3988,4930,7706
9444,3401,5891,9716,1228,7107,109,3563,2700,6161,5039,4992,2242,8541,7372,2067,1294,3058,1306,320,8881,5756,9326,411,8650,8824,5495,8282,8397,2000,1228,7817,2099,6473,3571,5994,4447,1299,5991,543,7874,2297,1651,101,2093,3463,9189,6872,6118,872,1008,1779,2805,9084,4048,2123,5877,55,3075,1737,9459,4535,6453,3644,108,5982,4437,5213,1340,6967,9943,5815,669,8074,1838,6979,9132,9315,715,5048
3327,4030,7177,6336,9933,5296,2621,4785,2755,4832,2512,2118,2244,4407,2170,499,7532,9742,5051,7687,970,6924,3527,4694,5145,1306,2165,5940,2425,8910,3513,1909,6983,346,6377,4304,9330,7203,6605,3709,3346,970,369,9737,5811,4427,9939,3693,8436,5566,1977,3728,2399,3985,8303,2492,5366,9802,9193,7296,1033,5060,9144,2766,1151,7629,5169,5995,58,7619,7565,4208,1713,6279,3209,4908,9224,7409,1325,8540
6882,1265,1775,3648,4690,959,5837,4520,5394,1378,9485,1360,4018,578,9174,2932,9890,3696,116,1723,1178,9355,7063,1594,1918,8574,7594,7942,1547,6166,7888,354,6932,4651,1010,7759,6905,661,7689,6092,9292,3845,9605,8443,443,8275,5163,7720,7265,6356,7779,1798,1754,5225,6661,1180,8024,5666,88,9153,1840,3508,1193,4445,2648,3538,6243,6375,8107,5902,5423,2520,1122,5015,6113,8859,9370,966,8673,2442
7338,3423,4723,6533,848,8041,7921,8277,4094,5368,7252,8852,9166,2250,2801,6125,8093,5738,4038,9808,7359,9494,601,9116,4946,2702,5573,2921,9862,1462,1269,2410,4171,2709,7508,6241,7522,615,2407,8200,4189,5492,5649,7353,2590,5203,4274,710,7329,9063,956,8371,3722,4253,4785,1194,4828,4717,4548,940,983,2575,4511,2938,1827,2027,2700,1236,841,5760,1680,6260,2373,3851,1841,4968,1172,5179,7175,3509
4420,1327,3560,2376,6260,2988,9537,4064,4829,8872,9598,3228,1792,7118,9962,9336,4368,9189,6857,1829,9863,6287,7303,7769,2707,8257,2391,2009,3975,4993,3068,9835,3427,341,8412,2134,4034,8511,6421,3041,9012,2983,7289,100,1355,7904,9186,6920,5856,2008,6545,8331,3655,5011,839,8041,9255,6524,3862,8788,62,7455,3513,5003,8413,3918,2076,7960,6108,3638,6999,3436,1441,4858,4181,1866,8731,7745,3744,1000
356,8296,8325,1058,1277,4743,3850,2388,6079,6462,2815,5620,8495,5378,75,4324,3441,9870,1113,165,1544,1179,2834,562,6176,2313,6836,8839,2986,9454,5199,6888,1927,5866,8760,320,1792,8296,7898,6121,7241,5886,5814,2815,8336,1576,4314,3109,2572,6011,2086,9061,9403,3947,5487,9731,7281,3159,1819,1334,3181,5844,5114,9898,4634,2531,4412,6430,4262,8482,4546,4555,6804,2607,9421,686,8649,8860,7794,6672
9870,152,1558,4963,8750,4754,6521,6256,8818,5208,5691,9659,8377,9725,5050,5343,2539,6101,1844,9700,7750,8114,5357,3001,8830,4438,199,9545,8496,43,2078,327,9397,106,6090,8181,8646,6414,7499,5450,4850,6273,5014,4131,7639,3913,6571,8534,9703,4391,7618,445,1320,5,1894,6771,7383,9191,4708,9706,6939,7937,8726,9382,5216,3685,2247,9029,8154,1738,9984,2626,9438,4167,6351,5060,29,1218,1239,4785
192,5213,8297,8974,4032,6966,5717,1179,6523,4679,9513,1481,3041,5355,9303,9154,1389,8702,6589,7818,6336,3539,5538,3094,6646,6702,6266,2759,4608,4452,617,9406,8064,6379,444,5602,4950,1810,8391,1536,316,8714,1178,5182,5863,5110,5372,4954,1978,2971,5680,4863,2255,4630,5723,2168,538,1692,1319,7540,440,6430,6266,7712,7385,5702,620,641,3136,7350,1478,3155,2820,9109,6261,1122,4470,14,8493,2095
1046,4301,6082,474,4974,7822,2102,5161,5172,6946,8074,9716,6586,9962,9749,5015,2217,995,5388,4402,7652,6399,6539,1349,8101,3677,1328,9612,7922,2879,231,5887,2655,508,4357,4964,3554,5930,6236,7384,4614,280,3093,9600,2110,7863,2631,6626,6620,68,1311,7198,7561,1768,5139,1431,221,230,2940,968,5283,6517,2146,1646,869,9402,7068,8645,7058,1765,9690,4152,2926,9504,2939,7504,6074,2944,6470,7859
4659,736,4951,9344,1927,6271,8837,8711,3241,6579,7660,5499,5616,3743,5801,4682,9748,8796,779,1833,4549,8138,4026,775,4170,2432,4174,3741,7540,8017,2833,4027,396,811,2871,1150,9809,2719,9199,8504,1224,540,2051,3519,7982,7367,2761,308,3358,6505,2050,4836,5090,7864,805,2566,2409,6876,3361,8622,5572,5895,3280,441,7893,8105,1634,2929,274,3926,7786,6123,8233,9921,2674,5340,1445,203,4585,3837
5759,338,7444,7968,7742,3755,1591,4839,1705,650,7061,2461,9230,9391,9373,2413,1213,431,7801,4994,2380,2703,6161,6878,8331,2538,6093,1275,5065,5062,2839,582,1014,8109,3525,1544,1569,8622,7944,2905,6120,1564,1839,5570,7579,1318,2677,5257,4418,5601,7935,7656,5192,1864,5886,6083,5580,6202,8869,1636,7907,4759,9082,5854,3185,7631,6854,5872,5632,5280,1431,2077,9717,7431,4256,8261,9680,4487,4752,4286
1571,1428,8599,1230,7772,4221,8523,9049,4042,8726,7567,6736,9033,2104,4879,4967,6334,6716,3994,1269,8995,6539,3610,7667,6560,6065,874,848,4597,1711,7161,4811,6734,5723,6356,6026,9183,2586,5636,1092,7779,7923,8747,6887,7505,9909,1792,3233,4526,3176,1508,8043,720,5212,6046,4988,709,5277,8256,3642,1391,5803,1468,2145,3970,6301,7767,2359,8487,9771,8785,7520,856,1605,8972,2402,2386,991,1383,5963
1822,4824,5957,6511,9868,4113,301,9353,6228,2881,2966,6956,9124,9574,9233,1601,7340,973,9396,540,4747,8590,9535,3650,7333,7583,4806,3593,2738,8157,5215,8472,2284,9473,3906,6982,5505,6053,7936,6074,7179,6688,1564,1103,6860,5839,2022,8490,910,7551,7805,881,7024,1855,9448,4790,1274,3672,2810,774,7623,4223,4850,6071,9975,4935,1915,9771,6690,3846,517,463,7624,4511,614,6394,3661,7409,1395,8127
8738,3850,9555,3695,4383,2378,87,6256,6740,7682,9546,4255,6105,2000,1851,4073,8957,9022,6547,5189,2487,303,9602,7833,1628,4163,6678,3144,8589,7096,8913,5823,4890,7679,1212,9294,5884,2972,3012,3359,7794,7428,1579,4350,7246,4301,7779,7790,3294,9547,4367,3549,1958,8237,6758,3497,3250,3456,6318,1663,708,7714,6143,6890,3428,6853,9334,7992,591,6449,9786,1412,8500,722,5468,1371,108,3939,4199,2535
7047,4323,1934,5163,4166,461,3544,2767,6554,203,6098,2265,9078,2075,4644,6641,8412,9183,487,101,7566,5622,1975,5726,2920,5374,7779,5631,3753,3725,2672,3621,4280,1162,5812,345,8173,9785,1525,955,5603,2215,2580,5261,2765,2990,5979,389,3907,2484,1232,5933,5871,3304,1138,1616,5114,9199,5072,7442,7245,6472,4760,6359,9053,7876,2564,9404,3043,9026,2261,3374,4460,7306,2326,966,828,3274,1712,3446
3975,4565,8131,5800,4570,2306,8838,4392,9147,11,3911,7118,9645,4994,2028,6062,5431,2279,8752,2658,7836,994,7316,5336,7185,3289,1898,9689,2331,5737,3403,1124,2679,3241,7748,16,2724,5441,6640,9368,9081,5618,858,4969,17,2103,6035,8043,7475,2181,939,415,1617,8500,8253,2155,7843,7974,7859,1746,6336,3193,2617,8736,4079,6324,6645,8891,9396,5522,6103,1857,8979,3835,2475,1310,7422,610,8345,7615
9248,5397,5686,2988,3446,4359,6634,9141,497,9176,6773,7448,1907,8454,916,1596,2241,1626,1384,2741,3649,5362,8791,7170,2903,2475,5325,6451,924,3328,522,90,4813,9737,9557,691,2388,1383,4021,1609,9206,4707,5200,7107,8104,4333,9860,5013,1224,6959,8527,1877,4545,7772,6268,621,4915,9349,5970,706,9583,3071,4127,780,8231,3017,9114,3836,7503,2383,1977,4870,8035,2379,9704,1037,3992,3642,1016,4303
5093,138,4639,6609,1146,5565,95,7521,9077,2272,974,4388,2465,2650,722,4998,3567,3047,921,2736,7855,173,2065,4238,1048,5,6847,9548,8632,9194,5942,4777,7910,8971,6279,7253,2516,1555,1833,3184,9453,9053,6897,7808,8629,4877,1871,8055,4881,7639,1537,7701,2508,7564,5845,5023,2304,5396,3193,2955,1088,3801,6203,1748,3737,1276,13,4120,7715,8552,3047,2921,106,7508,304,1280,7140,2567,9135,5266
6237,4607,7527,9047,522,7371,4883,2540,5867,6366,5301,1570,421,276,3361,527,6637,4861,2401,7522,5808,9371,5298,2045,5096,5447,7755,5115,7060,8529,4078,1943,1697,1764,5453,7085,960,2405,739,2100,5800,728,9737,5704,5693,1431,8979,6428,673,7540,6,7773,5857,6823,150,5869,8486,684,5816,9626,7451,5579,8260,3397,5322,6920,1879,2127,2884,5478,4977,9016,6165,6292,3062,5671,5968,78,4619,4763
9905,7127,9390,5185,6923,3721,9164,9705,4341,1031,1046,5127,7376,6528,3248,4941,1178,7889,3364,4486,5358,9402,9158,8600,1025,874,1839,1783,309,9030,1843,845,8398,1433,7118,70,8071,2877,3904,8866,6722,4299,10,1929,5897,4188,600,1889,3325,2485,6473,4474,7444,6992,4846,6166,4441,2283,2629,4352,7775,1101,2214,9985,215,8270,9750,2740,8361,7103,5930,8664,9690,8302,9267,344,2077,1372,1880,9550
5825,8517,7769,2405,8204,1060,3603,7025,478,8334,1997,3692,7433,9101,7294,7498,9415,5452,3850,3508,6857,9213,6807,4412,7310,854,5384,686,4978,892,8651,3241,2743,3801,3813,8588,6701,4416,6990,6490,3197,6838,6503,114,8343,5844,8646,8694,65,791,5979,2687,2621,2019,8097,1423,3644,9764,4921,3266,3662,5561,2476,8271,8138,6147,1168,3340,1998,9874,6572,9873,6659,5609,2711,3931,9567,4143,7833,8887
6223,2099,2700,589,4716,8333,1362,5007,2753,2848,4441,8397,7192,8191,4916,9955,6076,3370,6396,6971,3156,248,3911,2488,4930,2458,7183,5455,170,6809,6417,3390,1956,7188,577,7526,2203,968,8164,479,8699,7915,507,6393,4632,1597,7534,3604,618,3280,6061,9793,9238,8347,568,9645,2070,5198,6482,5000,9212,6655,5961,7513,1323,3872,6170,3812,4146,2736,67,3151,5548,2781,9679,7564,5043,8587,1893,4531
5826,3690,6724,2121,9308,6986,8106,6659,2142,1642,7170,2877,5757,6494,8026,6571,8387,9961,6043,9758,9607,6450,8631,8334,7359,5256,8523,2225,7487,1977,9555,8048,5763,2414,4948,4265,2427,8978,8088,8841,9208,9601,5810,9398,8866,9138,4176,5875,7212,3272,6759,5678,7649,4922,5422,1343,8197,3154,3600,687,1028,4579,2084,9467,4492,7262,7296,6538,7657,7134,2077,1505,7332,6890,8964,4879,7603,7400,5973,739
1861,1613,4879,1884,7334,966,2000,7489,2123,4287,1472,3263,4726,9203,1040,4103,6075,6049,330,9253,4062,4268,1635,9960,577,1320,3195,9628,1030,4092,4979,6474,6393,2799,6967,8687,7724,7392,9927,2085,3200,6466,8702,265,7646,8665,7986,7266,4574,6587,612,2724,704,3191,8323,9523,3002,704,5064,3960,8209,2027,2758,8393,4875,4641,9584,6401,7883,7014,768,443,5490,7506,1852,2005,8850,5776,4487,4269
4052,6687,4705,7260,6645,6715,3706,5504,8672,2853,1136,8187,8203,4016,871,1809,1366,4952,9294,5339,6872,2645,6083,7874,3056,5218,7485,8796,7401,3348,2103,426,8572,4163,9171,3176,948,7654,9344,3217,1650,5580,7971,2622,76,2874,880,2034,9929,1546,2659,5811,3754,7096,7436,9694,9960,7415,2164,953,2360,4194,2397,1047,2196,6827,575,784,2675,8821,6802,7972,5996,6699,2134,7577,2887,1412,4349,4380
4629,2234,6240,8132,7592,3181,6389,1214,266,1910,2451,8784,2790,1127,6932,1447,8986,2492,5476,397,889,3027,7641,5083,5776,4022,185,3364,5701,2442,2840,4160,9525,4828,6602,2614,7447,3711,4505,7745,8034,6514,4907,2605,7753,6958,7270,6936,3006,8968,439,2326,4652,3085,3425,9863,5049,5361,8688,297,7580,8777,7916,6687,8683,7141,306,9569,2384,1500,3346,4601,7329,9040,6097,2727,6314,4501,4974,2829
8316,4072,2025,6884,3027,1808,5714,7624,7880,8528,4205,8686,7587,3230,1139,7273,6163,6986,3914,9309,1464,9359,4474,7095,2212,7302,2583,9462,7532,6567,1606,4436,8981,5612,6796,4385,5076,2007,6072,3678,8331,1338,3299,8845,4783,8613,4071,1232,6028,2176,3990,2148,3748,103,9453,538,6745,9110,926,3125,473,5970,8728,7072,9062,1404,1317,5139,9862,6496,6062,3338,464,1600,2532,1088,8232,7739,8274,3873
2341,523,7096,8397,8301,6541,9844,244,4993,2280,7689,4025,4196,5522,7904,6048,2623,9258,2149,9461,6448,8087,7245,1917,8340,7127,8466,5725,6996,3421,5313,512,9164,9837,9794,8369,4185,1488,7210,1524,1016,4620,9435,2478,7765,8035,697,6677,3724,6988,5853,7662,3895,9593,1185,4727,6025,5734,7665,3070,138,8469,6748,6459,561,7935,8646,2378,462,7755,3115,9690,8877,3946,2728,8793,244,6323,8666,4271
6430,2406,8994,56,1267,3826,9443,7079,7579,5232,6691,3435,6718,5698,4144,7028,592,2627,217,734,6194,8156,9118,58,2640,8069,4127,3285,694,3197,3377,4143,4802,3324,8134,6953,7625,3598,3584,4289,7065,3434,2106,7132,5802,7920,9060,7531,3321,1725,1067,3751,444,5503,6785,7937,6365,4803,198,6266,8177,1470,6390,1606,2904,7555,9834,8667,2033,1723,5167,1666,8546,8152,473,4475,6451,7947,3062,3281
2810,3042,7759,1741,2275,2609,7676,8640,4117,1958,7500,8048,1757,3954,9270,1971,4796,2912,660,5511,3553,1012,5757,4525,6084,7198,8352,5775,7726,8591,7710,9589,3122,4392,6856,5016,749,2285,3356,7482,9956,7348,2599,8944,495,3462,3578,551,4543,7207,7169,7796,1247,4278,6916,8176,3742,8385,2310,1345,8692,2667,4568,1770,8319,3585,4920,3890,4928,7343,5385,9772,7947,8786,2056,9266,3454,2807,877,2660
6206,8252,5928,5837,4177,4333,207,7934,5581,9526,8906,1498,8411,2984,5198,5134,2464,8435,8514,8674,3876,599,5327,826,2152,4084,2433,9327,9697,4800,2728,3608,3849,3861,3498,9943,1407,3991,7191,9110,5666,8434,4704,6545,5944,2357,1163,4995,9619,6754,4200,9682,6654,4862,4744,5953,6632,1054,293,9439,8286,2255,696,8709,1533,1844,6441,430,1999,6063,9431,7018,8057,2920,6266,6799,356,3597,4024,6665
3847,6356,8541,7225,2325,2946,5199,469,5450,7508,2197,9915,8284,7983,6341,3276,3321,16,1321,7608,5015,3362,8491,6968,6818,797,156,2575,706,9516,5344,5457,9210,5051,8099,1617,9951,7663,8253,9683,2670,1261,4710,1068,8753,4799,1228,2621,3275,6188,4699,1791,9518,8701,5932,4275,6011,9877,2933,4182,6059,2930,6687,6682,9771,654,9437,3169,8596,1827,5471,8909,2352,123,4394,3208,8756,5513,6917,2056
5458,8173,3138,3290,4570,4892,3317,4251,9699,7973,1163,1935,5477,6648,9614,5655,9592,975,9118,2194,7322,8248,8413,3462,8560,1907,7810,6650,7355,2939,4973,6894,3933,3784,3200,2419,9234,4747,2208,2207,1945,2899,1407,6145,8023,3484,5688,7686,2737,3828,3704,9004,5190,9740,8643,8650,5358,4426,1522,1707,3613,9887,6956,2447,2762,833,1449,9489,2573,1080,4167,3456,6809,2466,227,7125,2759,6250,6472,8089
3266,7025,9756,3914,1265,9116,7723,9788,6805,5493,2092,8688,6592,9173,4431,4028,6007,7131,4446,4815,3648,6701,759,3312,8355,4485,4187,5188,8746,7759,3528,2177,5243,8379,3838,7233,4607,9187,7216,2190,6967,2920,6082,7910,5354,3609,8958,6949,7731,494,8753,8707,1523,4426,3543,7085,647,6771,9847,646,5049,824,8417,5260,2730,5702,2513,9275,4279,2767,8684,1165,9903,4518,55,9682,8963,6005,2102,6523
1998,8731,936,1479,5259,7064,4085,91,7745,7136,3773,3810,730,8255,2705,2653,9790,6807,2342,355,9344,2668,3690,2028,9679,8102,574,4318,6481,9175,5423,8062,2867,9657,7553,3442,3920,7430,3945,7639,3714,3392,2525,4995,4850,2867,7951,9667,486,9506,9888,781,8866,1702,3795,90,356,1483,4200,2131,6969,5931,486,6880,4404,1084,5169,4910,6567,8335,4686,5043,2614,3352,2667,4513,6472,7471,5720,1616
8878,1613,1716,868,1906,2681,564,665,5995,2474,7496,3432,9491,9087,8850,8287,669,823,347,6194,2264,2592,7871,7616,8508,4827,760,2676,4660,4881,7572,3811,9032,939,4384,929,7525,8419,5556,9063,662,8887,7026,8534,3111,1454,2082,7598,5726,6687,9647,7608,73,3014,5063,670,5461,5631,3367,9796,8475,7908,5073,1565,5008,5295,4457,1274,4788,1728,338,600,8415,8535,9351,7750,6887,5845,1741,125
3637,6489,9634,9464,9055,2413,7824,9517,7532,3577,7050,6186,6980,9365,9782,191,870,2497,8498,2218,2757,5420,6468,586,3320,9230,1034,1393,9886,5072,9391,1178,8464,8042,6869,2075,8275,3601,7715,9470,8786,6475,8373,2159,9237,2066,3264,5000,679,355,3069,4073,494,2308,5512,4334,9438,8786,8637,9774,1169,1949,6594,6072,4270,9158,7916,5752,6794,9391,6301,5842,3285,2141,3898,8027,4310,8821,7079,1307
8497,6681,4732,7151,7060,5204,9030,7157,833,5014,8723,3207,9796,9286,4913,119,5118,7650,9335,809,3675,2597,5144,3945,5090,8384,187,4102,1260,2445,2792,4422,8389,9290,50,1765,1521,6921,8586,4368,1565,5727,7855,2003,4834,9897,5911,8630,5070,1330,7692,7557,7980,6028,5805,9090,8265,3019,3802,698,9149,5748,1965,9658,4417,5994,5584,8226,2937,272,5743,1278,5698,8736,2595,6475,5342,6596,1149,6920
8188,8009,9546,6310,8772,2500,9846,6592,6872,3857,1307,8125,7042,1544,6159,2330,643,4604,7899,6848,371,8067,2062,3200,7295,1857,9505,6936,384,2193,2190,301,8535,5503,1462,7380,5114,4824,8833,1763,4974,8711,9262,6698,3999,2645,6937,7747,1128,2933,3556,7943,2885,3122,9105,5447,418,2899,5148,3699,9021,9501,597,4084,175,1621,1,1079,6067,5812,4326,9914,6633,5394,4233,6728,9084,1864,5863,1225
9935,8793,9117,1825,9542,8246,8437,3331,9128,9675,6086,7075,319,1334,7932,3583,7167,4178,1726,7720,695,8277,7887,6359,5912,1719,2780,8529,1359,2013,4498,8072,1129,9998,1147,8804,9405,6255,1619,2165,7491,1,8882,7378,3337,503,5758,4109,3577,985,3200,7615,8058,5032,1080,6410,6873,5496,1466,2412,9885,5904,4406,3605,8770,4361,6205,9193,1537,9959,214,7260,9566,1685,100,4920,7138,9819,5637,976
3466,9854,985,1078,7222,8888,5466,5379,3578,4540,6853,8690,3728,6351,7147,3134,6921,9692,857,3307,4998,2172,5783,3931,9417,2541,6299,13,787,2099,9131,9494,896,8600,1643,8419,7248,2660,2609,8579,91,6663,5506,7675,1947,6165,4286,1972,9645,3805,1663,1456,8853,5705,9889,7489,1107,383,4044,2969,3343,152,7805,4980,9929,5033,1737,9953,7197,9158,4071,1324,473,9676,3984,9680,3606,8160,7384,5432
1005,4512,5186,3953,2164,3372,4097,3247,8697,3022,9896,4101,3871,6791,3219,2742,4630,6967,7829,5991,6134,1197,1414,8923,8787,1394,8852,5019,7768,5147,8004,8825,5062,9625,7988,1110,3992,7984,9966,6516,6251,8270,421,3723,1432,4830,6935,8095,9059,2214,6483,6846,3120,1587,6201,6691,9096,9627,6671,4002,3495,9939,7708,7465,5879,6959,6634,3241,3401,2355,9061,2611,7830,3941,2177,2146,5089,7079,519,6351
7280,8586,4261,2831,7217,3141,9994,9940,5462,2189,4005,6942,9848,5350,8060,6665,7519,4324,7684,657,9453,9296,2944,6843,7499,7847,1728,9681,3906,6353,5529,2822,3355,3897,7724,4257,7489,8672,4356,3983,1948,6892,7415,4153,5893,4190,621,1736,4045,9532,7701,3671,1211,1622,3176,4524,9317,7800,5638,6644,6943,5463,3531,2821,1347,5958,3436,1438,2999,994,850,4131,2616,1549,3465,5946,690,9273,6954,7991
9517,399,3249,2596,7736,2142,1322,968,7350,1614,468,3346,3265,7222,6086,1661,5317,2582,7959,4685,2807,2917,1037,5698,1529,3972,8716,2634,3301,3412,8621,743,8001,4734,888,7744,8092,3671,8941,1487,5658,7099,2781,99,1932,4443,4756,4652,9328,1581,7855,4312,5976,7255,6480,3996,2748,1973,9731,4530,2790,9417,7186,5303,3557,351,7182,9428,1342,9020,7599,1392,8304,2070,9138,7215,2008,9937,1106,7110
7444,769,9688,632,1571,6820,8743,4338,337,3366,3073,1946,8219,104,4210,6986,249,5061,8693,7960,6546,1004,8857,5997,9352,4338,6105,5008,2556,6518,6694,4345,3727,7956,20,3954,8652,4424,9387,2035,8358,5962,5304,5194,8650,8282,1256,1103,2138,6679,1985,3653,2770,2433,4278,615,2863,1715,242,3790,2636,6998,3088,1671,2239,957,5411,4595,6282,2881,9974,2401,875,7574,2987,4587,3147,6766,9885,2965
3287,3016,3619,6818,9073,6120,5423,557,2900,2015,8111,3873,1314,4189,1846,4399,7041,7583,2427,2864,3525,5002,2069,748,1948,6015,2684,438,770,8367,1663,7887,7759,1885,157,7770,4520,4878,3857,1137,3525,3050,6276,5569,7649,904,4533,7843,2199,5648,7628,9075,9441,3600,7231,2388,5640,9096,958,3058,584,5899,8150,1181,9616,1098,8162,6819,8171,1519,1140,7665,8801,2632,1299,9192,707,9955,2710,7314
1772,2963,7578,3541,3095,1488,7026,2634,6015,4633,4370,2762,1650,2174,909,8158,2922,8467,4198,4280,9092,8856,8835,5457,2790,8574,9742,5054,9547,4156,7940,8126,9824,7340,8840,6574,3547,1477,3014,6798,7134,435,9484,9859,3031,4,1502,4133,1738,1807,4825,463,6343,9701,8506,9822,9555,8688,8168,3467,3234,6318,1787,5591,419,6593,7974,8486,9861,6381,6758,194,3061,4315,2863,4665,3789,2201,1492,4416
126,8927,6608,5682,8986,6867,1715,6076,3159,788,3140,4744,830,9253,5812,5021,7616,8534,1546,9590,1101,9012,9821,8132,7857,4086,1069,7491,2988,1579,2442,4321,2149,7642,6108,250,6086,3167,24,9528,7663,2685,1220,9196,1397,5776,1577,1730,5481,977,6115,199,6326,2183,3767,5928,5586,7561,663,8649,9688,949,5913,9160,1870,5764,9887,4477,6703,1413,4995,5494,7131,2192,8969,7138,3997,8697,646,1028
8074,1731,8245,624,4601,8706,155,8891,309,2552,8208,8452,2954,3124,3469,4246,3352,1105,4509,8677,9901,4416,8191,9283,5625,7120,2952,8881,7693,830,4580,8228,9459,8611,4499,1179,4988,1394,550,2336,6089,6872,269,7213,1848,917,6672,4890,656,1478,6536,3165,4743,4990,1176,6211,7207,5284,9730,4738,1549,4986,4942,8645,3698,9429,1439,2175,6549,3058,6513,1574,6988,8333,3406,5245,5431,7140,7085,6407
7845,4694,2530,8249,290,5948,5509,1588,5940,4495,5866,5021,4626,3979,3296,7589,4854,1998,5627,3926,8346,6512,9608,1918,7070,4747,4182,2858,2766,4606,6269,4107,8982,8568,9053,4244,5604,102,2756,727,5887,2566,7922,44,5986,621,1202,374,6988,4130,3627,6744,9443,4568,1398,8679,397,3928,9159,367,2917,6127,5788,3304,8129,911,2669,1463,9749,264,4478,8940,1109,7309,2462,117,4692,7724,225,2312
4164,3637,2000,941,8903,39,3443,7172,1031,3687,4901,8082,4945,4515,7204,9310,9349,9535,9940,218,1788,9245,2237,1541,5670,6538,6047,5553,9807,8101,1925,8714,445,8332,7309,6830,5786,5736,7306,2710,3034,1838,7969,6318,7912,2584,2080,7437,6705,2254,7428,820,782,9861,7596,3842,3631,8063,5240,6666,394,4565,7865,4895,9890,6028,6117,4724,9156,4473,4552,602,470,6191,4927,5387,884,3146,1978,3000
4258,6880,1696,3582,5793,4923,2119,1155,9056,9698,6603,3768,5514,9927,9609,6166,6566,4536,4985,4934,8076,9062,6741,6163,7399,4562,2337,5600,2919,9012,8459,1308,6072,1225,9306,8818,5886,7243,7365,8792,6007,9256,6699,7171,4230,7002,8720,7839,4533,1671,478,7774,1607,2317,5437,4705,7886,4760,6760,7271,3081,2997,3088,7675,6208,3101,6821,6840,122,9633,4900,2067,8546,4549,2091,7188,5605,8599,6758,5229
7854,5243,9155,3556,8812,7047,2202,1541,5993,4600,4760,713,434,7911,7426,7414,8729,322,803,7960,7563,4908,6285,6291,736,3389,9339,4132,8701,7534,5287,3646,592,3065,7582,2592,8755,6068,8597,1982,5782,1894,2900,6236,4039,6569,3037,5837,7698,700,7815,2491,7272,5878,3083,6778,6639,3589,5010,8313,2581,6617,5869,8402,6808,2951,2321,5195,497,2190,6187,1342,1316,4453,7740,4154,2959,1781,1482,8256
7178,2046,4419,744,8312,5356,6855,8839,319,2962,5662,47,6307,8662,68,4813,567,2712,9931,1678,3101,8227,6533,4933,6656,92,5846,4780,6256,6361,4323,9985,1231,2175,7178,3034,9744,6155,9165,7787,5836,9318,7860,9644,8941,6480,9443,8188,5928,161,6979,2352,5628,6991,1198,8067,5867,6620,3778,8426,2994,3122,3124,6335,3918,8897,2655,9670,634,1088,1576,8935,7255,474,8166,7417,9547,2886,5560,3842
6957,3111,26,7530,7143,1295,1744,6057,3009,1854,8098,5405,2234,4874,9447,2620,9303,27,7410,969,40,2966,5648,7596,8637,4238,3143,3679,7187,690,9980,7085,7714,9373,5632,7526,6707,3951,9734,4216,2146,3602,5371,6029,3039,4433,4855,4151,1449,3376,8009,7240,7027,4602,2947,9081,4045,8424,9352,8742,923,2705,4266,3232,2264,6761,363,2651,3383,7770,6730,7856,7340,9679,2158,610,4471,4608,910,6241
4417,6756,1013,8797,658,8809,5032,8703,7541,846,3357,2920,9817,1745,9980,7593,4667,3087,779,3218,6233,5568,4296,2289,2654,7898,5021,9461,5593,8214,9173,4203,2271,7980,2983,5952,9992,8399,3468,1776,3188,9314,1720,6523,2933,621,8685,5483,8986,6163,3444,9539,4320,155,3992,2828,2150,6071,524,2895,5468,8063,1210,3348,9071,4862,483,9017,4097,6186,9815,3610,5048,1644,1003,9865,9332,2145,1944,2213
9284,3803,4920,1927,6706,4344,7383,4786,9890,2010,5228,1224,3158,6967,8580,8990,8883,5213,76,8306,2031,4980,5639,9519,7184,5645,7769,3259,8077,9130,1317,3096,9624,3818,1770,695,2454,947,6029,3474,9938,3527,5696,4760,7724,7738,2848,6442,5767,6845,8323,4131,2859,7595,2500,4815,3660,9130,8580,7016,8231,4391,8369,3444,4069,4021,556,6154,627,2778,1496,4206,6356,8434,8491,3816,8231,3190,5575,1015
3787,7572,1788,6803,5641,6844,1961,4811,8535,9914,9999,1450,8857,738,4662,8569,6679,2225,7839,8618,286,2648,5342,2294,3205,4546,176,8705,3741,6134,8324,8021,7004,5205,7032,6637,9442,5539,5584,4819,5874,5807,8589,6871,9016,983,1758,3786,1519,6241,185,8398,495,3370,9133,3051,4549,9674,7311,9738,3316,9383,2658,2776,9481,7558,619,3943,3324,6491,4933,153,9738,4623,912,3595,7771,7939,1219,4405
2650,3883,4154,5809,315,7756,4430,1788,4451,1631,6461,7230,6017,5751,138,588,5282,2442,9110,9035,6349,2515,1570,6122,4192,4174,3530,1933,4186,4420,4609,5739,4135,2963,6308,1161,8809,8619,2796,3819,6971,8228,4188,1492,909,8048,2328,6772,8467,7671,9068,2226,7579,6422,7056,8042,3296,2272,3006,2196,7320,3238,3490,3102,37,1293,3212,4767,5041,8773,5794,4456,6174,7279,7054,2835,7053,9088,790,6640
3101,1057,7057,3826,6077,1025,2955,1224,1114,6729,5902,4698,6239,7203,9423,1804,4417,6686,1426,6941,8071,1029,4985,9010,6122,6597,1622,1574,3513,1684,7086,5505,3244,411,9638,4150,907,9135,829,981,1707,5359,8781,9751,5,9131,3973,7159,1340,6955,7514,7993,6964,8198,1933,2797,877,3993,4453,8020,9349,8646,2779,8679,2961,3547,3374,3510,1129,3568,2241,2625,9138,5974,8206,7669,7678,1833,8700,4480
4865,9912,8038,8238,782,3095,8199,1127,4501,7280,2112,2487,3626,2790,9432,1475,6312,8277,4827,2218,5806,7132,8752,1468,7471,6386,739,8762,8323,8120,5169,9078,9058,3370,9560,7987,8585,8531,5347,9312,1058,4271,1159,5286,5404,6925,8606,9204,7361,2415,560,586,4002,2644,1927,2824,768,4409,2942,3345,1002,808,4941,6267,7979,5140,8643,7553,9438,7320,4938,2666,4609,2778,8158,6730,3748,3867,1866,7181
171,3771,7134,8927,4778,2913,3326,2004,3089,7853,1378,1729,4777,2706,9578,1360,5693,3036,1851,7248,2403,2273,8536,6501,9216,613,9671,7131,7719,6425,773,717,8803,160,1114,7554,7197,753,4513,4322,8499,4533,2609,4226,8710,6627,644,9666,6260,4870,5744,7385,6542,6203,7703,6130,8944,5589,2262,6803,6381,7414,6888,5123,7320,9392,9061,6780,322,8975,7050,5089,1061,2260,3199,1150,1865,5386,9699,6501
3744,8454,6885,8277,919,1923,4001,6864,7854,5519,2491,6057,8794,9645,1776,5714,9786,9281,7538,6916,3215,395,2501,9618,4835,8846,9708,2813,3303,1794,8309,7176,2206,1602,1838,236,4593,2245,8993,4017,10,8215,6921,5206,4023,5932,6997,7801,262,7640,3107,8275,4938,7822,2425,3223,3886,2105,8700,9526,2088,8662,8034,7004,5710,2124,7164,3574,6630,9980,4242,2901,9471,1491,2117,4562,1130,9086,4117,6698
2810,2280,2331,1170,4554,4071,8387,1215,2274,9848,6738,1604,7281,8805,439,1298,8318,7834,9426,8603,6092,7944,1309,8828,303,3157,4638,4439,9175,1921,4695,7716,1494,1015,1772,5913,1127,1952,1950,8905,4064,9890,385,9357,7945,5035,7082,5369,4093,6546,5187,5637,2041,8946,1758,7111,6566,1027,1049,5148,7224,7248,296,6169,375,1656,7993,2816,3717,4279,4675,1609,3317,42,6201,3100,3144,163,9530,4531
7096,6070,1009,4988,3538,5801,7149,3063,2324,2912,7911,7002,4338,7880,2481,7368,3516,2016,7556,2193,1388,3865,8125,4637,4096,8114,750,3144,1938,7002,9343,4095,1392,4220,3455,6969,9647,1321,9048,1996,1640,6626,1788,314,9578,6630,2813,6626,4981,9908,7024,4355,3201,3521,3864,3303,464,1923,595,9801,3391,8366,8084,9374,1041,8807,9085,1892,9431,8317,9016,9221,8574,9981,9240,5395,2009,6310,2854,9255
8830,3145,2960,9615,8220,6061,3452,2918,6481,9278,2297,3385,6565,7066,7316,5682,107,7646,4466,68,1952,9603,8615,54,7191,791,6833,2560,693,9733,4168,570,9127,9537,1925,8287,5508,4297,8452,8795,6213,7994,2420,4208,524,5915,8602,8330,2651,8547,6156,1812,6271,7991,9407,9804,1553,6866,1128,2119,4691,9711,8315,5879,9935,6900,482,682,4126,1041,428,6247,3720,5882,7526,2582,4327,7725,3503,2631
2738,9323,721,7434,1453,6294,2957,3786,5722,6019,8685,4386,3066,9057,6860,499,5315,3045,5194,7111,3137,9104,941,586,3066,755,4177,8819,7040,5309,3583,3897,4428,7788,4721,7249,6559,7324,825,7311,3760,6064,6070,9672,4882,584,1365,9739,9331,5783,2624,7889,1604,1303,1555,7125,8312,425,8936,3233,7724,1480,403,7440,1784,1754,4721,1569,652,3893,4574,5692,9730,4813,9844,8291,9199,7101,3391,8914
6044,2928,9332,3328,8588,447,3830,1176,3523,2705,8365,6136,5442,9049,5526,8575,8869,9031,7280,706,2794,8814,5767,4241,7696,78,6570,556,5083,1426,4502,3336,9518,2292,1885,3740,3153,9348,9331,8051,2759,5407,9028,7840,9255,831,515,2612,9747,7435,8964,4971,2048,4900,5967,8271,1719,9670,2810,6777,1594,6367,6259,8316,3815,1689,6840,9437,4361,822,9619,3065,83,6344,7486,8657,8228,9635,6932,4864
8478,4777,6334,4678,7476,4963,6735,3096,5860,1405,5127,7269,7793,4738,227,9168,2996,8928,765,733,1276,7677,6258,1528,9558,3329,302,8901,1422,8277,6340,645,9125,8869,5952,141,8141,1816,9635,4025,4184,3093,83,2344,2747,9352,7966,1206,1126,1826,218,7939,2957,2729,810,8752,5247,4174,4038,8884,7899,9567,301,5265,5752,7524,4381,1669,3106,8270,6228,6373,754,2547,4240,2313,5514,3022,1040,9738
2265,8192,1763,1369,8469,8789,4836,52,1212,6690,5257,8918,6723,6319,378,4039,2421,8555,8184,9577,1432,7139,8078,5452,9628,7579,4161,7490,5159,8559,1011,81,478,5840,1964,1334,6875,8670,9900,739,1514,8692,522,9316,6955,1345,8132,2277,3193,9773,3923,4177,2183,1236,6747,6575,4874,6003,6409,8187,745,8776,9440,7543,9825,2582,7381,8147,7236,5185,7564,6125,218,7991,6394,391,7659,7456,5128,5294
2132,8992,8160,5782,4420,3371,3798,5054,552,5631,7546,4716,1332,6486,7892,7441,4370,6231,4579,2121,8615,1145,9391,1524,1385,2400,9437,2454,7896,7467,2928,8400,3299,4025,7458,4703,7206,6358,792,6200,725,4275,4136,7390,5984,4502,7929,5085,8176,4600,119,3568,76,9363,6943,2248,9077,9731,6213,5817,6729,4190,3092,6910,759,2682,8380,1254,9604,3011,9291,5329,9453,9746,2739,6522,3765,5634,1113,5789
5304,5499,564,2801,679,2653,1783,3608,7359,7797,3284,796,3222,437,7185,6135,8571,2778,7488,5746,678,6140,861,7750,803,9859,9918,2425,3734,2698,9005,4864,9818,6743,2475,132,9486,3825,5472,919,292,4411,7213,7699,6435,9019,6769,1388,802,2124,1345,8493,9487,8558,7061,8777,8833,2427,2238,5409,4957,8503,3171,7622,5779,6145,2417,5873,5563,5693,9574,9491,1937,7384,4563,6842,5432,2751,3406,7981
#+end_src
#+begin_src odin :main no :comments link :tangle src/path_sum_two_ways.odin
package path_sum_two_ways

import "core:os"
import "core:fmt"
import "core:strings"
import "core:strconv"
import "nubs:astar"

MX :: 80
MY :: 80
load_matrix :: proc(M: ^[MY][MX]int, file: string) {
	// each line is comma sep'd values equal to a row
	data, success := os.read_entire_file_from_filename(file)
	idx := 0
	if success {
		lines, err := strings.split(string(data), "\n")
		//fmt.println(len(lines))
		if err == .None {
			for l in lines {
				vals, err2 := strings.split(l, ",")
				//fmt.println(len(vals))
				if err2 == .None && len(vals) == 80 {
					for v in vals {
						x := idx % MX
						y := idx / MX
						M[y][x],_ = strconv.parse_int(v)
						idx += 1
					}
				}
			}
		}
	}
}

Cell :: struct {
  x: int,
  y: int,
  key: int,
}

Grid :: struct {
  dim: [2]int,
  graph : astar.Graph(Cell),
	
  start: ^Cell,
  end: ^Cell,
}

cell_get_node_index :: proc(n: Cell, r: rawptr) -> int {
  return astar.get_node_index(n, r)
}
cell_key :: proc(n: Cell) -> f32 {
  return astar.key(n)
}
cell_heuristic :: proc(n, m: Cell) -> f32 {
  return astar.heuristic(n, m)
}
cell_less :: proc(a,b: Cell) -> bool {
  return astar.less(a,b)
}

reconstruct_path :: proc(grid: ^Grid, came_from: []int, cost_so_far: map[int]f32) -> (path: [dynamic][2]int) {
  current := grid.end^
    for i := 0; !(current.x == grid.start.x && current.y == grid.start.y); i += 1 {
      append(&path, [2]int{current.x, current.y})
      curr := current.y * grid.dim.x + current.x
      current.x = came_from[curr] % grid.dim.x
      current.y = came_from[curr] / grid.dim.x
    }
  append(&path, [2]int{grid.start.x, grid.start.y})
  return
}

my_edges :: proc(node_idx: int, data: rawptr, clean: bool = false) -> (ret: []int) {
	// note: this my_edges() only goes right and down
  grid_wh := transmute(^[2]int)data
  w := grid_wh[0]
  h := grid_wh[1]
  x := node_idx % w
  y := node_idx / w
  is_corner := (node_idx == 0 || node_idx == w-1 || node_idx == (h-1) * grid_wh[0] || node_idx == (w * h)-1)
  is_edge := (x == 0 || x == w-1 || y == 0 || y == h-1)
  horizontal :: proc(x, w: int) -> (int, bool) {
    if x >= 0 && x < w {
      return x, true
    }
    return 0, false
  }
  vertical :: proc(y, h: int) -> (int, bool) {
    if y >= 0 && y < h {
      return y, true
    }
    return 0, false
  }

	ret = make([]int, 2)

  xy : [2]int; oks : [2]bool
  xy[0], oks[0] = horizontal(x+1, w)
  xy[1], oks[1] = vertical(y+1, h)

  idx := 0
  for i in 0..<2 {
    if oks[i] {
      if i == 0 {
        ret[idx] = y * w + xy[i]; idx += 1
      } else {
        ret[idx] = xy[i] * w + x; idx += 1
      }
    }
  }
  return ret
}

main :: proc() {
	/*
	MX :: 5
	MY :: 5
	M := [MY][MX]int{
		{131, 673, 234, 103, 18},
		{201, 96,  342, 965, 150},
		{630, 803, 746, 422, 111},
		{537, 699, 497, 121, 956},
		{805, 732, 524, 37,  331}}
		*/
	M : [MY][MX]int
	load_matrix(&M, "matrix.txt")

	came_from : []int
  cost_so_far : map[int]f32
  path : [dynamic][2]int

	// move "matrix" to "grid"
	grid : Grid
	grid.dim.x = MX
	grid.dim.y = MY
	tmp_cells := make([]Cell, grid.dim.x * grid.dim.y)
	for x in 0..<MX {
		for y in 0..<MY {
			idx := y*MX + x
			tmp_cells[idx].x = x
			tmp_cells[idx].y = y
			tmp_cells[idx].key = M[y][x]
		}
	}
	grid.graph.nodes = tmp_cells
	grid.start = &grid.graph.nodes[0]
	grid.end = &grid.graph.nodes[MX*MY-1]
	grid.graph.data = transmute(rawptr)&[2]int{int(grid.dim.x), int(grid.dim.y)}
	grid.graph.edges = my_edges
	grid.graph.get_node_index = cell_get_node_index
	grid.graph.heuristic = cell_heuristic
	grid.graph.key = cell_key
	grid.graph.less = cell_less
	// ------------------------------

	came_from, cost_so_far = astar.search(grid.start^, grid.end^, grid.graph)
  path = reconstruct_path(&grid, came_from, cost_so_far)

	//fmt.println("path", path)
	fmt.println(cost_so_far[MY*MX-1] + f32(M[0][0])) // no cost to "get" to first cell so add it in
}
#+end_src
* Prob 082 - Path Sum: Three Ways
** prob p82
NOTE: This problem is a more challenging version of Problem 81.

The minimal path sum in the $5$ by $5$ matrix below, by starting in any cell in
the left column and finishing in any cell in the right column, and only moving
up, down, and right, is indicated in red and bold; the sum is equal to $994$.

$$\begin{pmatrix}
131 & 673 & \color{red}{234} & \color{red}{103} & \color{red}{18} \\\\
\color{red}{201} & \color{red}{96} & \color{red}{342} & 965 & 150 \\
630 & 803 & 746 & 422 & 111 \\
537 & 699 & 497 & 121 & 956 \\
805 & 732 & 524 & 37 & 331
\end{pmatrix}$$

** code p82
#+begin_src odin :main no :comments link :tangle src/path_sum_three_ways.odin
package path_sum_three_ways

import "core:os"
import "core:fmt"
import "core:math"
import "core:strings"
import "core:strconv"
import "nubs:astar"

when false {
	MX :: 5
	MY :: 5
} else {
	MX :: 80
	MY :: 80
}	

load_matrix :: proc(M: ^[80][80]int, file: string) {
	// assumes file is 80x80
	// each line is comma sep'd values equal to a row
	data, success := os.read_entire_file_from_filename(file)
	idx := 0
	if success {
		lines, err := strings.split(string(data), "\n")
		//fmt.println(len(lines))
		if err == .None {
			for l in lines {
				vals, err2 := strings.split(l, ",")
				//fmt.println(len(vals))
				if err2 == .None && len(vals) == 80 {
					for v in vals {
						x := idx % 80
						y := idx / 80
						M[y][x],_ = strconv.parse_int(v)
						idx += 1
					}
				}
			}
		}
	}
}

Cell :: struct {
  x: int,
  y: int,
  key: int,
}

Grid :: struct {
  dim: [2]int,
  graph : astar.Graph(Cell),
	
  start: ^Cell,
  end: ^Cell,
}

cell_get_node_index :: proc(n: Cell, r: rawptr) -> int {
  return astar.get_node_index(n, r)
}
cell_key :: proc(n: Cell) -> f32 {
  return astar.key(n)
}
my_heuristic :: proc(a, b: Cell) -> f32 {
	sta := MX*MY
	end := sta+1
	if (a.x == sta || b.x == sta) {
		if a.x == 0 || b.x == 0 {
			return 1
		} else {
			return 9999
		}
	}
	if (a.x == end || b.x == end) {
		if a.x == MX-1 || b.x == MX-1 {
			return 1
		} else {
			return 9999
		}
		return 1
	}
  return math.sqrt_f32(math.pow(f32(a.x - b.x), 2) + math.pow(f32(a.y - b.y), 2))
}
cell_less :: proc(a,b: Cell) -> bool {
  return astar.less(a,b)
}

reconstruct_path :: proc(grid: ^Grid, came_from: []int, cost_so_far: map[int]f32) -> (path: [dynamic][2]int) {
  current := grid.end^
    for i := 0; !(current.x == grid.start.x && current.y == grid.start.y); i += 1 {
      append(&path, [2]int{current.x, current.y})
			if current.x == 0 { // we can be done here, got back to first column
				break
			}
      curr := current.y * grid.dim.x + current.x
      current.x = came_from[curr] % grid.dim.x
      current.y = came_from[curr] / grid.dim.x
    }
  //append(&path, [2]int{grid.start.x, grid.start.y})
  return
}

my_edges :: proc(node_idx: int, data: rawptr, clean: bool = false) -> (ret: []int) {
	// note: this my_edges() only goes right and up/down
	// note2: node_idx = w*h does fake start... connects/edges up to all nodes in first column
	grid_wh := transmute(^[2]int)data
  w := grid_wh[0]
  h := grid_wh[1]
	if node_idx == w*h { // fake start
		ret = make([]int, h)
		for i in 0..<h {
			ret[i] = i*w+ 0
		}
		return ret
	}
	if node_idx > w*h { // fake end ret nothing
		return ret
	}
	
  x := node_idx % w
  y := node_idx / w
  horizontal :: proc(x, w: int) -> (int, bool) {
    if x >= 0 && x < w {
      return x, true
    }
    return 0, false
  }
  vertical :: proc(y, h: int) -> (int, bool) {
    if y >= 0 && y < h {
      return y, true
    }
    return 0, false
  }

	tret : [dynamic]int
	xy, oks := horizontal(x+1, w)
	if oks {
		append(&tret, y*w + xy)
	}
	xy, oks = vertical(y+1, h)
	if oks {
		append(&tret, xy*w + x)
	}
	xy, oks = vertical(y-1, h)
	if oks {
		append(&tret, xy*w + x)
	}
	if x == w-1 { // fake last column connects to end
		append(&tret, w*h+1)
	}

  return tret[:]
}

show_path :: proc(path: [dynamic][2]int, grid: ^Grid, cost_so_far: map[int]f32) {
	contains :: proc(path: [dynamic][2]int, x: int, y: int) -> bool {
		for p in path {
			if p.x == x && p.y == y {
				return true
			}
		}
		return false
	}
	W := grid.dim.x
	for y in 0..<grid.dim.y {
		for x in 0..<grid.dim.x {
			if contains(path, x, y) {
				//fmt.printf("\033[%vm%03v\033[0m,", 31, grid.graph.nodes[y*W+x].key)
				fmt.printf("\033[%vm%v\033[0m", 31, ".")
			} else {
				//fmt.printf("%03v,", grid.graph.nodes[y*W+x].key)
				fmt.printf(".")
			}
		}
		fmt.printf("\n")
	}
	//fmt.println("costs:")
	//for y in 0..<grid.dim.y {
	//	for x in 0..<grid.dim.x {
	//		fmt.printf("%03v,", cost_so_far[y*W+x])
	//	}
	//	fmt.printf("\n")
	//}
}

main :: proc() {
	// this version only goes up or down or right
	when MX == 5 {
		M := [MY][MX]int{
			{131, 673, 234, 103, 18},
			{201, 96,  342, 965, 150},
			{630, 803, 746, 422, 111},
			{537, 699, 497, 121, 956},
			{805, 732, 524, 37,  331}}
	} else {
		MX :: 80
		MY :: 80
		M : [MY][MX]int
		load_matrix(&M, "matrix.txt")
	}

	came_from : []int
  cost_so_far : map[int]f32
  path : [dynamic][2]int

	// move "matrix" to "grid"
	grid : Grid
	grid.dim.x = MX
	grid.dim.y = MY
	tmp_cells := make([]Cell, grid.dim.x * grid.dim.y + 2 /*for fakes*/)
	for x in 0..<MX {
		for y in 0..<MY {
			idx := y*MX + x
			tmp_cells[idx].x = x
			tmp_cells[idx].y = y
			tmp_cells[idx].key = M[y][x]
		}
	}
	grid.graph.nodes = tmp_cells
	grid.start = new(Cell) // fake grid cell to connect to starting column
	grid.start.x = MX*MY
	grid.start.y = 0
	grid.start.key = 0
	grid.end = new(Cell) // fake grid cell to connect to ending column
	grid.end.x = MX*MY+1
	grid.end.y = 0
	grid.end.key = 0
	// both start and end *NEED* to be in .nodes ... for fakes
	grid.graph.nodes[grid.start.x] = grid.start^
	grid.graph.nodes[grid.end.x] = grid.end^
	grid.graph.data = transmute(rawptr)&[2]int{int(grid.dim.x), int(grid.dim.y)}
	grid.graph.edges = my_edges
	grid.graph.get_node_index = cell_get_node_index
	grid.graph.heuristic = my_heuristic
	grid.graph.key = cell_key
	grid.graph.less = cell_less
	// ------------------------------

	came_from, cost_so_far = astar.search(grid.start^, grid.end^, grid.graph)
  path = reconstruct_path(&grid, came_from, cost_so_far)

	acc := 0
	for p in path {
		acc += grid.graph.nodes[p.y*grid.dim.x+p.x].key
	}
	fmt.println("path cost", acc)
	//show_path(path, &grid, cost_so_far)
}
#+end_src
* Prob 083 - Path Sum: Four Ways
** prob p83
NOTE: This problem is a significantly more challenging version of Problem 81.
In the $5$ by $5$ matrix below, the minimal path sum from the top left to the
bottom right, by moving left, right, up, and down, is indicated in bold red and
is equal to $2297$.

$$\begin{pmatrix}
\color{red}{131} & 673 & \color{red}{234} & \color{red}{103} & \color{red}{18} \\\\
\color{red}{201} & \color{red}{96} & \color{red}{342} & 965 & \color{red}{150} \\
630 & 803 & 746 & \color{red}{422} & \color{red}{111} \\
537 & 699 & 497 & \color{red}{121} & 956 \\
805 & 732 & 524 & \color{red}{37} & \color{red}{331}
\end{pmatrix}$$

Find the minimal path sum from the top left to the bottom right by moving left,
right, up, and down in matrix.txt, a 31K text file containing an $80$ by $80$
matrix.
** code p83
#+begin_src odin :main no :comments link :tangle src/path_sum_four_ways.odin
package path_sum_four_ways

import "core:os"
import "core:fmt"
import "core:strings"
import "core:strconv"
import "nubs:astar"

MX :: 80
MY :: 80
load_matrix :: proc(M: ^[MY][MX]int, file: string) {
	// each line is comma sep'd values equal to a row
	data, success := os.read_entire_file_from_filename(file)
	idx := 0
	if success {
		lines, err := strings.split(string(data), "\n")
		//fmt.println(len(lines))
		if err == .None {
			for l in lines {
				vals, err2 := strings.split(l, ",")
				//fmt.println(len(vals))
				if err2 == .None && len(vals) == 80 {
					for v in vals {
						x := idx % MX
						y := idx / MX
						M[y][x],_ = strconv.parse_int(v)
						idx += 1
					}
				}
			}
		}
	}
}

Cell :: struct {
  x: int,
  y: int,
  key: int,
}

Grid :: struct {
  dim: [2]int,
  graph : astar.Graph(Cell),
	
  start: ^Cell,
  end: ^Cell,
}

cell_get_node_index :: proc(n: Cell, r: rawptr) -> int {
  return astar.get_node_index(n, r)
}
cell_key :: proc(n: Cell) -> f32 {
  return astar.key(n)
}
cell_heuristic :: proc(n, m: Cell) -> f32 {
  return astar.heuristic(n, m)
}
cell_less :: proc(a,b: Cell) -> bool {
  return astar.less(a,b)
}

reconstruct_path :: proc(grid: ^Grid, came_from: []int, cost_so_far: map[int]f32) -> (path: [dynamic][2]int) {
  current := grid.end^
    for i := 0; !(current.x == grid.start.x && current.y == grid.start.y); i += 1 {
      append(&path, [2]int{current.x, current.y})
      curr := current.y * grid.dim.x + current.x
      current.x = came_from[curr] % grid.dim.x
      current.y = came_from[curr] / grid.dim.x
    }
  append(&path, [2]int{grid.start.x, grid.start.y})
  return
}

my_edges :: proc(node_idx: int, data: rawptr, clean: bool = false) -> (ret: []int) {
	// note: this my_edges() only goes right and down
  grid_wh := transmute(^[2]int)data
  w := grid_wh[0]
  h := grid_wh[1]
  x := node_idx % w
  y := node_idx / w
  is_corner := (node_idx == 0 || node_idx == w-1 || node_idx == (h-1) * grid_wh[0] || node_idx == (w * h)-1)
  is_edge := (x == 0 || x == w-1 || y == 0 || y == h-1)
  horizontal :: proc(x, w: int) -> (int, bool) {
    if x >= 0 && x < w {
      return x, true
    }
    return 0, false
  }
  vertical :: proc(y, h: int) -> (int, bool) {
    if y >= 0 && y < h {
      return y, true
    }
    return 0, false
  }

	tret : [dynamic]int
	xy, oks := horizontal(x+1, w)
	if oks {
		append(&tret, y*w + xy)
	}
	xy, oks = horizontal(x-1, w)
	if oks {
		append(&tret, y*w + xy)
	}
	xy, oks = vertical(y+1, h)
	if oks {
		append(&tret, xy*w + x)
	}
	xy, oks = vertical(y-1, h)
	if oks {
		append(&tret, xy*w + x)
	}

  return tret[:]
}

show_path :: proc(path: [dynamic][2]int, grid: ^Grid, cost_so_far: map[int]f32) {
	contains :: proc(path: [dynamic][2]int, x: int, y: int) -> bool {
		for p in path {
			if p.x == x && p.y == y {
				return true
			}
		}
		return false
	}
	W := grid.dim.x
	for y in 0..<grid.dim.y {
		for x in 0..<grid.dim.x {
			if contains(path, x, y) {
				fmt.printf("\033[%vm%03v\033[0m,", 31, grid.graph.nodes[y*W+x].key)
				//fmt.printf("\033[%vm%v\033[0m", 31, ".")
			} else {
				fmt.printf("%03v,", grid.graph.nodes[y*W+x].key)
				//fmt.printf(".")
			}
		}
		fmt.printf("\n")
	}
}

main :: proc() {
	//MX :: 5
	//MY :: 5
	//M := [MY][MX]int{
	//	{131, 673, 234, 103, 18},
	//	{201, 96,  342, 965, 150},
	//	{630, 803, 746, 422, 111},
	//	{537, 699, 497, 121, 956},
	//	{805, 732, 524, 37,  331}}
	M : [MY][MX]int
	load_matrix(&M, "matrix.txt")

	came_from : []int
  cost_so_far : map[int]f32
  path : [dynamic][2]int

	// move "matrix" to "grid"
	grid : Grid
	grid.dim.x = MX
	grid.dim.y = MY
	tmp_cells := make([]Cell, grid.dim.x * grid.dim.y)
	for x in 0..<MX {
		for y in 0..<MY {
			idx := y*MX + x
			tmp_cells[idx].x = x
			tmp_cells[idx].y = y
			tmp_cells[idx].key = M[y][x]
		}
	}
	grid.graph.nodes = tmp_cells
	grid.start = &grid.graph.nodes[0]
	grid.end = &grid.graph.nodes[MX*MY-1]
	grid.graph.data = transmute(rawptr)&[2]int{int(grid.dim.x), int(grid.dim.y)}
	grid.graph.edges = my_edges
	grid.graph.get_node_index = cell_get_node_index
	grid.graph.heuristic = cell_heuristic
	grid.graph.key = cell_key
	grid.graph.less = cell_less
	// ------------------------------

	came_from, cost_so_far = astar.search(grid.start^, grid.end^, grid.graph)
  path = reconstruct_path(&grid, came_from, cost_so_far)

	//fmt.println("path", path)
	fmt.println(cost_so_far[MY*MX-1] + f32(M[0][0])) // no cost to "get" to first cell so add it in
	//show_path(path, &grid, cost_so_far)
}
#+end_src
* Prob 084 - Monopoly Odds
** prob p84
In the game, *Monopoly*, the standard board is set up in the
following way:

[[file:src/0084_monopoly_board.png]]

A player starts on the GO square and adds the scores on two 6-sided dice to
determine the number of squares they advance in a clockwise direction. Without
any further rules we would expect to visit each square with equal probability:
2.5%. However, landing on G2J (Go To Jail), CC (community chest), and CH
(chance) changes this distribution.

In addition to G2J, and one card from each of CC and CH, that orders the player
to go directly to jail, if a player rolls three consecutive doubles, they do not
advance the result of their 3rd roll. Instead they proceed directly to jail.

At the beginning of the game, the CC and CH cards are shuffled. When a player
lands on CC or CH they take a card from the top of the respective pile and,
after following the instructions, it is returned to the bottom of the pile.
There are sixteen cards in each pile, but for the purpose of this problem we are
only concerned with cards that order a movement; any instruction not concerned
with movement will be ignored and the player will remain on the CC/CH square.


Community Chest (2/16 cards):
- Advance to GO
- Go to JAIL
Chance (10/16 cards):
- Advance to GO
- Go to JAIL
- Go to C1
- Go to E3
- Go to H2
- Go to R1
- Go to next R (railway company)
- Go to next R
- Go to next U (utility company)
- Go back 3 squares.

The heart of this problem concerns the likelihood of visiting a particular
square. That is, the probability of finishing at that square after a roll. For
this reason it should be clear that, with the exception of G2J for which the
probability of finishing on it is zero, the CH squares will have the lowest
probabilities, as 5/8 request a movement to another square, and it is the final
square that the player finishes at on each roll that we are interested in. We
shall make no distinction between "Just Visiting" and being sent to JAIL, and we
shall also ignore the rule about requiring a double to "get out of jail",
assuming that they pay to get out on their next turn.

By starting at GO and numbering the squares sequentially from 00 to 39 we can
concatenate these two-digit numbers to produce strings that correspond with sets
of squares.

Statistically it can be shown that the three most popular squares, in order, are
JAIL (6.24%) = Square 10, E3 (3.18%) = Square 24, and GO (3.09%) = Square 00. So
these three most popular squares can be listed with the six-digit modal
string: 102400.

If, instead of using two 6-sided dice, two 4-sided dice are used, find the
six-digit modal string.

** code p84
#+begin_src odin :main no :comments link :tangle src/monopoly_odds.odin
package monopoly_odds

import "core:fmt"
import "core:mem"
import "core:math"
import "core:math/rand"
import "core:strings"
import "core:reflect"
import "vendor:raylib"

UINT64_MAX :: 1<<64-1
MENU_RECT :: raylib.Rectangle{250, 10, 240, 390}

MonopolyBoard :: enum {
	GO   = 00,
	
	A1   = 01,
	CC1  = 02,
	A2   = 03,
	T1   = 04,
	R1   = 05,
	B1   = 06,
	CH1  = 07,
	B2   = 08,
	B3   = 09,
	JAIL = 10,

	C1   = 11,
	U1,
	C2,
	C3,
	R2,
	D1,
	CC2,
	D2,
	D3,
	FP,

	E1,
	CH2,
	E2,
	E3,
	R3,
	F1,
	F2,
	U2,
	F3,
	G2J,

	G1,
	G2,
	CC3,
	G3,
	R4,
	CH3,
	H1,
	T2,
	H2,
}
CommunityChest :: enum {
	AdvToGo = 0,
	GoToJail = 1,
	A = 2,
	B = 3,
	C = 4,
	D = 5,
	E = 6,
	F = 7,
	G = 8,
	H = 9,
	I = 10,
	J = 11,
	K = 12,
	L = 13,
	M = 14,
	N = 15,
}
Chance :: enum {
	AdvToGo = 0,
	GoToJail = 1,
  GoToC1 = 2,
	GoToE3 = 3,
	GoToH2 = 4,
	GoToR1 = 5,
	GoToNextRail1 = 6,
	GoToNextRail2 = 7,
	GoToNextUtil = 8,
	GoBack3Squares = 9,
	A = 10,
	B = 11,
	C = 12,
	D = 13,
	E = 14,
	F = 15,
}

Values :: struct {
	show_menu   : bool,
	width       : int,
	height      : int,
	board_texture : raylib.Texture,
	board_visits : map[int]int,
	current_cell : int,
	number_of_rolls : int,
	comm_chest : int,
	chance : int,
	doubles : int,
	speed : f32,
}

draw_menu :: proc(values: ^Values) {
  using raylib

  menu_rect := MENU_RECT
  menu_rect.x = f32(values.width) - menu_rect.x
  if !values.show_menu {
    values.show_menu = GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")
  } else {
    panel := GuiPanel(menu_rect, "")
	  values.show_menu = !GuiButton(Rectangle{f32(values.width) - 40, 13, 18, 18}, "_")

    GuiSlider(Rectangle{f32(values.width) - 185, 40, 160, 20}, "speed", "", &values.speed, 0, 1)
    str := fmt.tprintf("%0.2v", values.speed)
    cstr := strings.unsafe_string_to_cstring(str)
    GuiTextBox(Rectangle{f32(values.width) - 185, 40, 160, 20}, cstr, 10, false)
	}
}

draw_monopoly_board :: proc(values: ^Values) {
	using raylib

	// draw background board
	DrawTexture(values.board_texture, 0, 0, WHITE)

	// draw current cell
	// cells start @4,5.. they are 39x36? with 1px black border.. 11x11 board (only corners and edges are cells)
	cell_x : i32 = 0
	cell_y : i32 = 0
	cc := i32(values.current_cell)
	if cc < 11 {
		cell_x = cc
	} else if cc < 21 {
		cell_x = 10
		cell_y = cc - 10
	} else if cc < 31 {
		cell_x = cc - 20
		cell_x = 10-cell_x
		cell_y = 10
	} else {
		cell_x = 0
		cell_y = cc - 30
		cell_y = 10-cell_y
	}
	DrawText("X", cell_x*40 + 6, cell_y*37 + 6, 10, BLACK)

	// draw percentages for all cells
	h1 := 0
	h2 := 0
	h3 := 0
	for i in 0..<40 {
		ii := i32(i)
		if i < 11 {
			cell_x = ii
			cell_y = 0
		} else if i < 21 {
			cell_x = 10
			cell_y = ii - 10
		} else if i < 31 {
			cell_x = ii - 20
			cell_x = 10-cell_x
			cell_y = 10
		} else {
			cell_x = 0
			cell_y = ii - 30
			cell_y = 10-cell_y
		}
		percent := f32(values.board_visits[i]) / f32(values.number_of_rolls)
		percent_str := strings.unsafe_string_to_cstring(fmt.tprintf("%.2f", percent*100))
		DrawText(percent_str, cell_x*40 + 13, cell_y*37 + 28, 10, RED)
	}

	// draw 6 digit code of 3 most highest percentage cells
	highs := [3]int{0,0,0} // cells
	hnums := [3]int{0,0,0} // number of visits to those cells
	for k,v in values.board_visits {
		if v >= hnums[0] {
			hnums[2] = hnums[1]
			hnums[1] = hnums[0]
			hnums[0] = v
			highs[2] = highs[1]
			highs[1] = highs[0]
			highs[0] = k
		} else if v >= hnums[1] {
			hnums[2] = hnums[1]
			hnums[1] = v
			highs[2] = highs[1]
			highs[1] = k
		} else if v >= hnums[2] {
			hnums[2] = v
			highs[2] = k
		}
	}
	sixstr := fmt.tprintf("%02d%02d%02d", highs[0], highs[1], highs[2])
	sixstr2 := fmt.tprintf("%v %v %v", MonopolyBoard(highs[0]), MonopolyBoard(highs[1]), MonopolyBoard(highs[2]))
	DrawText(strings.unsafe_string_to_cstring(sixstr), 15, 430, 10, RED)
	DrawText(strings.unsafe_string_to_cstring(sixstr2), 15, 455, 10, BLACK)
	
	return
}

roll_1d6 :: proc() -> int {
	// roll a 1d6... returns 1..6
	return int(rand.uint64() / (UINT64_MAX/6)) + 1
}
roll_1d4 :: proc() -> int {
	// roll a 1d4... returns 1..4
	return int(rand.uint64() / (UINT64_MAX/4)) + 1
}

resolve_roll :: proc(values: ^Values) {
	assert(len(CommunityChest) == 16)
	assert(len(Chance) == 16)

	r1 := roll_1d4()
	r2 := roll_1d4()
	roll := r1 + r2
	is_dbl := (r1 == r2)
	values.number_of_rolls += 1
	assert(r1 > 0 && r1 <= 6)
	assert(r2 > 0 && r2 <= 6)

	if is_dbl {
		values.doubles += 1
	} else {
		values.doubles = 0 // must be consecutive
	}

	if values.doubles >= 3 {
		values.current_cell = int(MonopolyBoard.JAIL)
		values.doubles = 0
	} else {
		values.current_cell += roll
		values.current_cell %= len(MonopolyBoard)
	}

	if MonopolyBoard(values.current_cell) == .G2J {
		values.current_cell = int(MonopolyBoard.JAIL)
	}
	
	if MonopolyBoard(values.current_cell) == .CC1 ||
		MonopolyBoard(values.current_cell) == .CC2 ||
		MonopolyBoard(values.current_cell) == .CC3 { // Community Chest
			if CommunityChest(values.comm_chest) == .AdvToGo {
				values.current_cell = int(MonopolyBoard.GO)
			} else if CommunityChest(values.comm_chest) == .GoToJail {
				values.current_cell = int(MonopolyBoard.JAIL)
			}
			values.comm_chest += 1
			values.comm_chest %= len(CommunityChest)
	}
	if MonopolyBoard(values.current_cell) == .CH1 ||
		MonopolyBoard(values.current_cell) == .CH2 ||
		MonopolyBoard(values.current_cell) == .CH3 { // Chance
			if Chance(values.chance) == .AdvToGo {
				values.current_cell = int(MonopolyBoard.GO)
			} else if Chance(values.chance) == .GoToJail {
				values.current_cell = int(MonopolyBoard.JAIL)
			} else if Chance(values.chance) == .GoToC1 {
				values.current_cell = int(MonopolyBoard.C1)
			} else if Chance(values.chance) == .GoToE3 {
				values.current_cell = int(MonopolyBoard.E3)
			} else if Chance(values.chance) == .GoToH2 {
				values.current_cell = int(MonopolyBoard.H2)
			} else if Chance(values.chance) == .GoToR1 {
				values.current_cell = int(MonopolyBoard.R1)
			} else if Chance(values.chance) == .GoToNextRail1 ||
				Chance(values.chance) == .GoToNextRail2 {
					if values.current_cell < int(MonopolyBoard.R1) {
						values.current_cell = int(MonopolyBoard.R1)
					} else if values.current_cell < int(MonopolyBoard.R2) {
						values.current_cell = int(MonopolyBoard.R2)
					} else if values.current_cell < int(MonopolyBoard.R3) {
						values.current_cell = int(MonopolyBoard.R3)
					} else if values.current_cell < int(MonopolyBoard.R4) {
						values.current_cell = int(MonopolyBoard.R4)
					} else {
						values.current_cell = int(MonopolyBoard.R1)
					}
				} else if Chance(values.chance) == .GoToNextUtil {
					if values.current_cell < int(MonopolyBoard.U1) {
						values.current_cell = int(MonopolyBoard.U1)
					} else if values.current_cell < int(MonopolyBoard.U2) {
						values.current_cell = int(MonopolyBoard.U2)
					} else {
						values.current_cell = int(MonopolyBoard.U1)
					}
				} else if Chance(values.chance) == .GoBack3Squares {
					values.current_cell -= 3
				}
			
			values.chance += 1
			values.chance %= len(Chance)
		}

	assert(values.current_cell >= 0 && values.current_cell < len(MonopolyBoard))
	values.board_visits[values.current_cell] += 1
}

main :: proc() {
	using raylib

	ta := mem.Tracking_Allocator{};
	mem.tracking_allocator_init(&ta, context.allocator);
	context.allocator = mem.tracking_allocator(&ta);
	defer {
		if len(ta.allocation_map) > 0 {
			for _, v in ta.allocation_map {
				fmt.printf("Leaked %v bytes @ %v\n", v.size, v.location);
			}
		}
		if len(ta.bad_free_array) > 0 {
			fmt.println("Bad frees:");
			for v in ta.bad_free_array {
				fmt.println(v);
			}
		}
	}
	// ------------------------------
	{
		values : Values
		values.show_menu = false
		values.width = 600
		values.height = 500
		values.speed = 1


		InitWindow(i32(values.width), i32(values.height), "Window_Title")
		SetTargetFPS(60)

		values.board_texture = LoadTexture("0084_monopoly_board.png")
		board_cell_names := reflect.enum_field_names(MonopolyBoard)
		defer delete(values.board_visits)

		cnt : f32 = 60
		for !WindowShouldClose() {
			// Update ------------------------------
			if cnt <= 0 {
				for i:=0; i>=int(cnt); i-=1 {
					resolve_roll(&values)
				}
				cnt = 60
			} else {
				cnt -= (values.speed * 10_000 + 1)
			}
			
			// Draw   ------------------------------
			BeginDrawing()
			ClearBackground(WHITE)

			draw_monopoly_board(&values)
			draw_menu(&values)
			
			EndDrawing()
		}
		//fmt.println(int(MonopolyBoard.E3))
		CloseWindow()
	}
}
#+end_src
* Prob 085 - Counting Rectangles
** prob p85
By counting carefully it can be seen that a rectangular grid measuring $3$ by
$2$ contains eighteen rectangles:

[[file:src/0085.png]]

Although there exists no rectangular grid that contains exactly two million
rectangles, find the area of the grid with the nearest solution.

      1  2h  3h  2v  2x2  3x2
------------------------------      
2x1 = 2 + 1                    = 3
2x2 = 4 + 2     + 2 + 1        = 9

3x1 = 3 + 2 + 1                = 6
3x2 = 6 + 4 + 2 + 3 + 2 + 1    = 18
------------------------------

4x1 = 4 + 3 + 2 + 1            = 10 --
4x2 = 8 + 6 + 4 + 2    + 4 + 3 + 2 + 1 = 30
4x3 = 12 + 9 + 6 + 3   + 8 + 6 + 4 + 2   + 4 + 3 + 2 + 1 = 60
4x4 = 16 + 12 + 8 + 4  + 12 + 9 + 6 + 3  + 8 + 6 + 4 + 2  + 4 + 3 + 2 + 1 = 100

Kx1 = \Sigma(K to 1)
KxJ = \Sigma(K to 1) * J + Kx(J-1)

** code p85
#+begin_src odin :main no :comments link :tangle src/counting_rectangles.odin
package counting_rectangles

import "core:fmt"
import "core:math"

sum :: proc(k: int) -> int {
	// sum 1..=k
	//          v overflows?
	sum := (k * (1 + k)) / 2
	//sum := (k/2) + (k/2*k)
	assert(sum > 0)
	return sum
}
// Kx1 = \Sigma(K to 1)
// KxJ = J * \Sigma(K to 1) + Kx(J-1)
// K is width(# of columns) and J is height(# of rows)
cnt_rects :: proc(k: int, j: int, prev: int) -> int {
	s := sum(k)
	cnt := j * s + prev
	assert(cnt > 0)
	return cnt
}

main :: proc() {
	nearest := 2_000_000 // nearest so far
	nearest_x, nearest_y := 0,0
	two_mil :: 2_000_000

 	NOF :: 20
	found : [NOF]bool // to poop out after not finding a nearest after NOF tries
  fshift :: proc(f: ^[NOF]bool) {
		for i in 0..<(NOF-1) {
			f[i] = f[i+1]
		}
		f[NOF-1] = false
	}
	ffalse :: proc(f: ^[NOF]bool) -> bool {
		for i in 0..<NOF {
			if f[i] do return true
		}
		return false
	}
	
	for x:=1;; x+=1 { // inf loop
		prev := sum(x)
		//fmt.println(x,1,prev)
		for y:=2; y<=x; y+=1 {
			cnt := cnt_rects(x, y, prev)
			dist := math.abs(two_mil - cnt)
			if dist < nearest {
				nearest = dist
				nearest_x = x
				nearest_y = y
				found[NOF-1] = true
			}
			prev = cnt
			//fmt.println(x,y, cnt)
		}
		fshift(&found)
		if x > 1 && !ffalse(&found) do break
	}
	fmt.println(nearest_x, nearest_y, nearest_x * nearest_y)
}
#+end_src
* Prob 086 - Cuboid Route
** prob p86
A spider, S, sits in one corner of a cuboid room, measuring $6$ by $5$ by $3$,
and a fly, F, sits in the opposite corner. By travelling on the surfaces of the
room the shortest "straight line" distance from S to F is $10$ and the path is
shown on the diagram.

[[file:src/0086.png]]

However, there are up to three "shortest" path candidates for any given cuboid
and the shortest route doesn't always have integer length.

It can be shown that there are exactly $2060$ distinct cuboids, ignoring
rotations, with integer dimensions, up to a maximum size of $M$ by $M$ by $M$,
for which the shortest route has integer length when $M = 100$. This is the
least value of $M$ for which the number of solutions first exceeds two thousand;
the number of solutions when $M = 99$ is $1975$.

Find the least value of $M$ such that the number of solutions first exceeds one
million.


spider dist = sqrt( 6^2 + (5+3)^2 ) = 10
think: "unfold" / "lay flat" a cardboard box and connect points with straight line

** code p86
#+begin_src odin :main no :comments link :tangle src/cuboid_route.odin
package cuboid_route

import "core:fmt"
import "core:container/rbtree"

// x > y > z
// when is:  sqrt( x^2 + (y+z)^2 ) = an integer?
// when x^2 + (y+z)^2 is in a list of squares?

// red/black tree used for squares in an effort to speed things up
// not sure if it is even worth it though =(
make_squares_tree :: proc(size: int, ret: ^rbtree.Tree(int,int)) {
	for i:=1; i<=size; i+=1 {
		sqr := i*i
		rbtree.find_or_insert(ret, sqr, sqr)
	}
}

main :: proc() {
	MSIZE :: 100_000 // 99
	ONEMIL :: 1_000_000
	
	sqr_tree : rbtree.Tree(int,int)
	rbtree.init(&sqr_tree)
	make_squares_tree(3*MSIZE, &sqr_tree) // just guessing 3*MSIZE should be enuf!

	M := 0
	cnt := 0
	found := false
	//for M=1; M<=MSIZE; M+=1 {
	for M=1; !found; M+=1 {
		x := M
		for y:=1; y<=x; y+=1 {
			for z:=1; z<=y; z+=1 {
				num := x*x + (y+z)*(y+z)
				isin := rbtree.find(&sqr_tree, num)
				if isin != nil {
					//fmt.println(x, y, z,"  ", num)
					cnt += 1
					if cnt > ONEMIL {
						found = true
					}
				}
			}
		}
	}
	fmt.println(M-1, cnt)
}
#+end_src
* Prob 087 - Prime Power Triples
** prob p87
The smallest number expressible as the sum of a prime square, prime cube, and
prime fourth power is $28$. In fact, there are exactly four numbers below fifty
that can be expressed in such a way:

$$\begin{aligned}
28 &= 2^2 + 2^3 + 2^4 \\
33 &= 3^2 + 2^3 + 2^4 \\
49 &= 5^2 + 2^3 + 2^4 \\
47 &= 2^2 + 3^3 + 2^4
\end{aligned}$$

How many numbers below fifty million can be expressed as the sum of a prime
square, prime cube, and prime fourth power?

** code p87
#+begin_src odin :main no :comments link :tangle src/prime_power_triples.odin
package prime_power_triples

import "core:fmt"
import "core:math"
import "../util"

root_n_guess :: proc(num: int, n: int) -> int {
	for i in 1..<num/2 {
		if math.pow(f32(i), f32(n)) > f32(num) {
			return i-1
		}
	}
	return 0
}

main :: proc() {
	BELOW :: 50_000_000
	nums : map[int]([3]int)
	
	i := 2
	j := 2
	k := 2

	iMAX := root_n_guess(BELOW, 2)
	jMAX := root_n_guess(BELOW, 3)
	kMAX := root_n_guess(BELOW, 4)
	
	for ; k<=kMAX; {
		j = 2
		for ; j<=jMAX; {
			i = 2
			for ; i<=iMAX; {
				//fmt.println("testing", i, j, k)
				equ := i*i + j*j*j + k*k*k*k
				if equ < BELOW {
					nums[equ] = [3]int{i,j,k}
				}
				i += 1
				for ; !util.is_prime(i); i+=1 {} // set i to next prime
			}
			j += 1
			for ; !util.is_prime(j); j+=1 {} // set j to next prime
		}
		k += 1
		for ; !util.is_prime(k); k+=1 {} // set k to next prime
	}
	fmt.println(len(nums))
}
#+end_src
